<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.315">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2022-12-27">

<title>Seoyeon’s Blog - [CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Seoyeon’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/md/"> 
<span class="menu-text">Lectures</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/chch/"> 
<span class="menu-text">Lectures_fastai</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/blog/"> 
<span class="menu-text">Research_ing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/ms/"> 
<span class="menu-text">Research_fastai</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/seoyeonc"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><strong>[CGSP]</strong> Chap 12.2 ~ 3: Power Spectral Density and its Estimators</li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title"><strong>[CGSP]</strong> Chap 12.2 ~ 3: Power Spectral Density and its Estimators</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>신록예찬 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 27, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../1_note.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><strong>Note</strong></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text"><strong>Studies</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../2_graph.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Graph</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../2_quantum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quantum</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../2_pyg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Pyg</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text"><strong>Researches</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../3_ittgnn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ITTGNN</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../3_gode.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">GODE</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../3_hcam.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">HCAM</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preliminary-study" id="toc-preliminary-study" class="nav-link active" data-scroll-target="#preliminary-study">Preliminary Study</a></li>
  <li><a href="#vectorization-mathematics" id="toc-vectorization-mathematics" class="nav-link" data-scroll-target="#vectorization-mathematics">Vectorization (mathematics)</a>
  <ul class="collapse">
  <li><a href="#kronecker-product" id="toc-kronecker-product" class="nav-link" data-scroll-target="#kronecker-product">Kronecker product</a></li>
  <li><a href="#khatrirao-product" id="toc-khatrirao-product" class="nav-link" data-scroll-target="#khatrirao-product">Khatri–Rao product</a></li>
  <li><a href="#그래프-표현" id="toc-그래프-표현" class="nav-link" data-scroll-target="#그래프-표현">그래프 표현</a></li>
  <li><a href="#gso" id="toc-gso" class="nav-link" data-scroll-target="#gso">GSO</a></li>
  </ul></li>
  <li><a href="#power-spectral-density" id="toc-power-spectral-density" class="nav-link" data-scroll-target="#power-spectral-density">12.2.1. Power Spectral Density</a></li>
  <li><a href="#power-spectral-density-estimators" id="toc-power-spectral-density-estimators" class="nav-link" data-scroll-target="#power-spectral-density-estimators">12.3. Power Spectral Density Estimators</a></li>
  <li><a href="#nonparametric-psd-estimators" id="toc-nonparametric-psd-estimators" class="nav-link" data-scroll-target="#nonparametric-psd-estimators">12.3.1. Nonparametric PSD estimators</a>
  <ul class="collapse">
  <li><a href="#periodogram-correlogram-and-ls-estimator" id="toc-periodogram-correlogram-and-ls-estimator" class="nav-link" data-scroll-target="#periodogram-correlogram-and-ls-estimator">Periodogram, correlogram, and LS estimator</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a>
  <ul class="collapse">
  <li><a href="#정상시계열을-분석하는-두-가지-흐름-acf와-psd" id="toc-정상시계열을-분석하는-두-가지-흐름-acf와-psd" class="nav-link" data-scroll-target="#정상시계열을-분석하는-두-가지-흐름-acf와-psd">정상시계열을 분석하는 두 가지 흐름, ACF와 PSD</a>
  <ul class="collapse">
  <li><a href="#전통적인-분석방법" id="toc-전통적인-분석방법" class="nav-link" data-scroll-target="#전통적인-분석방법">전통적인 분석방법</a></li>
  <li><a href="#스펙트럼-방법" id="toc-스펙트럼-방법" class="nav-link" data-scroll-target="#스펙트럼-방법">스펙트럼 방법</a></li>
  <li><a href="#전통적인-방법과-스펙트럼-방법의-비교" id="toc-전통적인-방법과-스펙트럼-방법의-비교" class="nav-link" data-scroll-target="#전통적인-방법과-스펙트럼-방법의-비교">전통적인 방법과 스펙트럼 방법의 비교</a></li>
  </ul></li>
  <li><a href="#그래프신호에서의-psd의-추정" id="toc-그래프신호에서의-psd의-추정" class="nav-link" data-scroll-target="#그래프신호에서의-psd의-추정">그래프신호에서의 PSD의 추정</a>
  <ul class="collapse">
  <li><a href="#bf-c_bf-xbf-v-textdiagbf-pbf-vh" id="toc-bf-c_bf-xbf-v-textdiagbf-pbf-vh" class="nav-link" data-scroll-target="#bf-c_bf-xbf-v-textdiagbf-pbf-vh">1. <span class="math inline">\({\bf C}_{\bf x}={\bf V} \text{diag}({\bf p}){\bf V}^H\)</span></a></li>
  <li><a href="#bf-pmathbbeleftbf-vhbf-x2right" id="toc-bf-pmathbbeleftbf-vhbf-x2right" class="nav-link" data-scroll-target="#bf-pmathbbeleftbf-vhbf-x2right">2. <span class="math inline">\({\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\)</span></a></li>
  <li><a href="#bf-c_bf-x-bf-g_np-bf-p" id="toc-bf-c_bf-x-bf-g_np-bf-p" class="nav-link" data-scroll-target="#bf-c_bf-x-bf-g_np-bf-p">3. <span class="math inline">\({\bf c}_{\bf x} = {\bf G}_{np} {\bf p}\)</span></a></li>
  </ul></li>
  <li><a href="#의문점" id="toc-의문점" class="nav-link" data-scroll-target="#의문점">의문점</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="2022-12-27-Chap-12.2.1~12.3.1.out.ipynb" download="2022-12-27-Chap-12.2.1~12.3.1.out.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">




<div id="b124476d-3ceb-46a1-acab-309755a73584" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span>, <span class="bu">Plots</span>, <span class="bu">FFTW</span>, <span class="bu">Statistics</span></span></code></pre></div>
</div>
<section id="preliminary-study" class="level1">
<h1>Preliminary Study</h1>
</section>
<section id="vectorization-mathematics" class="level1 page-columns page-full">
<h1>Vectorization (mathematics)</h1>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/3ba6d811-8d79-45ed-83e4-43eae9f427e5-1-46db00cb-96a5-45b0-b8c4-3042c7e3bc33.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">위키에서 긁은 그림</figcaption>
</figure>
</div>
<p>(예제)</p>
<div id="ddc67096-95e3-4dec-aaf0-1febf130ba55" class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">=</span> [<span class="fl">1</span> <span class="fl">2</span> </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="fl">3</span> <span class="fl">4</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="80">
<pre><code>2×2 Matrix{Int64}:
 1  2
 3  4</code></pre>
</div>
</div>
<div id="0117adf4-6e0a-4464-8248-46e76a1be29b" class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">vec</span>(A)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">
<pre><code>4-element Vector{Int64}:
 1
 3
 2
 4</code></pre>
</div>
</div>
<section id="kronecker-product" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="kronecker-product">Kronecker product</h2>
<p>크로네커곱의 정의는 아래와 같다.</p>
<p><span class="math display">\[{\bf A} \otimes {\bf B}
=\begin{bmatrix}
a_{11}{\bf B} &amp; a_{12}{\bf B} &amp; \dots &amp; a_{1m}{\bf B} \\
a_{21}{\bf B} &amp; a_{22}{\bf B} &amp; \dots &amp; a_{2m}{\bf B} \\
\dots &amp; \dots &amp; \dots &amp; \dots \\
a_{n1}{\bf B} &amp; a_{n2}{\bf B} &amp; \dots &amp; a_{nm}{\bf B} \\
\end{bmatrix}\]</span></p>
<p>두 행렬 <span class="math inline">\({\bf A}_{m\times n}\)</span>, <span class="math inline">\({\bf B}_{p\times q}\)</span>의 크로네커곱 <span class="math inline">\({\bf A}\otimes {\bf B}\)</span>의 차원은 <span class="math inline">\(mp \times nq\)</span> 가 된다. 계산예시는 아래와 같다.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/5663bf73-f717-4d07-96e8-c926fb6359c0-1-856d291e-9401-4ca2-84e0-269d7cd2eac7.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">위키에서 긁은 예제, 글씨가 좀 작음</figcaption>
</figure>
</div>
<p>크로네커곱에 대한 성질들이 위키에 많이 있으니 참고하면 좋다.</p>
<p>(예제1)</p>
<div id="fce34661-fb80-41ef-ae37-3a3ab10907c8" class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">=</span> [<span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="fl">3</span> <span class="fl">4</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>B<span class="op">=</span> [<span class="fl">0</span> <span class="fl">5</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="fl">6</span> <span class="fl">7</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> <span class="fu">kron</span>(A, B)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="82">
<pre><code>4×4 Matrix{Int64}:
  0   5   0  10
  6   7  12  14
  0  15   0  20
 18  21  24  28</code></pre>
</div>
</div>
<p>(예제2)</p>
<div id="c2196d92-ac7f-47b1-8e37-0f9baf31e478" class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">=</span> [<span class="fl">1</span> <span class="op">-</span><span class="fl">4</span> <span class="fl">7</span>; <span class="op">-</span><span class="fl">2</span> <span class="fl">3</span> <span class="fl">3</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>B<span class="op">=</span> [<span class="fl">8</span> <span class="op">-</span><span class="fl">9</span> <span class="op">-</span><span class="fl">6</span> <span class="op">-</span><span class="fl">5</span>; <span class="fl">1</span> <span class="op">-</span><span class="fl">3</span> <span class="op">-</span><span class="fl">4</span> <span class="fl">7</span>; <span class="fl">2</span> <span class="fl">8</span> <span class="op">-</span><span class="fl">8</span> <span class="op">-</span><span class="fl">3</span>; <span class="fl">1</span> <span class="fl">2</span> <span class="op">-</span><span class="fl">5</span> <span class="op">-</span><span class="fl">1</span>]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> <span class="fu">kron</span>(A, B)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="83">
<pre><code>8×12 Matrix{Int64}:
   8   -9  -6   -5  -32   36   24   20  56  -63  -42  -35
   1   -3  -4    7   -4   12   16  -28   7  -21  -28   49
   2    8  -8   -3   -8  -32   32   12  14   56  -56  -21
   1    2  -5   -1   -4   -8   20    4   7   14  -35   -7
 -16   18  12   10   24  -27  -18  -15  24  -27  -18  -15
  -2    6   8  -14    3   -9  -12   21   3   -9  -12   21
  -4  -16  16    6    6   24  -24   -9   6   24  -24   -9
  -2   -4  10    2    3    6  -15   -3   3    6  -15   -3</code></pre>
</div>
</div>
</section>
<section id="khatrirao-product" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="khatrirao-product">Khatri–Rao product</h2>
<p>카트리-라오곱은 매트릭스 <span class="math inline">\({\bf A}\)</span>와 <span class="math inline">\({\bf B}\)</span>가 같은 차원의 블락매트릭스로 정의될때 각 서브매트릭스의 크로네커 곱으로 정의된다. 정의와 계산예시는 아래와 같다.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/9b272351-038c-40ff-91d7-c16abab167be-1-7617bfb3-8b35-4b60-a609-25a593b62838.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">예시1: 위키에서 긁은 그림</figcaption>
</figure>
</div>
<p>또 다른 계산예시는 아래와 같다. 이 예제는 중요하니까 구현해보자.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/dafb4ee2-42f6-4570-901b-d2fcc05cde32-1-f7f2fde4-ceb3-41e1-8580-036cb36951cc.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">예시2: 위키에서 긁은 그림</figcaption>
</figure>
</div>
<p>(예제1)</p>
<div id="bdf45953-56e0-4dc8-a7c6-04ec072ddbcb" class="cell" data-execution_count="302">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>C<span class="op">=</span> [<span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span> </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="fl">4</span> <span class="fl">5</span> <span class="fl">6</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="fl">7</span> <span class="fl">8</span> <span class="fl">9</span>] </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>D<span class="op">=</span> [<span class="fl">1</span> <span class="fl">4</span> <span class="fl">7</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="fl">2</span> <span class="fl">5</span> <span class="fl">8</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="fl">3</span> <span class="fl">6</span> <span class="fl">9</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="302">
<pre><code>3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9</code></pre>
</div>
</div>
<div id="a0069f8b-76ff-487b-b1a6-a90b539fad5d" class="cell" data-execution_count="303">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">hcat</span>([<span class="fu">kron</span>(C[<span class="op">:</span>,i],D[<span class="op">:</span>,i]) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>]<span class="op">...</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="303">
<pre><code>9×3 Matrix{Int64}:
  1   8  21
  2  10  24
  3  12  27
  4  20  42
  8  25  48
 12  30  54
  7  32  63
 14  40  72
 21  48  81</code></pre>
</div>
</div>
<p>이건 자주 쓸일이 있을것 같으니까 함수로 저장하자.</p>
<div id="dbd0e94f-85c1-4f89-8fc3-ece199203c28" class="cell" data-execution_count="304">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>columnwise_kron <span class="op">=</span> </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>(C,D) <span class="op">-&gt;</span> <span class="fu">hcat</span>([<span class="fu">kron</span>(C[<span class="op">:</span>,i],D[<span class="op">:</span>,i]) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(C)[<span class="fl">2</span>]]<span class="op">...</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="304">
<pre><code>#181 (generic function with 1 method)</code></pre>
</div>
</div>
<div id="7da92998-4ba4-4679-ae0e-73887b567878" class="cell" data-execution_count="305">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">columnwise_kron</span>(C,D)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="305">
<pre><code>9×3 Matrix{Int64}:
  1   8  21
  2  10  24
  3  12  27
  4  20  42
  8  25  48
 12  30  54
  7  32  63
 14  40  72
 21  48  81</code></pre>
</div>
</div>
</section>
<section id="그래프-표현" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="그래프-표현">그래프 표현</h2>
<p>아래의 그림을 살펴보자.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/e84c0f89-f543-4774-bd0d-5568789826ba-1-ce19ffd8-4444-440d-a260-1e7279de12dc.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">그래프의 개념을 이해하는 필요한 그림, 일단 오른쪽의 <span class="math inline">\({\bf S}\)</span>는 무시할 것</figcaption>
</figure>
</div>
<p>오른쪽의 <span class="math inline">\({\bf S}\)</span>는 무시하고 왼쪽의 그래프만 살펴보자. 이 그림에는 6개의 노드가 있고 각각의 노드는 저 마다의 연결구조를 가진다. 이러한 연결구조는 <span class="math inline">\({\bf G}=({\bf N},{\bf E})\)</span> 으로 표현할 수 있는데 여기에서 <span class="math inline">\({\bf N}\)</span>은 노드들의 집합이고 <span class="math inline">\({\bf E}\)</span>는 엣지들의 집합이다.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 보통 <span class="math inline">\({\cal E}\)</span>는 복잡하므로 연결정보를 매트릭스 <span class="math inline">\({\bf E}\)</span>로 표현하는데 이러한 <span class="math inline">\({\bf E}\)</span>를 인접행렬이라고 부른다. 인접행렬의 각 원소는 <span class="math inline">\(E_{ij}= \begin{cases} 1 &amp; (i,j) \in {\cal E} \\ 0 &amp; o.w \end{cases}\)</span> 와 같이 정의한다. 이 그림의 경우 <span class="math inline">\({\cal N}\)</span> 와 <span class="math inline">\({\cal E}\)</span>, <span class="math inline">\({\bf E}\)</span> 는 아래와 같다.</p>
<div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;노드 <span class="math inline">\(i\)</span>에서 노드 <span class="math inline">\(j\)</span>로 향하는 연결이 있다면 <span class="math inline">\((i,j) \in {\cal E}\)</span>이다.</p></li></div><ul>
<li><p><span class="math inline">\({\cal N}=\{1,2,3,4,5,6\}\)</span></p></li>
<li><p><span class="math inline">\({\bf E}=\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}\)</span></p></li>
<li><p><span class="math inline">\({\cal E} = \{(i,j) : E_{ij}=1 \}\)</span></p></li>
</ul>
</section>
<section id="gso" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="gso">GSO</h2>
<p>후에 자세히 서술하겠지만 전통적인 시계열분석기법을 그래프신호로 확장하기 위해서는 단지 퓨리에변환 대신에 그래프퓨리에 변환을 사용하면 된다. 즉 퓨리에변환을 일반화한 그래프퓨리에변환을 잘 정의하면 된다.</p>
<p>전통적인 신호처리 영역에서의 퓨리에변환은 시계열자료의 인접성을 의미하는 행렬 <span class="math inline">\({\bf B}\)</span><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>의 고유행렬의 켤레전치로 정의할 수 있다. 이를 이용하면 그래프 퓨리에변환은 그래프자료의 인접성을 의미하는 행렬<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>의 고유행렬의 켤레전치로 정의할 수 있음을 유추할 수 있다. 즉 비유클리드 자료에서도 <span class="math inline">\({\bf B}\)</span>에 대응하는 어떠한 매트릭스가 정의되어야 하는데 (그리고 이 매트릭스는 그래프자료의 인접성에 대한 정보가 있어야 한다) 이 매트릭스를 <span class="math inline">\({\bf S}\)</span>라고 정의하고 <strong>grahp shift operator (GSO)</strong> 라고 이름 붙인다.</p>
<div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;원래는 평행이동을 의미하는 행렬이지만, 이걸 인접성을 의미하는 행렬로 해석할 수도 있다. 어차피 인접한 곳으로 이동할 수 있으니까..</p></li><li id="fn3"><p><sup>3</sup>&nbsp;예를들면 인접행렬 <span class="math inline">\({\bf E}\)</span>와 같은 행렬</p></li></div><p>주어진 그래프 <span class="math inline">\({\cal G}=({\cal N},{\cal E})\)</span> 에 대하여 GSO <span class="math inline">\({\bf S}\)</span>는 <span class="math inline">\({\bf E}+{\bf I}\)</span>의 값이 1인 영역에만 값이 있는 어떠한 행렬이다. 다시 아래의 그림을 생각하여 보자.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/9285f6b0-90b1-41de-b928-b86bb3055f89-1-ce19ffd8-4444-440d-a260-1e7279de12dc.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">GSO의 개념을 이해하는데 필요한 그림</figcaption>
</figure>
</div>
<p>왼쪽그래프의 GSO는 오른쪽과 같은 행렬 <span class="math inline">\({\bf S}\)</span>가 된다. 이제 <span class="math inline">\({\bf S}\)</span> 의 고유벡터행렬을 구한 뒤에 그것의 켤레전치를 <span class="math inline">\({\bf GFT}\)</span> 행렬로 정의하면 될 것 같다. 문제는 “<span class="math inline">\({\bf S}\)</span>의 고유벡터행렬이 항상 존재하는가?” 인데, 사실 이게 항상 존재한다는 보장이 없다. 즉 <span class="math inline">\({\bf S}\)</span>의 고유벡터 행렬이 존재 안할 수도 있다. 따라서 GSO <span class="math inline">\({\bf S}\)</span>가 고유분해가능하다는 조건이 추가적으로 필요한데 이러한 조건을 만족하는 GSO를 normal GSO라고 부른다. 우리는 당연히 normal GSO에 대해서만 관심이 있으므로 앞으로 특별한 언급이 없는한 GSO는 모두 normal GSO라고 가정한다.</p>
</section>
</section>
<section id="power-spectral-density" class="level1 page-columns page-full">
<h1>12.2.1. Power Spectral Density</h1>
<blockquote class="blockquote page-columns page-full">
<p><span class="citation" data-cites="djuric2018cooperative">Djuric and Richard (<a href="#ref-djuric2018cooperative" role="doc-biblioref">2018</a>)</span> 의 Chap 12.2.1, Chap 12.3</p>
<div class="no-row-height column-margin column-container"><div id="ref-djuric2018cooperative" class="csl-entry" role="listitem">
Djuric, Petar, and Cédric Richard. 2018. <em>Cooperative and Graph Signal Processing: Principles and Applications</em>. Academic Press.
</div></div></blockquote>
<p><strong>Definition 12.3.</strong> The PSD of a random process <span class="math inline">\({\bf x}\)</span> that is stationary with respect to GSO <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span> is the nonnegative <span class="math inline">\(N \times 1\)</span> vector <span class="math inline">\({\bf p}\)</span></p>
<p><span class="math display">\[{\bf p}:=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big).\]</span></p>
<p>OversObserve that because <span class="math inline">\({\bf C}_{\bf x}\)</span> is diagonalized by <span class="math inline">\({\bf V}\)</span> the matrix <span class="math inline">\({\bf V}^H{\bf C}_{\bf x}{\bf V}\)</span> is diagonal and it follows that the PSD in above equation corresponds to the eigenvalues of the positive semidefinite covariance matrix <span class="math inline">\({\bf C}_{\bf x}\)</span>. Thus, above equation is equivalent to</p>
<p><span class="math display">\[{\bf C}_{\bf x}={\bf V}\text{diag}({\bf p}){\bf V}^H.\]</span></p>
<p>Zero-mean white noise is an example of a random process that is stationary with respect to any graph shift <span class="math inline">\({\bf S}\)</span>. The PSD of white noise with covariance <span class="math inline">\(\mathbb{E}[{\bf n}{\bf n}^H] = \sigma^2{\bf I}\)</span> is <span class="math inline">\({\bf p} = \sigma^2{\bf 1}\)</span><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Also notice that, by definition, any random process <span class="math inline">\({\bf x}\)</span> is stationary with respect to the shift <span class="math inline">\({\bf S} = {\bf C}_{\bf x}\)</span> defined by its covariance matrix, with corresponding PSD <span class="math inline">\({\bf p} = \text{diag}({\bf \Lambda})\)</span>. This can be exploited in the context of network topology inference. Given a set of graph signals <span class="math inline">\(\{{\bf x}_r\}_{r=1}^R\)</span> it is common to infer the underlying topology by building a graph <span class="math inline">\({\cal G}_{corr}\)</span> whose edge weights correspond to cross-correlations among the entries of the signals. In that case, the process generating those signals is stationary in the shift given by the adjacency of <span class="math inline">\({\cal G}_{corr}\)</span>; see <span class="citation" data-cites="segarra2017network">Segarra et al. (<a href="#ref-segarra2017network" role="doc-biblioref">2017</a>)</span> for details. A random process x is also stationary with respect to the shift given by its precision matrix, which is defined as the (pseudo-)inverse <span class="math inline">\({\bf \Theta}= {\bf C}^{\dagger}_{\bf x}\)</span>. The PSD, in this case, is <span class="math inline">\({\bf p} = \text{diag}(\Lambda)^{\dagger}\)</span>. This is particularly important when <span class="math inline">\({\bf x}\)</span> is a Gaussian Markov Random Field (GMRF) whose Markovian dependence is captured by the unweighted graph <span class="math inline">\({\cal G}_{MF}\)</span>. It is well known <span class="citation" data-cites="segarra2017network">Segarra et al. (<a href="#ref-segarra2017network" role="doc-biblioref">2017</a>)</span> Ch. 19 that in these cases <span class="math inline">\({\bf \Theta}_{i,j}\)</span> can be nonzero only if <span class="math inline">\((i,j)\)</span> is either a link of <span class="math inline">\({\cal G}_{MF}\)</span> , or an element in the diagonal. Thus, any GMRF is stationary with respect to the sparse shift <span class="math inline">\({\bf S} = {\bf \Theta}\)</span>, which captures the conditional dependence between the elements of <span class="math inline">\({\bf x}\)</span>. Two important properties that hold for random processes in time can be shown to be true as well for the PSD of graph processes.</p>
<div class="no-row-height column-margin column-container"><li id="fn4"><p><sup>4</sup>&nbsp;<span class="math inline">\({\bf 1}\)</span> is length <span class="math inline">\(N\)</span> vector with all elements are 1</p></li><div id="ref-segarra2017network" class="csl-entry" role="listitem">
Segarra, Santiago, Antonio G Marques, Gonzalo Mateos, and Alejandro Ribeiro. 2017. <span>“Network Topology Inference from Spectral Templates.”</span> <em>IEEE Transactions on Signal and Information Processing over Networks</em> 3 (3): 467–83.
</div></div><p><strong>Property 12.1</strong> Let <span class="math inline">\({\bf x}\)</span> be stationary in <span class="math inline">\({\bf S}\)</span> with covariance <span class="math inline">\({\bf C}_{\bf x}\)</span> and PSD <span class="math inline">\({\bf p}_x\)</span>. Consider a filter <span class="math inline">\({\bf H}\)</span> with frequency response <span class="math inline">\(\tilde{\bf h}\)</span> and define <span class="math inline">\({\bf y}:={\bf H}{\bf x}\)</span>. Then, the process <span class="math inline">\({\bf y}\)</span>:</p>
<ol type="a">
<li><p>Is stationary in <span class="math inline">\({\bf S}\)</span> with covariance <span class="math inline">\({\bf C}_{\bf y}= {\bf H}{\bf C}_{\bf x}{\bf H}^H\)</span>.</p></li>
<li><p>Has a PSD given by <span class="math inline">\({\bf p}_{\bf y}=|\tilde{\bf h}|^2 \circ {\bf p}_{\bf x}\)</span>, where <span class="math inline">\(|\cdot|^2\)</span> is applied elementwise.</p></li>
</ol>
<blockquote class="blockquote">
<p>Here <span class="math inline">\(\circ\)</span> is elementwise matrix product</p>
</blockquote>
<p><strong>Property 12.2</strong> Given a process <span class="math inline">\({\bf x}\)</span> stationary in <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span> with PSD <span class="math inline">\({\bf p}\)</span>, define the GFT process as <span class="math inline">\(\tilde{\bf x}={\bf V}^H{\bf x}\)</span>. Then, it holds that <span class="math inline">\(\tilde{\bf x}\)</span> is uncorrelated and its covariance matrix is</p>
<p><span class="math display">\[{\bf C}_{\tilde{\bf x}}:= \mathbb{E}\left[\tilde{\bf x}\tilde{\bf x}^H \right]=\mathbb{E}\left[({\bf V}^H{\bf x})({\bf V}^H{\bf x})^H \right]=\text{diag}({\bf p}).\]</span></p>
<p>Property 12.1 is a statement of the spectral convolution theorem for graph signals. Property 12.2 is fundamental to motivate the analysis and modeling of stationary graph processes in the frequency domain, which we undertake in the remainder of this chapter. It also shows that if a process <span class="math inline">\({\bf x}\)</span> is stationary in the shift <span class="math inline">\({\bf S} = {\bf V}{\bf \Lambda}{\bf V}^H\)</span>, then the GFT <span class="math inline">\({\bf V}^H\)</span> provides the Karhunen-Loève expansion of the process.</p>
<p>The concept of stationarity and, consequently, that of PSD can be extended to processes defined jointly in a graph and over time. Before we review this extension in the ensuing section, we discuss requirements on the first moment of stationary graph processes.</p>
<p><strong>The mean of stationary graph processes</strong>. While Definitions 12.1 and 12.2 assume that the random process <span class="math inline">\({\bf x}\)</span> has mean <span class="math inline">\(\tilde{\bf x} := \mathbb{E}[{\bf x}] = {\bf 0}\)</span>, traditional stationary time processes are allowed to have a (nonzero) constant mean <span class="math inline">\(\bar{\bf x} = \alpha{\bf 1}\)</span>, with <span class="math inline">\(\alpha\)</span> being an arbitrary scalar. Stationary graph processes, by contrast, are required to have a first-order moment of the form <span class="math inline">\(\bar{\bf x} = \alpha {\bf v}_k\)</span>, i.e., a scaled version of an eigenvector of <span class="math inline">\({\bf S}\)</span>. This choice: (i) takes into account the structure of the underlying graph; (ii) maintains the validity of Property 12.1; and (iii) encompasses the case <span class="math inline">\({\bf v}_k = {\bf 1}\)</span> when <span class="math inline">\({\bf S}\)</span> is either the adjacency matrix of a directed cycle or the Laplacian of any graph, recovering the classical first-order requirement for weak stationarity.</p>
</section>
<section id="power-spectral-density-estimators" class="level1 page-columns page-full">
<h1>12.3. Power Spectral Density Estimators</h1>
<p>We can exploit the fact that <span class="math inline">\({\bf x}\)</span> is a stationary graph process in <span class="math inline">\({\bf S} = {\bf V}\text{diag}({\bf \Lambda}){\bf V}^H\)</span> to design efficient estimators of the covariance <span class="math inline">\({\bf C}_{\bf x}\)</span>. In particular, instead of estimating <span class="math inline">\({\bf C}_{\bf x}\)</span> directly, which has <span class="math inline">\(N(N + 1)/2\)</span> degrees of freedom, one can estimate <span class="math inline">\({\bf p}\)</span> first, which only has <span class="math inline">\(N\)</span> degrees of freedom, and then leverage that <span class="math inline">\({\bf C}_{\bf x} = {\bf V}\text{diag}({\bf p}){\bf V}^H\)</span>. Motivated by this, the focus of this section is on estimating <span class="math inline">\({\bf p}\)</span>, the PSD of a stationary random graph process <span class="math inline">\({\bf x}\)</span>, using as input either one or a few realizations <span class="math inline">\(\{{\bf x}_r\}_{r=1}^R\)</span> of <span class="math inline">\({\bf x}\)</span>. To illustrate the developments in Sections 12.3 and 12.4, we will use as a running example a random process defined on the well-known Zachary’s Karate club network <span class="citation" data-cites="zachary1977information">Zachary (<a href="#ref-zachary1977information" role="doc-biblioref">1977</a>)</span> (Figs. 12.3 and 12.4). As shown in Fig. 12.4, this graph consists of 34 nodes or members of the club and 78 undirected edges symbolizing friendships among members.</p>
<div class="no-row-height column-margin column-container"><div id="ref-zachary1977information" class="csl-entry" role="listitem">
Zachary, Wayne W. 1977. <span>“An Information Flow Model for Conflict and Fission in Small Groups.”</span> <em>Journal of Anthropological Research</em> 33 (4): 452–73.
</div></div><div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/1f505a23-5b9f-4dbb-a3f8-03c093652bc1-1-27b3f625-0405-4e7f-b677-35aa91a95a68.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">그림12.3(교재에서 긁어온 그림): Power spectral density estimation. All estimators are based on the same random process defined on the Karate club network <span class="citation" data-cites="zachary1977information">(<a href="#ref-zachary1977information" role="doc-biblioref">Zachary 1977</a>)</span>. (A) Periodogram estimation with different numbers of observations. (B) Windowed average periodogram from a single realization and a different number of windows. (C) Windowed average periodogram for four windows and a varying number of realizations. (D) Parametric MA estimation for 1 and 10 realizations.<div id="ref-zachary1977information" class="csl-entry" role="listitem">
Zachary, Wayne W. 1977. <span>“An Information Flow Model for Conflict and Fission in Small Groups.”</span> <em>Journal of Anthropological Research</em> 33 (4): 452–73.
</div></figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/871b9550-848f-4d49-9a99-26a5c2d85595-1-f9528ecc-9143-4e3b-bff7-18e4b23a9651.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">그림12.4(교재에서 긁어온 그림): PSD estimation from a subset of nodes. Estimators are based on a random process defined on the Karate club network <span class="citation" data-cites="zachary1977information">(<a href="#ref-zachary1977information" role="doc-biblioref">Zachary 1977</a>)</span>. (A) Graph sampling for nonparametric PSD estimation. Here, 20 out of 34 nodes are observed. The sampled nodes are highlighted by the circles around the nodes. (B) Nonparametric PSD estimation based on observations from 20 nodes and 100 data snapshots. (C) Graph sampling for parametric MA PSD estimation. Here, 4 out of 34 nodes are observed. (D) Parametric MA PSD estimation based on observations from 4 nodes and 100 data snapshots.<div id="ref-zachary1977information" class="csl-entry" role="listitem">
Zachary, Wayne W. 1977. <span>“An Information Flow Model for Conflict and Fission in Small Groups.”</span> <em>Journal of Anthropological Research</em> 33 (4): 452–73.
</div></figcaption>
</figure>
</div>
</section>
<section id="nonparametric-psd-estimators" class="level1 page-columns page-full">
<h1>12.3.1. Nonparametric PSD estimators</h1>
<p>Nonparametric estimators—as opposed to their parametric counterparts—do not assume any specific generating model on the process <span class="math inline">\({\bf x}\)</span>. This more agnostic view of <span class="math inline">\({\bf x}\)</span> comes with the price of needing, in general, to observe more graph signals to achieve satisfactory performance. In this section, we extend to the graph setting the periodogram, the correlogram, and the least-squares (LS) estimator, which are classical unbiased nonparametric estimators. Moreover, for the special case where the observations are Gaussian, we derive the Cramér-Rao lower bound. We also discuss the windowed average periodogram, which attains a better performance when a few observations are available by introducing bias in a controlled manner while drastically reducing the variance.</p>
<section id="periodogram-correlogram-and-ls-estimator" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="periodogram-correlogram-and-ls-estimator">Periodogram, correlogram, and LS estimator</h2>
<p>From <span class="math inline">\({\bf C}_{\tilde{\bf x}}:= \mathbb{E}\left[\tilde{\bf x}\tilde{\bf x}^H \right]=\mathbb{E}\left[({\bf V}^H{\bf x})({\bf V}^H{\bf x})^H \right]=\text{diag}({\bf p})\)</span> it follows that one may express the PSD as <span class="math inline">\({\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\)</span>. That is, the PSD is given by the expected value of the squared frequency components of the random process. This leads to a natural approach for the estimation of <span class="math inline">\({\bf p}\)</span> from a finite set of <span class="math inline">\(R\)</span> realizations of the process <span class="math inline">\({\bf x}\)</span>. Indeed, we compute the <span class="math inline">\({\bf GFT} \tilde{\bf x}_r = {\bf V}^H{\bf x}_r\)</span> of each observed signal <span class="math inline">\({\bf x}_r\)</span> and estimate <span class="math inline">\({\bf p}\)</span> as</p>
<p><span class="math display">\[
\hat{\bf p}_{pg}:= \frac{1}{R}\sum_{r=1}^R|\tilde{\bf x}_r|^2=\frac{1}{R}\sum_{r=1}^{R}|{\bf V}^H{\bf x}_{r}|^2.
\]</span></p>
<p>The estimator <span class="math inline">\(\hat{\bf p}_{pg}\)</span> is termed periodogram due to its evident similarity with its homonym<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> in classical estimation. It is simple to show that <span class="math inline">\({\bf p}_{pg}\)</span> is an unbiased estimator, that is, <span class="math inline">\(\mathbb{E}[\hat{\bf p}_{pg}]= {\bf p}\)</span>. A more detailed analysis of the performance of <span class="math inline">\(\hat{\bf p}_{pg}\)</span>, for the case where the observations are Gaussian, is given in Proposition 12.1.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div class="no-row-height column-margin column-container"><li id="fn5"><p><sup>5</sup>&nbsp;동음이의어</p></li><li id="fn6"><p><sup>6</sup>&nbsp;Proposition 12.1은 뒤에 다루는데 <span class="math inline">\(\hat{\bf p}_{pg}\)</span>의 분산에 대한 서술이 있음. 분산은 <span class="math inline">\(\mathbb{V}[\hat{\bf p}_{pg}]=\frac{2}{R}\text{diag}^2({\bf p})\)</span>와 같음</p></li></div><p>An alternative nonparametric estimation scheme, denominated correlogram, can be devised by starting from the definition of <span class="math inline">\({\bf p}\)</span> in</p>
<p><span class="math display">\[{\bf p}:=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big).\]</span></p>
<p>Namely, one may substitute <span class="math inline">\({\bf C}_{\bf x}\)</span> in above equation by the sample covariance <span class="math inline">\(\hat{\bf C}_{\bf x} = \frac{1}{R}\sum_{r=1}^R{\bf x}_r{\bf x}_r^H\)</span> computed based on the available observations to obtain</p>
<p><span class="math display">\[\hat{\bf p}_{cg}:= \text{diag}\left({\bf V}^H \hat{\bf C}_{\bf x}{\bf V} \right):=\text{diag}\left[{\bf V}^H\big[ \frac{1}{R}\sum_{r=1}^R{\bf x}_r{\bf x}_r^H\big]{\bf V} \right].\]</span></p>
<p>Notice that the matrix <span class="math inline">\({\bf V}^H\hat{\bf C}_{\bf x}{\bf V}\)</span> is in general, not diagonal because the eigenbasis of <span class="math inline">\(\hat{\bf C}_{\bf x}\)</span> differs from <span class="math inline">\({\bf V}\)</span>, the eigenbasis of <span class="math inline">\({\bf C}_{\bf x}\)</span>. Nonetheless, we keep only the diagonal elements <span class="math inline">\({\bf v}_i^H \hat{\bf C}_{\bf x}{\bf v}_i\)</span> for <span class="math inline">\(i = 1, \dots , N\)</span> as our PSD estimator. It can be shown that the correlogram <span class="math inline">\({\bf p}_{cg}\)</span> and the periodogram <span class="math inline">\({\bf p}_{pg}\)</span> lead to identical estimators, as is the case in classical signal processing.</p>
<p>The correlogram can also be interpreted as an LS estimator. The decomposition in <span class="math inline">\({\bf C}_{\bf x}={\bf V}\text{diag}({\bf p}){\bf V}^H\)</span> allows a linear parameterization of the covariance matrix <span class="math inline">\({\bf C}_{\bf x}\)</span> as</p>
<p><span class="math display">\[
{\bf C}_{\bf x}({\bf p})=\sum_{i=1}^N p_i{\bf v}_i{\bf v}_i^H.
\]</span></p>
<p>This linear parametrization will also be useful for the sampling schemes developed in Section 12.4. Vectorizing <span class="math inline">\({\bf C}_{\bf x}\)</span> in <span class="math inline">\({\bf C}_{\bf x}({\bf p})=\sum_{i=1}^N p_i{\bf v}_i{\bf v}_i^H\)</span> results in a set of <span class="math inline">\(N^2\)</span> equations in <span class="math inline">\({\bf p}\)</span></p>
<p><span class="math display">\[
{\bf c}_{\bf x} = \text{vec}({\bf C}_{\bf x})=\sum_{i=1}^{N}p_i \text{vec}({\bf v}_i{\bf v}_i^H)={\bf G}_{np}{\bf p},
\]</span></p>
<p>where <span class="math inline">\(\text{vec}({\bf v}_i{\bf v}_i^H)={\bf v}_i^\ast \otimes {\bf v}_i\)</span>. Relying on the Khatri-Rao product, we then form the <span class="math inline">\(N^2 \times N\)</span> matrix <span class="math inline">\({\bf G}_{np}\)</span> as</p>
<p><span class="math display">\[
{\bf G}_{np}:= \left[{\bf v}_1^\ast \otimes {\bf v}_1, \dots, {\bf v}_N^\ast \otimes {\bf v}_N \right] = {\bf V}^\ast \odot {\bf V}.
\]</span></p>
<blockquote class="blockquote">
<p>Here <span class="math inline">\(\otimes\)</span> denote the Kronecker matrix product and <span class="math inline">\(\odot\)</span> denote the Khatri-Rao matrix product.</p>
</blockquote>
<p>Using the sample covariance matrix <span class="math inline">\(\hat{\bf C}_{\bf x}\)</span> as an estimate of <span class="math inline">\({\bf C}_{\bf x}\)</span>, we can <em>match</em> the estimated covariance vector <span class="math inline">\(\hat{\bf c}_{\bf x}=\text{vec}(\hat{\bf C}_{\bf x})\)</span> to the true covariance vector <span class="math inline">\({\bf c}_{\bf x}\)</span> in the LS sense as</p>
<p><span class="math display">\[
\hat{\bf p}_{ls} = \underset{\bf p}{\operatorname{argmin}} \|\hat{\bf c}_{\bf x}-{\bf G}_{np}{\bf p}\|_2^2=({\bf G}_{np}^H{\bf G}_{np})^{-1}{\bf G}_{np}^H\hat{\bf c}_{\bf x}.
\]</span></p>
<p>In other words, the LS estimator minimizes the squared error <span class="math inline">\(\text{tr}\left[\big(\hat{\bf C}_{\bf x} − \hat{\bf C}_{\bf x}({\bf p})\big)^T \big(\hat{\bf C}_{\bf x} − \hat{\bf C}_{\bf x}({\bf p})\big)\right]\)</span>. From expression <span class="math inline">\(\hat{\bf p}_{ls} = \underset{\bf p}{\operatorname{argmin}} \|\hat{\bf c}_{\bf x}-{\bf G}_{np}{\bf p}\|_2^2=({\bf G}_{np}^H{\bf G}_{np})^{-1}{\bf G}_{np}^H\hat{\bf c}_{\bf x}\)</span> it can be shown that the <span class="math inline">\(i\)</span>th element of <span class="math inline">\(\hat{\bf p}_{ls}\)</span> is <span class="math inline">\({\bf v}_i^H \hat{\bf C}_{\bf x} {\bf v}_i\)</span>. Combining this with Eq.</p>
<p><span class="math display">\[\hat{\bf p}_{cg}:= \text{diag}\left({\bf V}^H \hat{\bf C}_{\bf x}{\bf V} \right):=\text{diag}\left[{\bf V}^H\big[ \frac{1}{R}\sum_{r=1}^R{\bf x}_r{\bf x}_r^H\big]{\bf V} \right]\]</span></p>
<p>we get that the LS estimator <span class="math inline">\(\hat{\bf p}_{ls}\)</span> and the correlogram <span class="math inline">\(\hat{\bf p}_{cg}\)</span> —and hence the periodogram as well— are all identical estimators. The estimators derived in this subsection do not assume any data distribution and are well suited for cases where the data probability density function is not available. In what follows, we provide performance bounds for these estimators under the condition that the observed signals are Gaussian.</p>
</section>
</section>
<section id="summary" class="level1 page-columns page-full">
<h1>Summary</h1>
<section id="정상시계열을-분석하는-두-가지-흐름-acf와-psd" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="정상시계열을-분석하는-두-가지-흐름-acf와-psd">정상시계열을 분석하는 두 가지 흐름, ACF와 PSD</h2>
<section id="전통적인-분석방법" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="전통적인-분석방법">전통적인 분석방법</h3>
<p>클래식한 정상시계열은 유한차수의 ARMA로 근사할 수 있음이 알려져 있다<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. 유한차수의 ARMA의 계수 <span class="math inline">\(p\)</span>,<span class="math inline">\(q\)</span>를 적절하게 추정하기 위해서는 시계열 <span class="math inline">\({\bf x}\)</span>를 SACF plot 혹은 SPACF plot 을 이용하면 된다. 이때 SACF 혹은 SPACF 의 그림을 살펴보고 적절한 모형을 선택하기 위해서는 유한차수 ARMA의 이론적 ACF의 모양을 알면 되는데,<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> 이를 바꾸어서 말하면 결국 정상시계열 <span class="math inline">\({\bf x}\)</span>의 모든 정보는 ACF에 들어있다는 의미가 된다. 즉 정상시계열은 ACF만 잘 추정하면 모든 것이 해결된다.</p>
<div class="no-row-height column-margin column-container"><li id="fn7"><p><sup>7</sup>&nbsp;Wold’s theorem</p></li><li id="fn8"><p><sup>8</sup>&nbsp;예를들어 “coef가 0.9인 AR(1)의 경우 lag=1 에 대한 이론적 ACF값이 0.9, lag=2에 대한 ACF값이 0.81, … 와 같이 되더라~” 하는식의</p></li></div><p>그런데 ACF의 모든 정보는 다시 아래의 행렬에 들어있다.</p>
<p><span class="math display">\[{\bf C}_{\bf x}=\mathbb{E}[{\bf x}{\bf x}^T]\]</span></p>
<p>여기에서 <span class="math inline">\({\bf x}\)</span>는 realization이 아니라 확률벡터를 의미함을 유의하자.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> 따라서 정상시계열의 경우 <span class="math inline">\({\bf C}_{\bf x}\)</span>를 잘 추정하면 모든것이 해결된다고 생각하면 된다.</p>
<div class="no-row-height column-margin column-container"><li id="fn9"><p><sup>9</sup>&nbsp;보통 수리통계에서는 확률변수를 <span class="math inline">\(X\)</span> realization을 <span class="math inline">\(x\)</span>로 표현하지만 여기에서는 매트릭스를 대문자로 쓰고 있어서 그런식으로 표현하기 어렵다, 그래서 그때 그때 이것이 확률변수인지 realization인지 따져봐야 한다</p></li></div><blockquote class="blockquote">
<p>참고: 정상시계열의 경우 ACF 만 정확하게 알아도 (반대로 PACF만 정확하게 알아도) 이론상 모든 모형을 특정할 수 있다. 즉 정상시계열의 모형을 특정하기 위해서는 ACF plot, PACF plot 하나만 있어도 충분하다. (Wold’s Thm은 떠올리면 모든 정상시계열은 무한MA로 유니크하게 표현할 수 있는데, 이는 PACF plot을 가지고 모든 정상시계열을 유니크하게 특정할 수 있다는 것을 의미한다) 다만 좀 더 모형을 특정하는 과정을 용이하게 하기 위해서 실전에서는 SACF plot 과 SPACF plot 을 함께 보는 것이 유리하다.</p>
</blockquote>
<p><strong>(예제) AR(1) 모형</strong></p>
<p>왜 ACF의 모든정보를 <span class="math inline">\({\bf C}_{\bf x}\)</span>로 부터 알수 있는지 코드를 통하여 실습하여 보자. (바로 이해된다면 사실 이 예제는 스킵해도 무방함) 아래와 같은 모형을 가정하자.</p>
<p><span class="math display">\[x_{t} = 0.5 x_{t-1} +\epsilon_t\]</span></p>
<p>여기에서 <span class="math inline">\(\epsilon_t\)</span>는 서로 독립인 표준정규분포를 따른다. 이 모형에서 길이가 100인 시계열을 임의로 발생시키자.</p>
<div id="0d734652-3cbe-4c96-813d-45974ddc405b" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fu">zeros</span>(<span class="fl">100</span><span class="op">*</span><span class="fl">1000</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>x[<span class="fl">1</span>] <span class="op">=</span> <span class="fu">randn</span>()</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">100</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    x[t] <span class="op">=</span> <span class="fl">0.5</span><span class="op">*</span>x[t<span class="op">-</span><span class="fl">1</span>] <span class="op">+</span> <span class="fu">randn</span>()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
</div>
<p>모형에서 생성된 하나의 시계열을 시각화 하면 아래와 같다.</p>
<div id="8a6bf1d5-789c-4e3b-9d6c-3a003d5b30c0" class="cell" data-execution_count="463">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x) <span class="co"># 그냥 그려본것임. 별 의미는 없음</span></span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="463">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/cell-12-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p><strong>lag=1일 경우 이 시계열의 SACF를 계산하면 아래와 같다.</strong></p>
<div id="29d808ce-eea9-44a4-9738-04b1dd4e15c8" class="cell" data-execution_count="464">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>x[<span class="fl">1</span><span class="op">:</span><span class="fl">99</span>] <span class="op">.*</span> x[<span class="fl">2</span><span class="op">:</span><span class="fl">100</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="464">
<pre><code>99-element Vector{Float64}:
  1.587897526021493
  1.130306190921068
  0.5698214432110668
  0.4648189302568683
  0.3099446153360606
  0.36362604534744775
  0.8191871414624922
 -0.1720390842292145
 -0.06301214708310766
  0.026414715508855904
 -0.007988283356933327
 -0.04178812545299474
  0.22453267567940685
  ⋮
  3.931333581073927
  1.315564948810858
  0.9096080102581454
  0.5410986320348997
  0.29627801400693676
  1.0673283524686212
 -1.0394649044573636
  2.80195248208142
  4.152973765526384
  2.316315764368524
  0.978758337765867
 -0.5840281943972468</code></pre>
</div>
</div>
<ul>
<li>이 계산결과는 각 <span class="math inline">\(t\)</span>에 대하여 <span class="math inline">\(x_{t-1}x_t\)</span> 를 계산한 것과 같다.</li>
</ul>
<p>이 수열들의 평균은 아래와 같다.</p>
<div id="513c8274-59b3-4a42-8ce8-7689b7c9639d" class="cell" data-execution_count="465">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>x[<span class="fl">1</span><span class="op">:</span><span class="fl">99</span>] <span class="op">.*</span> x[<span class="fl">2</span><span class="op">:</span><span class="fl">100</span>] <span class="op">|&gt;</span> mean</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="465">
<pre><code>0.5835563885014224</code></pre>
</div>
</div>
<ul>
<li>이 계산결과는 <span class="math inline">\(\frac{1}{99}\sum_{t=2}^{100} x_{t-1}x_t\)</span>를 계산한 것과 같다.</li>
</ul>
<p>이론적인 값인 0.5 근처의 값이 잘 나옴을 알 수 있다.</p>
<p><strong>lag=2일 경우도 마찬가지로 구할 수 있다.</strong></p>
<div id="6b36fa1c-6ce3-400e-9b1e-213081e15088" class="cell" data-execution_count="466">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>x[<span class="fl">1</span><span class="op">:</span><span class="fl">98</span>] <span class="op">.*</span> x[<span class="fl">3</span><span class="op">:</span><span class="fl">100</span>] <span class="op">|&gt;</span> mean</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="466">
<pre><code>0.38420263596668275</code></pre>
</div>
</div>
<p>이러한 숫자들은 그런데 <span class="math inline">\({\bf x}{\bf x}^T\)</span>를 이용하여서도 구할 수 있다.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<div class="no-row-height column-margin column-container"><li id="fn10"><p><sup>10</sup>&nbsp;참고로 여기에서 <span class="math inline">\({\bf x}\)</span>는 확률벡터가 아니라 realization을 의미함</p></li></div><div id="b50e151f-8286-4d63-83f8-a9f47628c234" class="cell" data-execution_count="467">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>x<span class="op">*</span>x<span class="op">'</span></span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="467">
<pre><code>100×100 Matrix{Float64}:
  0.760108    1.5879      0.541064   …  -1.57394    -0.472676    0.939172
  1.5879      3.31719     1.13031       -3.28802    -0.987441    1.96197
  0.541064    1.13031     0.385143      -1.12037    -0.336463    0.668527
  0.800507    1.67229     0.569821      -1.65759    -0.497799    0.989089
  0.441361    0.922022    0.314172      -0.913915   -0.274462    0.545336
  0.533784    1.1151      0.379961   …  -1.10529    -0.331936    0.659531
  0.517803    1.08171     0.368586      -1.0722     -0.321998    0.639786
  1.20252     2.51212     0.855987      -2.49003    -0.747794    1.48581
 -0.108745   -0.227173   -0.0774074      0.225175    0.0676234  -0.134363
  0.440444    0.920106    0.313519      -0.912016   -0.273892    0.544203
  0.0455859   0.0952309   0.0324492  …  -0.0943935  -0.0283478   0.0563249
 -0.133198   -0.278257   -0.0948139      0.27581     0.0828298  -0.164577
  0.238468    0.498169    0.169748      -0.493789   -0.148292    0.294646
  ⋮                                  ⋱                          
  2.04697     4.2762      1.45708       -4.2386     -1.27291     2.52919
  0.488514    1.02053     0.347736      -1.01155    -0.303784    0.603596
  1.41531     2.95665     1.00746    …  -2.93065    -0.880119    1.74873
  0.290602    0.60708     0.206858      -0.601742   -0.180712    0.359062
  0.774954    1.61891     0.551632      -1.60468    -0.481908    0.957516
  1.04688     2.18698     0.745197      -2.16775    -0.651007    1.2935
 -0.754723   -1.57665    -0.537231       1.56279     0.469328   -0.932519
 -2.82194    -5.89516    -2.00873    …   5.84333     1.75484    -3.48673
 -1.11863    -2.33686    -0.796269       2.31632     0.695624   -1.38215
 -1.57394    -3.28802    -1.12037        3.25911     0.978758   -1.94472
 -0.472676   -0.987441   -0.336463       0.978758    0.293936   -0.584028
  0.939172    1.96197     0.668527      -1.94472    -0.584028    1.16042</code></pre>
</div>
</div>
<p>여기에서 각 원소들이 의미하는 바는 아래와 같다.</p>
<ul>
<li>대각선의 원소: <span class="math inline">\(x_t^2,~ t=1,2,\dots,100\)</span> 을 의미</li>
<li>대각선 한칸 위, 혹은 한칸 아래: <span class="math inline">\(x_{t-1} x_t~ t=2,3,\dots,100\)</span> 을 의미</li>
<li>대각선 두칸 위, 혹은 두칸 아래: <span class="math inline">\(x_{t-2} x_t~ t=3,4,\dots,100\)</span> 을 의미</li>
</ul>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/2a9fe8a0-0ed9-47d8-b170-6791a0a225d0-1-3d82bca8-e1ea-49ce-9829-4aaaca822157.jpeg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption"><code>x*x'</code>의 계산결과를 캡쳐한 그림, 이것은 <span class="math inline">\(\hat{\bf C}_{\bf x}\)</span>를 의미함</figcaption>
</figure>
</div>
<p>확인해보자.</p>
<p><strong>lag=1, 스크린샷의 노란색</strong></p>
<div id="b58c4f34-9ddc-4086-b09d-414f3e10b832" class="cell" data-execution_count="456">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(x[<span class="fl">1</span><span class="op">:</span><span class="fl">99</span>] <span class="op">.*</span> x[<span class="fl">2</span><span class="op">:</span><span class="fl">100</span>])[<span class="fl">1</span><span class="op">:</span><span class="fl">5</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="456">
<pre><code>5-element Vector{Float64}:
 1.587897526021493
 1.130306190921068
 0.5698214432110668
 0.4648189302568683
 0.3099446153360606</code></pre>
</div>
</div>
<ul>
<li>lag1에 해당하는 숫자들임. 이는 스크린샷에서 노란색으로 표현된 1.589, 1.13031, 0.569821 … 등과 일치한다.</li>
</ul>
<p><strong>lag=2, 스크린샷의 빨간색</strong></p>
<div id="92267eec-b98c-448f-a014-0bc9e0387fb5" class="cell" data-execution_count="468">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>(x[<span class="fl">1</span><span class="op">:</span><span class="fl">98</span>] <span class="op">.*</span> x[<span class="fl">3</span><span class="op">:</span><span class="fl">100</span>])[<span class="fl">1</span><span class="op">:</span><span class="fl">5</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="468">
<pre><code>5-element Vector{Float64}:
 0.5410642277088621
 1.6722932576420804
 0.3141719983177106
 0.5621541352252872
 0.30066534927151267</code></pre>
</div>
</div>
<ul>
<li>lag2에 해당하는 숫자들임. 이는 스크린샷에서 빨간색으로 표현된 숫자들인 0.54164, 1.67229, 0.31417 … 등과 일치한다.</li>
</ul>
</section>
<section id="스펙트럼-방법" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="스펙트럼-방법">스펙트럼 방법</h3>
<p>지금까지는 정상시계열일 경우 ACF를 이용한 간단한 분석방법을 다시 복습했다. 그리고 <span class="math inline">\({\bf C}_{\bf x}\)</span>가 ACF를 구함에 필요한 모든정보를 가지고 있음을 이해했다. 한편 <span class="math inline">\({\bf C}_{\bf x}\)</span>은 positive definite matrix 이므로 아래와 같이 분해가능하다.</p>
<p><span class="math display">\[{\bf C}_{\bf x} = {\bf V} \text{diag}({\bf p}) {\bf V}^H\]</span></p>
<p>이 수식표현을 잘 해석하면 <span class="math inline">\({\bf C}_{\bf x}\)</span>의 모든 정보는 <span class="math inline">\({\bf V}\)</span>와 <span class="math inline">\({\bf p}\)</span>에 담겨있다는 사실을 이해할 수 있다. 그런데 정상시계열일 경우 한정하여 <span class="math inline">\({\bf C}_{x}\)</span>의 고유벡터행렬은 <span class="math inline">\({\bf B}\)</span>의 고유벡터행렬과 일치한다는 사실을 알고 있다. 따라서 <span class="math inline">\({\bf V}\)</span>는 <span class="math inline">\({\bf B}\)</span>로 부터 그냥 알 수 있는 정보이다. 따라서 <span class="math inline">\({\bf C}_{\bf x}\)</span>의 모든 정보는 <span class="math inline">\({\bf p}\)</span>에 담겨있다는 사실을 알 수 있다. 이는 적절한 <span class="math inline">\({\bf p}\)</span>를 추정하는 일은 적절한 <span class="math inline">\({\bf C}_{\bf x}\)</span>를 추정하는 것과 같다는 사실을 알려준다.</p>
<p>요약하면 아래와 같다.</p>
<ul>
<li>임의의 정상시계열은 이론적인 ACF (혹은 PACF)를 잘 추정하면 유니크하게 특정할 수 있다. (Wold’s Thm)</li>
<li>ACF를 잘 추정한다는 말은 <span class="math inline">\({\bf C}_{\bf x}\)</span>를 잘 추정한다는 의미이다.</li>
<li>그런데 <span class="math inline">\({\bf p}\)</span>를 잘 추정하면 <span class="math inline">\({\bf C}_{\bf x}\)</span>를 잘 추정하는 일이 된다.</li>
<li>따라서 임의의 정상시계열은 <span class="math inline">\({\bf p}\)</span>를 잘 추정하면 유니크하게 특정할 수 있다는 결론을 얻는다.</li>
</ul>
<p>여기에서 <span class="math inline">\({\bf p}\)</span>를 power spectral density 라고 부른다. 일반적으로 정상시계열을 분석하기 위해서는 <span class="math inline">\({\bf C}_{\bf x}\)</span>를 특정하거나, <span class="math inline">\({\bf p}\)</span>를 특정하면 되는데 여기에서 <span class="math inline">\({\bf p}\)</span>를 특정한뒤 <span class="math inline">\({\bf p}\)</span>로 부터 <span class="math inline">\({\bf C}\)</span>를 역으로 해석하는 방법론을 spectral analysis라고 부른다. 경우에 따라서 <span class="math inline">\({\bf C}_{\bf x}\)</span>를 특정하는 것이 용이할 수도 있지만 <span class="math inline">\({\bf p}\)</span>를 특정하고 해석하는 것이 용이할 때도 있다.</p>
<p>그렇다면 주어진 시계열 <span class="math inline">\({\bf x}\)</span>에 대하여 <span class="math inline">\({\bf p}\)</span>를 어떻게 구할까? 직관적으로 생각하면 단순히 아래의 알고리즘으로 구하면 된다는 것을 알 수 있다.</p>
<ol type="1">
<li><span class="math inline">\({\bf C}_{\bf x}\)</span>를 알아낸다.</li>
<li><span class="math inline">\({\bf C}_{\bf x}\)</span>를 고유분해하여 <span class="math inline">\({\bf p}\)</span>를 구한다.</li>
</ol>
<p>또 다른 방법으로는 교재에 소개된 바 있는 아래의 수식을 이용하는 것이다.<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<div class="no-row-height column-margin column-container"><li id="fn11"><p><sup>11</sup>&nbsp;이 수식이 성립하는 이유는 조금 손으로 써보면 금방 알 수 있음</p></li></div><p><span class="math display">\[{\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\]</span></p>
<p>이것을 이용하면 아래와 같은 알고리즘을 떠올릴 수 있다.</p>
<ol type="1">
<li><span class="math inline">\({\bf B}\)</span>의 고유벡터행렬 <span class="math inline">\({\bf V}\)</span>를 구하고 <span class="math inline">\({\bf V}^H{\bf x}\)</span>를 계산한다.</li>
<li>계산된 결과를 원소별로 제곱하여 <span class="math inline">\({\bf p}\)</span>를 얻는다.</li>
</ol>
<p>그런데 <span class="math inline">\({\bf V}^H{\bf x}= {\bf DFT} \cdot {\bf x}\)</span> 이므로 1의 과정을 아래와 같이 바꾸어 서술할 수 있다.</p>
<ol type="1">
<li><span class="math inline">\({\bf x}\)</span>를 퓨리에변환하여 <span class="math inline">\(\tilde{\bf x} = {\bf DFT} \cdot {\bf x}\)</span> 를 계산한다.</li>
<li><span class="math inline">\(\tilde{\bf x}\)</span>를 원소별로 제곱하여 <span class="math inline">\({\bf p}\)</span>를 얻는다.</li>
</ol>
<p>즉 임의의 시계열을 퓨리에변환한 뒤 제곱하면 <span class="math inline">\({\bf p}\)</span>를 얻을 수 있다.</p>
<p><strong>(예제2) – 하나의 realization에서 <span class="math inline">\(\hat{\bf p}\)</span>를 구해보자.</strong></p>
<p>(예제1에 이어서) 아래의 모형에서 생성된 <span class="math inline">\({\bf x}\)</span>를 다시 고려하자.</p>
<p><span class="math display">\[x_{t} = 0.5 x_{t-1} +\epsilon_t\]</span></p>
<div id="75c8406b-0525-4b73-8eee-2a2ca58d5371" class="cell" data-execution_count="476">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="476">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/cell-19-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>이 자료의 PSD <span class="math inline">\({\bf p}\)</span>는 아래와 같이 구할 수 있다.</p>
<p><strong>단계1</strong>: <span class="math inline">\({\bf x}\)</span>의 DFT를 계산</p>
<div id="7e84e537-fbd2-44b2-9f88-dcac80ecea97" class="cell" data-execution_count="494">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>x̃ <span class="op">=</span> <span class="fu">fft</span>(x) </span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="494">
<pre><code>100-element Vector{ComplexF64}:
  -5.756917285643583 + 0.0im
   -19.0826720904921 - 1.0178306444775302im
  14.230506824768984 - 11.867854578089997im
  3.8980118254428726 + 1.2603018602424614im
 -16.157973053188194 + 27.488246322270918im
   12.32574209329046 - 1.5134316695905219im
    3.95421224972561 + 15.369129638224624im
   9.516938110507798 + 19.371467179753544im
  -19.38292930624831 + 9.49506288623419im
  -7.853934851478428 + 4.134711886071571im
 -14.072349901900408 - 5.945064076174294im
 -14.596266922162355 + 3.447776409279256im
   5.857720447482927 + 5.738895112838594im
                     ⋮
   5.857720447482924 - 5.738895112838594im
 -14.596266922162352 - 3.4477764092792564im
 -14.072349901900408 + 5.945064076174294im
   -7.85393485147843 - 4.134711886071569im
 -19.382929306248315 - 9.49506288623419im
   9.516938110507798 - 19.37146717975354im
  3.9542122497256105 - 15.36912963822462im
  12.325742093290458 + 1.5134316695905206im
 -16.157973053188194 - 27.488246322270925im
  3.8980118254428717 - 1.260301860242461im
  14.230506824768984 + 11.867854578089993im
 -19.082672090492103 + 1.0178306444775296im</code></pre>
</div>
</div>
<ul>
<li><span class="math inline">\({\bf B}\)</span>를 설정하고 고유값분해 하기 귀찮아서 그냥 DFT해주는 패키지 사용함</li>
</ul>
<p><strong>단계2</strong>: <span class="math inline">\(\hat{\bf p}\)</span>를 계산</p>
<div id="59dfb2f8-2fb9-4d4b-bc7f-a01ba904d537" class="cell" data-execution_count="498">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>p̂ <span class="op">=</span> <span class="fu">abs</span>.(x̃)<span class="op">.^</span><span class="fl">2</span></span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="498">
<pre><code>100-element Vector{Float64}:
   33.14209663374188
  365.18435333408365
  343.3532967764883
   16.782856970223087
 1016.6837790613963
  154.21439356883184
  251.84594035243464
  465.8258516955045
  465.85416770456163
   78.78013503208902
  233.37481863133453
  224.93817023139349
   67.24780595702228
    ⋮
   67.24780595702225
  224.93817023139337
  233.37481863133453
   78.78013503208902
  465.8541677045618
  465.8258516955044
  251.84594035243452
  154.2143935688318
 1016.6837790613968
   16.782856970223072
  343.3532967764882
  365.1843533340838</code></pre>
</div>
</div>
<p><strong><em>참고</em></strong></p>
<p><code>fft(x)</code> 대신에 아래의 코드를 이용해도 된다.</p>
<div id="38fcbfa2-36b1-4d90-aa76-5695d1dac958" class="cell" data-execution_count="554">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">100</span> </span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> [i<span class="op">*</span>j for i <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span>(N<span class="op">-</span><span class="fl">1</span>) for j <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span>(N<span class="op">-</span><span class="fl">1</span>)] <span class="op">|&gt;</span> </span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">reshape</span>(x,(N,N)) <span class="op">.|&gt;</span> </span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">exp</span>(<span class="cn">im</span> <span class="op">*</span> (<span class="fl">2</span>π<span class="op">/</span>N) <span class="op">*</span> x)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>V<span class="op">'</span>x</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="554">
<pre><code>100-element Vector{ComplexF64}:
  -5.756917285643587 + 0.0im
 -19.082672090492103 - 1.0178306444775291im
   14.23050682476898 - 11.867854578090007im
  3.8980118254428824 + 1.2603018602424476im
  -16.15797305318818 + 27.48824632227092im
   12.32574209329044 - 1.5134316695905325im
  3.9542122497256385 + 15.369129638224617im
    9.51693811050782 + 19.371467179753516im
  -19.38292930624826 + 9.495062886234233im
 -7.8539348514784155 + 4.134711886071595im
 -14.072349901900417 - 5.945064076174276im
 -14.596266922162371 + 3.447776409279244im
   5.857720447482956 + 5.7388951128385735im
                     ⋮
   5.857720447482839 - 5.738895112838781im
 -14.596266922162307 - 3.4477764092792627im
  -14.07234990190023 + 5.945064076174198im
  -7.853934851478599 - 4.134711886071242im
 -19.382929306248577 - 9.49506288623372im
   9.516938110507212 - 19.371467179753736im
  3.9542122497250025 - 15.369129638224603im
  12.325742093290597 + 1.5134316695903638im
  -16.15797305318867 - 27.488246322270854im
  3.8980118254424903 - 1.2603018602428118im
  14.230506824769146 + 11.867854578089572im
   -19.0826720904922 + 1.0178306444775123im</code></pre>
</div>
</div>
<p>진짜 똑같은지 확인</p>
<div id="b3b7a60b-e8a7-4cbf-a0ee-9aafcd847c6b" class="cell" data-execution_count="555">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fft</span>(x)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="555">
<pre><code>100-element Vector{ComplexF64}:
  -5.756917285643583 + 0.0im
   -19.0826720904921 - 1.0178306444775302im
  14.230506824768984 - 11.867854578089997im
  3.8980118254428726 + 1.2603018602424614im
 -16.157973053188194 + 27.488246322270918im
   12.32574209329046 - 1.5134316695905219im
    3.95421224972561 + 15.369129638224624im
   9.516938110507798 + 19.371467179753544im
  -19.38292930624831 + 9.49506288623419im
  -7.853934851478428 + 4.134711886071571im
 -14.072349901900408 - 5.945064076174294im
 -14.596266922162355 + 3.447776409279256im
   5.857720447482927 + 5.738895112838594im
                     ⋮
   5.857720447482924 - 5.738895112838594im
 -14.596266922162352 - 3.4477764092792564im
 -14.072349901900408 + 5.945064076174294im
   -7.85393485147843 - 4.134711886071569im
 -19.382929306248315 - 9.49506288623419im
   9.516938110507798 - 19.37146717975354im
  3.9542122497256105 - 15.36912963822462im
  12.325742093290458 + 1.5134316695905206im
 -16.157973053188194 - 27.488246322270925im
  3.8980118254428717 - 1.260301860242461im
  14.230506824768984 + 11.867854578089993im
 -19.082672090492103 + 1.0178306444775296im</code></pre>
</div>
</div>
</section>
<section id="전통적인-방법과-스펙트럼-방법의-비교" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="전통적인-방법과-스펙트럼-방법의-비교">전통적인 방법과 스펙트럼 방법의 비교</h3>
<p>시계열자료의 전통적인 분석과 spectral analysis는 대충 아래의 과정으로 비교 설명할 수 있다.</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">단계</th>
<th style="text-align: center;">전통적인 방법</th>
<th style="text-align: center;">스펙트럴 분석</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\({\bf x}\)</span>의 plot을 그려봄</td>
<td style="text-align: center;"><span class="math inline">\({\bf x}\)</span>의 plot을 그려봄</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">SACF plot, SPACF plot 을 그려봄</td>
<td style="text-align: center;">PSD plot을 그려봄</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">ACF를 추정 (=ARMA(<span class="math inline">\(p\)</span>,<span class="math inline">\(q\)</span>)에 대응하는 파라메터를 추정)</td>
<td style="text-align: center;"><span class="math inline">\({\bf p}\)</span>를 추정</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">추정된 파라메터를 바탕으로 여러가지 분석 수행</td>
<td style="text-align: center;">추정된 파라메터를 바탕으로 여러가지 분석 수행</td>
</tr>
</tbody>
</table>
<p>눈여겨 볼 점은 PSD plot의 존재이다. 전통적인 시계열에서 SACF plot 과 비슷하게 스펙트럼 방법에서 시계열을 분석하기 위해 필요한 매우 중요한 시각화 이다. 간단하게 비교를 하면 아래와 같다.</p>
<p><strong>SACF plot</strong></p>
<ul>
<li>x축: lag=0, lag=1, ….</li>
<li>y축: lag에 대응하는 상관계수값</li>
</ul>
<p><strong>PSD plot</strong></p>
<ul>
<li>x축: <span class="math inline">\(\Omega=\big\{\frac{k}{N}:~ \text{for}~ k=0,\dots, N-1\big\}\)</span>, 정규화된 freq를 의미함</li>
<li>y축: 주파수에 대응하는 power값</li>
</ul>
<p>전통적인 방법에 비하여 스펙트럴 분석이 가지는 장점은 위의 표에서 소개한 일반적인 분석루틴이 시계열이 아닌 그래프신호로 쉽게 확장가능 하다는 점이다<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>. 따라서 앞으로는 전통적인 시계열 분석방법 대신 스펙트럴 분석만을 다룰 것이다. 스펙트럴 분석의 핵심적인 부분은 <span class="math inline">\({\bf p}\)</span>를 추정하는 방법과 추정량의 점근적 성질들을 파악하는 것이다. 이 포스트에서는 <span class="math inline">\({\bf p}\)</span>를 추정하는 방법만을 다룬다.</p>
<div class="no-row-height column-margin column-container"><li id="fn12"><p><sup>12</sup>&nbsp;퓨리에 변환대신에 그래프 퓨리에 변환을 이용하기만 하면된다</p></li></div></section>
</section>
<section id="그래프신호에서의-psd의-추정" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="그래프신호에서의-psd의-추정">그래프신호에서의 PSD의 추정</h2>
<p>이제 그래프 신호에서 <span class="math inline">\({\bf p}\)</span>를 추정하는 방법에 대하여 살펴보자. 그래프이동변환 (Graph Shift Operator, GSO)<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span>에 대하여 정상인 시계열 <span class="math inline">\({\bf x}\)</span>를 고려한다. 이 신호의 그래프퓨리에 변환<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>은 아래와 같이 구할 수 있다.</p>
<div class="no-row-height column-margin column-container"><li id="fn13"><p><sup>13</sup>&nbsp;Back shift operator의 일반화 버전</p></li><li id="fn14"><p><sup>14</sup>&nbsp;좀 더 정확하게는 <span class="math inline">\({\bf V}^H\)</span> 에 대한 그래프 변환이라고 한다</p></li></div><p><span class="math display">\[\tilde{\bf x}={\bf GFT} {\bf x} = {\bf V}^H{\bf x}\]</span></p>
<p>여기에서 <span class="math inline">\(\tilde{\bf x}\)</span>를 <span class="math inline">\({\bf x}\)</span>의 주파수응답(frequency representation)이라고 부른다.<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> 우리는 아래의 수식에서 <span class="math inline">\({\bf p}\)</span>의 값에 관심이 있다.</p>
<div class="no-row-height column-margin column-container"><li id="fn15"><p><sup>15</sup>&nbsp;이 <span class="math inline">\(\tilde{\bf x}\)</span>를 그냥 graph Fourier transform이라고 부르는 사람도 많다. 즉 그래프퓨리에변환이 (1) 변환매트릭스 <span class="math inline">\({\bf GFT}\)</span>자체를 지칭할때도 있고 (2) 트랜스폼된 결과 <span class="math inline">\(\tilde{\bf x}\)</span>를 지칭할때도 있음. 교재에서는 변환은 graph Fourier transform, 그리고 변환된 결과는 <span class="math inline">\({\bf x}\)</span>의 주파수응답이라고 한다.</p></li></div><p><span class="math display">\[{\bf C}_{\bf x}={\bf V} \text{diag}({\bf p}){\bf V}^H\]</span></p>
<p>여기에서 <span class="math inline">\({\bf p}\)</span>를 PSD (power spectrum density) 라고 한다. <span class="math inline">\({\bf p}\)</span>가 포함된 표현식은 위의 수식 이외에도 2개가 더 있다. 이를 모두 요약하면 아래와 같다<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<div class="no-row-height column-margin column-container"><li id="fn16"><p><sup>16</sup>&nbsp;약간의 계산을 통하면 1,2,3이 쉽게 같은 수식임을 알 수 있음</p></li></div><ol type="1">
<li><span class="math inline">\({\bf C}_{\bf x}={\bf V} \text{diag}({\bf p}){\bf V}^H\)</span><a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a></li>
<li><span class="math inline">\({\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\)</span></li>
<li><span class="math inline">\({\bf c}_{\bf x} = \sum_{i=1}^{N}p_i \text{vec}({\bf v}_i{\bf v}_i^H) = {\bf G}_{np} {\bf p}\)</span></li>
</ol>
<div class="no-row-height column-margin column-container"><li id="fn17"><p><sup>17</sup>&nbsp;이 수식을 살짝 정리하면 <span class="math inline">\({\bf p}=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big)\)</span> 와 같이 보다 예쁜 수식을 얻을 수 있음</p></li></div><p>위의 표현중 3.에서 <span class="math inline">\({\bf c}_{\bf x}\)</span>은 <span class="math inline">\({\bf C}_x\)</span>를 벡터화한 것이며 <span class="math inline">\({\bf G}_{np}\)</span>는 <span class="math inline">\({\bf V}^\ast\)</span> 와 <span class="math inline">\({\bf V}\)</span>를 열별-크로네커곱 (column-wise Kronecker product) 이다. 이때 <span class="math inline">\({\bf G}_{np}\)</span>의 정의가 조금 생소하니 한번 계산하여 보자.</p>
<p>(예제) 아래와 같은 GSO <span class="math inline">\({\bf B}\)</span>를 고려하자.</p>
<div id="34cdc26a-dc13-448d-800d-f8ef89a5addf" class="cell" data-execution_count="280">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>B<span class="op">=</span> [<span class="fl">0</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> </span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">0</span> </span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> </span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="280">
<pre><code>4×4 Matrix{Int64}:
 0  1  0  0
 0  0  1  0
 0  0  0  1
 1  0  0  0</code></pre>
</div>
</div>
<p>이러한 GSO에 대하여 <span class="math inline">\({\bf G}_{np}\)</span>는 아래와 같이 구할 수 있다.</p>
<p><code>(1)</code> <span class="math inline">\({\bf V}\)</span>를 정의</p>
<div id="b504e458-753e-4202-90d4-315d90bd0280" class="cell" data-execution_count="534">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> [i<span class="op">*</span>j for i <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="fl">3</span> for j <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="fl">3</span>] <span class="op">|&gt;</span> </span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">reshape</span>(x,(<span class="fl">4</span>,<span class="fl">4</span>)) <span class="op">.|&gt;</span> </span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">exp</span>(<span class="cn">im</span> <span class="op">*</span> (<span class="fl">2</span>π<span class="op">/</span><span class="fl">4</span>) <span class="op">*</span> x) </span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="534">
<pre><code>4×4 Matrix{ComplexF64}:
 1.0+0.0im           1.0+0.0im          …           1.0+0.0im
 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im
 1.0+0.0im          -1.0+1.22465e-16im             -1.0+3.67394e-16im
 1.0+0.0im  -1.83697e-16-1.0im              5.51091e-16+1.0im</code></pre>
</div>
</div>
<p><code>(2)</code> <span class="math inline">\({\bf G}_{np}={\bf V}^{\ast} \odot {\bf V}\)</span>, 여기에서 <span class="math inline">\(\odot\)</span>은 열별-크로네커곱을 의미한다.</p>
<div id="3acf11c8-0fcc-4a42-869e-b3c4deac8d21" class="cell" data-execution_count="535">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># columnwise_kron은 위에서 정의한적 있음~</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>Gₙₚ <span class="op">=</span> <span class="fu">columnwise_kron</span>(<span class="fu">conj</span>(V),V)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="535">
<pre><code>16×4 Matrix{ComplexF64}:
 1.0+0.0im           1.0+0.0im          …           1.0+0.0im
 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im
 1.0+0.0im          -1.0+1.22465e-16im             -1.0+3.67394e-16im
 1.0+0.0im  -1.83697e-16-1.0im              5.51091e-16+1.0im
 1.0+0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im
 1.0+0.0im           1.0+0.0im          …           1.0+0.0im
 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im
 1.0+0.0im          -1.0+1.22465e-16im             -1.0+3.67394e-16im
 1.0+0.0im          -1.0-1.22465e-16im             -1.0-3.67394e-16im
 1.0+0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im
 1.0+0.0im           1.0+0.0im          …           1.0+0.0im
 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im
 1.0+0.0im  -1.83697e-16+1.0im              5.51091e-16-1.0im
 1.0+0.0im          -1.0-1.22465e-16im             -1.0-3.67394e-16im
 1.0+0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im
 1.0+0.0im           1.0+0.0im          …           1.0+0.0im</code></pre>
</div>
</div>
<p>위에서 언급한 표현식 1,2,3 을 이용하면 <span class="math inline">\({\bf p}\)</span>를 추정하는 세 가지 방법을 각각 정의할 수 있다. 하나씩 살펴보자.</p>
<section id="bf-c_bf-xbf-v-textdiagbf-pbf-vh" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="bf-c_bf-xbf-v-textdiagbf-pbf-vh">1. <span class="math inline">\({\bf C}_{\bf x}={\bf V} \text{diag}({\bf p}){\bf V}^H\)</span></h3>
<p>확률과정 <span class="math inline">\({\bf x}\)</span>에서 <span class="math inline">\(R\)</span>개의 realization <span class="math inline">\(\{{\bf x}_1 \dots {\bf x}_R\}\)</span> 을 관측하였다고 하자. 수식 <span class="math inline">\({\bf C}_{\bf x}={\bf V} \text{diag}({\bf p}){\bf V}^H\)</span>를 적당히 변형하면 아래를 얻을 수 있다.</p>
<p><span class="math display">\[{\bf p}=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big)\]</span></p>
<p>여기에서</p>
<p><span class="math display">\[{\bf C}_{\bf x}=\mathbb{E}[{\bf x}{\bf x}^H]\approx \frac{1}{R}\sum_{r=1}^R{\bf x}_t{\bf x}_r^H\]</span></p>
<p>이므로 이 수식에 근거하여 <span class="math inline">\({\bf p}\)</span>을 추정한다면 아래와 같이 할 수 있다.</p>
<p><span class="math display">\[\hat{\bf p}_{cg}:= \text{diag}\left({\bf V}^H \hat{\bf C}_{\bf x}{\bf V} \right):=\text{diag}\left[{\bf V}^H\big[ \frac{1}{R}\sum_{r=1}^R{\bf x}_r{\bf x}_r^H\big]{\bf V} \right].\]</span></p>
<p>만약에 확률과정 <span class="math inline">\({\bf x}\)</span>에서 관측한 시계열이 <span class="math inline">\({\bf x}_r\)</span> 하나라면<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>, 즉 <span class="math inline">\(R=1\)</span> 이라면 단순히 아래와 같이 쓸 수 있다.</p>
<div class="no-row-height column-margin column-container"><li id="fn18"><p><sup>18</sup>&nbsp;대부분은 관측한 시계열이 하나겠지..</p></li></div><p><span class="math display">\[\hat{\bf p}_{cg}:= \text{diag}\left({\bf V}^H \hat{\bf C}_{\bf x}{\bf V} \right):=\text{diag}\left[{\bf V}^H{\bf x}_r{\bf x}_r^H{\bf V} \right].\]</span></p>
<blockquote class="blockquote">
<p>주의: 여기에서 <span class="math inline">\({\bf V}^H {\bf C}_{\bf x}{\bf V}\)</span> 는 항상 대각행렬이지만 <span class="math inline">\({\bf V}^H \hat{\bf C}_{\bf x}{\bf V}\)</span> 은 대각행렬이 아닐수도 있음을 유의하자. 즉 이론적인 모수는 대각행렬이지만 sample version은 대각행렬이 아닐 수 있다. 대각선이 아닌 원소는 버리면 된다.)</p>
</blockquote>
<blockquote class="blockquote">
<p>아이디어: 혹시 대각선이 아닌 원소들을 이용하여 오차항 <span class="math inline">\(\epsilon_t\)</span>의 분산을 추정할 수도 있지 않을까? 이미 연구가 있겠지?</p>
</blockquote>
<p>(예제)</p>
<div id="cc5fdabd-ffbc-4435-aaba-7c700408766a" class="cell" data-execution_count="549">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">100</span> </span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> [i<span class="op">*</span>j for i <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span>(N<span class="op">-</span><span class="fl">1</span>) for j <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span>(N<span class="op">-</span><span class="fl">1</span>)] <span class="op">|&gt;</span> </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">reshape</span>(x,(N,N)) <span class="op">.|&gt;</span> </span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">exp</span>(<span class="cn">im</span> <span class="op">*</span> (<span class="fl">2</span>π<span class="op">/</span>N) <span class="op">*</span> x)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="549">
<pre><code>100×100 Matrix{ComplexF64}:
 1.0+0.0im       1.0+0.0im        …       1.0+0.0im
 1.0+0.0im  0.998027+0.0627905im     0.998027-0.0627905im
 1.0+0.0im  0.992115+0.125333im      0.992115-0.125333im
 1.0+0.0im  0.982287+0.187381im      0.982287-0.187381im
 1.0+0.0im  0.968583+0.24869im       0.968583-0.24869im
 1.0+0.0im  0.951057+0.309017im   …  0.951057-0.309017im
 1.0+0.0im  0.929776+0.368125im      0.929776-0.368125im
 1.0+0.0im  0.904827+0.425779im      0.904827-0.425779im
 1.0+0.0im  0.876307+0.481754im      0.876307-0.481754im
 1.0+0.0im  0.844328+0.535827im      0.844328-0.535827im
 1.0+0.0im  0.809017+0.587785im   …  0.809017-0.587785im
 1.0+0.0im  0.770513+0.637424im      0.770513-0.637424im
 1.0+0.0im  0.728969+0.684547im      0.728969-0.684547im
    ⋮                             ⋱  
 1.0+0.0im  0.728969-0.684547im      0.728969+0.684547im
 1.0+0.0im  0.770513-0.637424im      0.770513+0.637424im
 1.0+0.0im  0.809017-0.587785im   …  0.809017+0.587785im
 1.0+0.0im  0.844328-0.535827im      0.844328+0.535827im
 1.0+0.0im  0.876307-0.481754im      0.876307+0.481754im
 1.0+0.0im  0.904827-0.425779im      0.904827+0.425779im
 1.0+0.0im  0.929776-0.368125im      0.929776+0.368125im
 1.0+0.0im  0.951057-0.309017im   …  0.951057+0.309017im
 1.0+0.0im  0.968583-0.24869im       0.968583+0.24869im
 1.0+0.0im  0.982287-0.187381im      0.982287+0.187381im
 1.0+0.0im  0.992115-0.125333im      0.992115+0.125333im
 1.0+0.0im  0.998027-0.0627905im     0.998027+0.0627905im</code></pre>
</div>
</div>
<div id="21c6836c-1eef-4fa7-8641-af5fdda5eaae" class="cell" data-execution_count="556">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>p̂ <span class="op">=</span> <span class="fu">diag</span>(V<span class="op">'</span> <span class="op">*</span> (x<span class="op">*</span>x<span class="op">'</span>) <span class="op">*</span> V)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="556">
<pre><code>100-element Vector{ComplexF64}:
 33.142096633741986 + 0.0im
 365.18435333408354 + 1.5376069362644531e-13im
  343.3532967764883 + 6.904176529646917e-14im
 16.782856970223083 - 3.5538396658301444e-14im
 1016.6837790613963 + 5.475049904926759e-15im
 154.21439356883144 + 6.4512443306088e-14im
  251.8459403524346 + 2.1316282072803006e-14im
 465.82585169550384 + 1.816929057526117e-13im
 465.85416770456044 + 4.1584439183295984e-14im
    78.780135032089 + 1.3472456770553478e-14im
 233.37481863133462 + 6.315728724701355e-14im
 224.93817023139385 - 3.472109560086835e-14im
  67.24780595702241 + 7.105427357601002e-14im
                    ⋮
   67.2478059570233 + 6.384723798533952e-14im
 224.93817023139195 + 1.9727655769954595e-14im
 233.37481863132837 - 2.1872689567834747e-14im
    78.780135032089 + 1.917599080404094e-14im
 465.85416770456294 + 4.808950231511622e-14im
 465.82585169550094 - 4.890486289860305e-14im
  251.8459403524291 + 2.0146681724568905e-14im
  154.2143935688347 - 1.0948596967617507e-13im
 1016.6837790614081 + 1.2114814701286432e-13im
  16.78285697022108 + 2.376159104534641e-14im
 343.35329677648286 + 1.1310381241837407e-14im
 365.18435333408746 + 4.574214786667376e-14im</code></pre>
</div>
</div>
</section>
<section id="bf-pmathbbeleftbf-vhbf-x2right" class="level3">
<h3 class="anchored" data-anchor-id="bf-pmathbbeleftbf-vhbf-x2right">2. <span class="math inline">\({\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\)</span></h3>
<p>확률과정 <span class="math inline">\({\bf x}\)</span>에서 <span class="math inline">\(R\)</span>개의 realization <span class="math inline">\(\{{\bf x}_1 \dots {\bf x}_R\}\)</span> 을 관측하였다고 하자. 아래의 수식을 관찰하자.</p>
<p><span class="math display">\[{\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\approx \frac{1}{R}\sum_{r=1}^{R} |{\bf V}^H {\bf x}_r|^2 \]</span></p>
<p>따라서 <span class="math inline">\(\frac{1}{R}\sum_{r=1}^{R} |{\bf V}^H {\bf x}_r|^2\)</span> 를 PSD <span class="math inline">\({\bf p}\)</span>에 대한 추정량이라고 생각할 수 있다. 이러한 추정량을 기호로 <span class="math inline">\(\hat{\bf p}_{pg}\)</span>라고 정의하고 periodogram이라고 부른다. 즉</p>
<p><span class="math display">\[\hat{\bf p}_{pg}=\frac{1}{R}\sum_{r=1}^{R} |{\bf V}^H {\bf x}_r|^2 \]</span></p>
<p>만약에 확률과정 <span class="math inline">\({\bf x}\)</span>에서 관측한 시계열이 <span class="math inline">\({\bf x}_r\)</span> 하나라면, 즉 <span class="math inline">\(R=1\)</span> 이라면 단순히 아래와 같이 쓸 수 있다.</p>
<p><span class="math display">\[\hat{\bf p}_{pg}=|{\bf V}^H {\bf x}_r|^2 \]</span></p>
<p>즉 이 경우 <span class="math inline">\(\hat{\bf p}_{pg}\)</span>는 단순히 관측시계열 <span class="math inline">\({\bf x}_r\)</span>의 그래프 퓨리에 변환 <span class="math inline">\(\tilde{\bf x}={\bf V}^H{\bf x}_r\)</span> 결과에 절대값을 취하고 제곱한 것과 같다.</p>
<p>(예제)</p>
<p>스펙트럼방법챕터 예제2에서 이미 보여준 적 있다. 주어진 시계열 <span class="math inline">\({\bf x}\)</span>에 대하여 <span class="math inline">\(\hat{\bf p}_{pg}\)</span>를 구하는 방법을 요약하면 아래와 같다.</p>
<div id="8f01086a-1d7f-42a0-8f3f-890e6c980abd" class="cell" data-execution_count="504">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>x̃ <span class="op">=</span> <span class="fu">fft</span>(x) <span class="co"># 단계1: GFT, 이 신호는 시계열이라서 GFT대신에 DFT를 써도 된다.</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>p̂ <span class="op">=</span> <span class="fu">abs</span>.(x̃)<span class="op">.^</span><span class="fl">2</span> <span class="co"># 단계2: hat p</span></span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="504">
<pre><code>100-element Vector{Float64}:
   33.14209663374188
  365.18435333408365
  343.3532967764883
   16.782856970223087
 1016.6837790613963
  154.21439356883184
  251.84594035243464
  465.8258516955045
  465.85416770456163
   78.78013503208902
  233.37481863133453
  224.93817023139349
   67.24780595702228
    ⋮
   67.24780595702225
  224.93817023139337
  233.37481863133453
   78.78013503208902
  465.8541677045618
  465.8258516955044
  251.84594035243452
  154.2143935688318
 1016.6837790613968
   16.782856970223072
  343.3532967764882
  365.1843533340838</code></pre>
</div>
</div>
</section>
<section id="bf-c_bf-x-bf-g_np-bf-p" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="bf-c_bf-x-bf-g_np-bf-p">3. <span class="math inline">\({\bf c}_{\bf x} = {\bf G}_{np} {\bf p}\)</span></h3>
<p>확률과정 <span class="math inline">\({\bf x}\)</span>에서 <span class="math inline">\(R\)</span>개의 realization <span class="math inline">\(\{{\bf x}_1 \dots {\bf x}_R\}\)</span> 을 관측하였다고 하자. 아래의 수식을 관찰하자.</p>
<p><span class="math display">\[{\bf C}_{\bf x} = {\bf V} \text{diag}({\bf p}) {\bf V}^H\]</span></p>
<p>이 수식으로부터 아래를 얻을 수 있다.</p>
<p><span class="math display">\[{\bf c}_{\bf x} = \sum_{i=1}^{N}p_i \text{vec}({\bf v}_i{\bf v}_i^H) = {\bf G}_{np} {\bf p}\]</span></p>
<p>여기에서 <span class="math inline">\({\bf c}_{\bf x}\)</span> 대신에 <span class="math inline">\(\hat{\bf c}_{\bf x}\)</span> 를 대입하면 아래와 같이 생각할 수 있다.</p>
<p><span class="math display">\[\hat{\bf c}_{\bf x} \approx  {\bf G}_{np} {\bf p}\]</span></p>
<p>이 문제는 아래와 같은 회귀모형으로 생각할 수 있다.</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">회귀모형</th>
<th style="text-align: center;">우리의 문제</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">모형</td>
<td style="text-align: center;"><span class="math inline">\({\bf y} \approx {\bf X}{\boldsymbol \beta}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\hat{\bf c}_{\bf x} \approx {\bf G}_{np}{\bf p}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">설명변수</td>
<td style="text-align: center;"><span class="math inline">\({\bf X}\)</span><a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a></td>
<td style="text-align: center;"><span class="math inline">\({\bf G}_{np}\)</span><a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a></td>
</tr>
<tr class="odd">
<td style="text-align: center;">반응변수</td>
<td style="text-align: center;"><span class="math inline">\({\bf y}\)</span><a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a></td>
<td style="text-align: center;"><span class="math inline">\(\hat{\bf c}_{\bf x}\)</span><a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a></td>
</tr>
<tr class="even">
<td style="text-align: center;">추정하고 싶은 파라메터</td>
<td style="text-align: center;"><span class="math inline">\({\boldsymbol \beta}\)</span><a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a></td>
<td style="text-align: center;"><span class="math inline">\(\hat{\bf p}\)</span><a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a></td>
</tr>
<tr class="odd">
<td style="text-align: center;">오차항</td>
<td style="text-align: center;">대부분 정규분포를 가정</td>
<td style="text-align: center;">??? 모르겠는데??</td>
</tr>
</tbody>
</table>
<div class="no-row-height column-margin column-container"><li id="fn19"><p><sup>19</sup>&nbsp;(n,p) matrix</p></li><li id="fn20"><p><sup>20</sup>&nbsp;(N²,N) matrix</p></li><li id="fn21"><p><sup>21</sup>&nbsp;(n,1) col-vector</p></li><li id="fn22"><p><sup>22</sup>&nbsp;(N²,1) col-vector</p></li><li id="fn23"><p><sup>23</sup>&nbsp;(p,1) col-vector</p></li><li id="fn24"><p><sup>24</sup>&nbsp;(N,1) col-vector</p></li></div><p>회귀분석에서 아래의 수식이 익숙하다면</p>
<p><span class="math display">\[
\hat{\boldsymbol \beta}_{ls} = \underset{\boldsymbol \beta}{\operatorname{argmin}} \|{\bf y}-{\bf X}{\boldsymbol \beta}\|_2^2=({\bf X}^T{\bf X})^{-1}{\bf X}^T{\bf y}.
\]</span></p>
<p><span class="math inline">\({\bf p}\)</span>를 추정하기 위한 아래의 수식도 쉽게 이해할 수 있다. (의문: 그런데 왜 MSE를 손실함수로 쓰고 있는 거야? 오차항이 설마 정규분포?)</p>
<p><span class="math display">\[
\hat{\bf p}_{ls} = \underset{\bf p}{\operatorname{argmin}} \|\hat{\bf c}_{\bf x}-{\bf G}_{np}{\bf p}\|_2^2=({\bf G}_{np}^H{\bf G}_{np})^{-1}{\bf G}_{np}^H\hat{\bf c}_{\bf x}.
\]</span></p>
<p><strong>(예제)</strong></p>
<p><code>(1)</code> <span class="math inline">\({\bf V}\)</span>를 정의</p>
<div id="5479b21f-3610-4099-aa64-8eae1394eb1e" class="cell" data-execution_count="566">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">100</span> </span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> [i<span class="op">*</span>j for i <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span>(N<span class="op">-</span><span class="fl">1</span>) for j <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span>(N<span class="op">-</span><span class="fl">1</span>)] <span class="op">|&gt;</span> </span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">reshape</span>(x,(N,N)) <span class="op">.|&gt;</span> </span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">-&gt;</span> <span class="fu">exp</span>(<span class="cn">im</span> <span class="op">*</span> (<span class="fl">2</span>π<span class="op">/</span>N) <span class="op">*</span> x)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="566">
<pre><code>100×100 Matrix{ComplexF64}:
 1.0+0.0im       1.0+0.0im        …       1.0+0.0im
 1.0+0.0im  0.998027+0.0627905im     0.998027-0.0627905im
 1.0+0.0im  0.992115+0.125333im      0.992115-0.125333im
 1.0+0.0im  0.982287+0.187381im      0.982287-0.187381im
 1.0+0.0im  0.968583+0.24869im       0.968583-0.24869im
 1.0+0.0im  0.951057+0.309017im   …  0.951057-0.309017im
 1.0+0.0im  0.929776+0.368125im      0.929776-0.368125im
 1.0+0.0im  0.904827+0.425779im      0.904827-0.425779im
 1.0+0.0im  0.876307+0.481754im      0.876307-0.481754im
 1.0+0.0im  0.844328+0.535827im      0.844328-0.535827im
 1.0+0.0im  0.809017+0.587785im   …  0.809017-0.587785im
 1.0+0.0im  0.770513+0.637424im      0.770513-0.637424im
 1.0+0.0im  0.728969+0.684547im      0.728969-0.684547im
    ⋮                             ⋱  
 1.0+0.0im  0.728969-0.684547im      0.728969+0.684547im
 1.0+0.0im  0.770513-0.637424im      0.770513+0.637424im
 1.0+0.0im  0.809017-0.587785im   …  0.809017+0.587785im
 1.0+0.0im  0.844328-0.535827im      0.844328+0.535827im
 1.0+0.0im  0.876307-0.481754im      0.876307+0.481754im
 1.0+0.0im  0.904827-0.425779im      0.904827+0.425779im
 1.0+0.0im  0.929776-0.368125im      0.929776+0.368125im
 1.0+0.0im  0.951057-0.309017im   …  0.951057+0.309017im
 1.0+0.0im  0.968583-0.24869im       0.968583+0.24869im
 1.0+0.0im  0.982287-0.187381im      0.982287+0.187381im
 1.0+0.0im  0.992115-0.125333im      0.992115+0.125333im
 1.0+0.0im  0.998027-0.0627905im     0.998027+0.0627905im</code></pre>
</div>
</div>
<p><code>(2)</code> <span class="math inline">\({\bf G}_{np}={\bf V}^{\ast} \odot {\bf V}\)</span>, 여기에서 <span class="math inline">\(\odot\)</span>은 열별-크로네커곱을 의미한다.</p>
<div id="bdb6e959-c6ad-46d6-a6ab-be9e310851bf" class="cell" data-execution_count="567">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># columnwise_kron은 위에서 정의한적 있음~</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>Gₙₚ <span class="op">=</span> <span class="fu">columnwise_kron</span>(<span class="fu">conj</span>(V),V)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="567">
<pre><code>10000×100 Matrix{ComplexF64}:
 1.0+0.0im       1.0+0.0im        …       1.0+0.0im
 1.0+0.0im  0.998027+0.0627905im     0.998027-0.0627905im
 1.0+0.0im  0.992115+0.125333im      0.992115-0.125333im
 1.0+0.0im  0.982287+0.187381im      0.982287-0.187381im
 1.0+0.0im  0.968583+0.24869im       0.968583-0.24869im
 1.0+0.0im  0.951057+0.309017im   …  0.951057-0.309017im
 1.0+0.0im  0.929776+0.368125im      0.929776-0.368125im
 1.0+0.0im  0.904827+0.425779im      0.904827-0.425779im
 1.0+0.0im  0.876307+0.481754im      0.876307-0.481754im
 1.0+0.0im  0.844328+0.535827im      0.844328-0.535827im
 1.0+0.0im  0.809017+0.587785im   …  0.809017-0.587785im
 1.0+0.0im  0.770513+0.637424im      0.770513-0.637424im
 1.0+0.0im  0.728969+0.684547im      0.728969-0.684547im
    ⋮                             ⋱  
 1.0+0.0im  0.770513-0.637424im      0.770513+0.637424im
 1.0+0.0im  0.809017-0.587785im      0.809017+0.587785im
 1.0+0.0im  0.844328-0.535827im   …  0.844328+0.535827im
 1.0+0.0im  0.876307-0.481754im      0.876307+0.481754im
 1.0+0.0im  0.904827-0.425779im      0.904827+0.425779im
 1.0+0.0im  0.929776-0.368125im      0.929776+0.368125im
 1.0+0.0im  0.951057-0.309017im      0.951057+0.309017im
 1.0+0.0im  0.968583-0.24869im    …  0.968583+0.24869im
 1.0+0.0im  0.982287-0.187381im      0.982287+0.187381im
 1.0+0.0im  0.992115-0.125333im      0.992115+0.125333im
 1.0+0.0im  0.998027-0.0627905im     0.998027+0.0627905im
 1.0+0.0im       1.0+0.0im                1.0+0.0im</code></pre>
</div>
</div>
<p><code>(3)</code> <span class="math inline">\(\hat{\bf p}_{ls}=({\bf G}_{np}^H{\bf G}_{np})^{-1}{\bf G}_{np}^H\hat{\bf c}_{\bf x}\)</span></p>
<div id="8db61662-db29-40db-8a78-e7fa4ec470d0" class="cell" data-execution_count="572">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>ĉₓ <span class="op">=</span> <span class="fu">vec</span>(x<span class="op">*</span>x<span class="op">'</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>p̂ <span class="op">=</span> <span class="fu">inv</span>(Gₙₚ<span class="op">'</span> <span class="op">*</span> Gₙₚ) <span class="op">*</span> Gₙₚ<span class="op">'</span> <span class="op">*</span> ĉₓ </span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="572">
<pre><code>100-element Vector{ComplexF64}:
  0.003314209663374193 - 2.7356277964988863e-19im
   0.03651843533340838 - 4.01518191768058e-18im
   0.03433532967764885 + 2.515448157755484e-17im
 0.0016782856970223292 - 1.0070028487673847e-17im
   0.10166837790613971 + 3.1129277935880596e-18im
  0.015421439356883134 + 9.403422807142065e-18im
  0.025184594035243472 - 3.993782799800785e-18im
   0.04658258516955039 - 1.850761436988587e-18im
   0.04658541677045607 + 1.1559103895961936e-17im
  0.007878013503208905 + 3.559698092088507e-18im
  0.023337481863133468 + 2.6204945155857973e-18im
   0.02249381702313939 + 5.304406111488559e-18im
  0.006724780595702225 - 1.655564138463681e-17im
                       ⋮
  0.006724780595702329 + 1.8121162053534517e-18im
  0.022493817023139205 - 1.0461976779111972e-17im
   0.02333748186313285 - 6.792203007975684e-18im
  0.007878013503208907 - 2.3575339315335667e-18im
  0.046585416770456294 + 1.5392042695643853e-17im
  0.046582585169550106 - 1.123245521985718e-17im
  0.025184594035242928 + 1.1628578774983873e-18im
  0.015421439356883466 + 5.864828990948797e-18im
   0.10166837790614085 + 2.2712943512935246e-17im
 0.0016782856970221013 + 4.829637376114682e-18im
   0.03433532967764831 + 3.3208196889839756e-19im
  0.036518435333408754 + 1.3795822112205515e-17im</code></pre>
</div>
</div>
<ul>
<li>?? 뭔가 스케일이 안맞음</li>
</ul>
<div id="0e2e88f6-3e43-4ac3-a9b5-75c1385305ff" class="cell" data-execution_count="574">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>N<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> p̂</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="574">
<pre><code>100-element Vector{ComplexF64}:
  33.14209663374193 - 2.7356277964988864e-15im
 365.18435333408377 - 4.0151819176805797e-14im
  343.3532967764885 + 2.515448157755484e-13im
 16.782856970223293 - 1.0070028487673847e-13im
 1016.6837790613971 + 3.1129277935880596e-14im
 154.21439356883135 + 9.403422807142065e-14im
 251.84594035243472 - 3.9937827998007846e-14im
  465.8258516955039 - 1.850761436988587e-14im
  465.8541677045607 + 1.1559103895961937e-13im
  78.78013503208905 + 3.559698092088507e-14im
 233.37481863133468 + 2.6204945155857973e-14im
 224.93817023139388 + 5.304406111488559e-14im
  67.24780595702225 - 1.655564138463681e-13im
                    ⋮
  67.24780595702329 + 1.8121162053534517e-14im
 224.93817023139206 - 1.0461976779111972e-13im
  233.3748186313285 - 6.792203007975684e-14im
  78.78013503208906 - 2.3575339315335666e-14im
 465.85416770456294 + 1.5392042695643854e-13im
 465.82585169550106 - 1.123245521985718e-13im
 251.84594035242927 + 1.1628578774983874e-14im
 154.21439356883465 + 5.864828990948797e-14im
 1016.6837790614085 + 2.2712943512935246e-13im
  16.78285697022101 + 4.8296373761146824e-14im
  343.3532967764831 + 3.3208196889839758e-15im
  365.1843533340875 + 1.3795822112205514e-13im</code></pre>
</div>
</div>
<ul>
<li><span class="math inline">\(N^2\)</span>를 곱해주니까 아까부터 구하던 값이 그대로 잘 나옴. (<span class="math inline">\({\bf DFT}\)</span> 혹은 <span class="math inline">\({\bf GFT}\)</span>를 정의할때 <span class="math inline">\(\frac{1}{\sqrt N}\)</span>으로 스케일링 하느냐 마느냐 차이때문에 생기는 현상임)</li>
</ul>
</section>
</section>
<section id="의문점" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="의문점">의문점</h2>
<p>아래의 그림을 살펴보자.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/a4e861e2-fbdf-47cf-a305-77316af0e5a6-1-27b3f625-0405-4e7f-b677-35aa91a95a68.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">그림12.3(교재에서 긁어온 그림): Power spectral density estimation. All estimators are based on the same random process defined on the Karate club network <span class="citation" data-cites="zachary1977information">(<a href="#ref-zachary1977information" role="doc-biblioref">Zachary 1977</a>)</span>. (A) Periodogram estimation with different numbers of observations. (B) Windowed average periodogram from a single realization and a different number of windows. (C) Windowed average periodogram for four windows and a varying number of realizations. (D) Parametric MA estimation for 1 and 10 realizations.<div id="ref-zachary1977information" class="csl-entry" role="listitem">
Zachary, Wayne W. 1977. <span>“An Information Flow Model for Conflict and Fission in Small Groups.”</span> <em>Journal of Anthropological Research</em> 33 (4): 452–73.
</div></figcaption>
</figure>
</div>
<p>이 그림은 다양한 방법으로 true PSD <span class="math inline">\({\bf p}\)</span>를 추정한 결과를 나타내는 PSD plot 이다<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>. 우리가 적용한 방법은 (A)에서 <span class="math inline">\(R=1\)</span>일 경우이다. 보는것 처럼 true PSD 를 놀라울 정도로 제대로 추정하지 못한다<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>. 만약에 우리가 모형에서 하나의 시계열이 아니라 1000개의 정도의 시계열을 관측하였다면 좀 더 합리적으로 추정할 수 있다. 그런데 사실 하나의 모형에서 1000개씩이나 되는 시계열을 관측하는 일은 현실적으로 불가능하다<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> 따라서 우리는 비교적 적은 <span class="math inline">\(R\)</span>에서 합리적인 PSD의 추정치를 이끌어내야 한다. 그림 (B),(C)는 상대적으로 적은 <span class="math inline">\(R\)</span>에 대해 <span class="math inline">\({\bf p}\)</span>를 추정하는 windowed periodogram 을 이용하여 PSD를 추정한 결과이다. (C)를 살펴보면 <span class="math inline">\(R=1\)</span> 일경우 <span class="math inline">\({\bf p}\)</span>를 추정한 값들이 나와있는데 (A)와 비교하면 꽤 합리적으로 보인다.</p>
<div class="no-row-height column-margin column-container"><li id="fn25"><p><sup>25</sup>&nbsp;x축이 freq, y축이 PSD</p></li><li id="fn26"><p><sup>26</sup>&nbsp;맞추는게 없는 것 같은데?</p></li><li id="fn27"><p><sup>27</sup>&nbsp;그리고 대부분 <span class="math inline">\(R=1\)</span>이지..</p></li><li id="fn28"><p><sup>28</sup>&nbsp;약간 바이어스가 있어보이긴 하는데, 우연히 생긴건지 이론적으로 항상 생기는 건지는 잘 모르겠네?</p></li><li id="fn29"><p><sup>29</sup>&nbsp;이런걸 세미파라메트릭 모형이라고 해요</p></li><li id="fn30"><p><sup>30</sup>&nbsp;그래서 플랏을 보면서 적당한 ARMA를 찾을 필요도 없고, AIC 니 BIC 를 따져가면서 모형선택을 할 필요도 없고</p></li><li id="fn31"><p><sup>31</sup>&nbsp;적합이후에 잔차분석 같은거 안해도 된다는 의미</p></li></div><p>문제는 (A)-(C)에서 제안된 방법 모두가 (D)에 제시된 전통적인 방법에 비하여 퍼포먼스가 떨어진다는 것이다. (D)는 parametric 모형을 사용한 결과이다. 파라메트릭 방법이므로 특정 모델을 한정하고 거기에 대응하는 한두개의 모수만 추정하면 되므로 추정이 잘 된다.<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a> 반면 (A)-(C)의 경우 한 두개의 파라메터가 아니라 <span class="math inline">\({\bf p}\)</span>의 모든 원소를 추정해야하므로 추정할 파라메터가 데이터의 수 <span class="math inline">\(N\)</span>과 같다<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>. 따라서 추정치의 분산이 크다. 사실 이것은 파라메트릭 방법과 세미파라메트릭 방법이라는 구조적인 차이때문에 어쩔 수 없는 것 같다. 그래도 세미파라메트릭 방법은 머리아프게 모델링을 할 필요가 없고<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> 내가 적합한 모델이 맞는지 확인할 필요도 없다<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a>는 장점이 있다.</p>
<p>아래는 나름 PSD를 추정하는 신기술인 것 같다.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="2022-12-27-Chap-12.2.1~12.3.1_files/figure-html/da2b1b30-ea09-4d72-afa3-ed2f27566c6b-1-f9528ecc-9143-4e3b-bff7-18e4b23a9651.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption margin-caption">그림12.4(교재에서 긁어온 그림): PSD estimation from a subset of nodes. Estimators are based on a random process defined on the Karate club network <span class="citation" data-cites="zachary1977information">(<a href="#ref-zachary1977information" role="doc-biblioref">Zachary 1977</a>)</span>. (A) Graph sampling for nonparametric PSD estimation. Here, 20 out of 34 nodes are observed. The sampled nodes are highlighted by the circles around the nodes. (B) Nonparametric PSD estimation based on observations from 20 nodes and 100 data snapshots. (C) Graph sampling for parametric MA PSD estimation. Here, 4 out of 34 nodes are observed. (D) Parametric MA PSD estimation based on observations from 4 nodes and 100 data snapshots.<div id="ref-zachary1977information" class="csl-entry" role="listitem">
Zachary, Wayne W. 1977. <span>“An Information Flow Model for Conflict and Fission in Small Groups.”</span> <em>Journal of Anthropological Research</em> 33 (4): 452–73.
</div></figcaption>
</figure>
</div>
<p>그래프신호의 sub-sampling을 이용하는 것 같은데 교재의 뒤쪽에 서술되어있다. <span class="math inline">\(R=100\)</span>임을 고려하여도 퍼포먼스가 좋은 편인듯 하다<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>.</p>


<div class="no-row-height column-margin column-container"><li id="fn32"><p><sup>32</sup>&nbsp;내 생각엔 이게 핵심 기술인 것 같음</p></li></div>
</section>
</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        return container.innerHTML
      } else {
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        console.log("RESIZE");
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="seoyeonc/sy_hub" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>