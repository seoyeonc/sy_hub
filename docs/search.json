[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This blog was generated to manage my blogs.\nThere are two purposes for achieving something here.\n\nFirst\nI will get definitions of any subjects and organize that in my words.\nIt is important to understand those information if I want to research exactly and improve myself.\n\n\nSecond\nI will brief my past and present researches.\nOverall, this blog will be the essential step for developing my skills."
  },
  {
    "objectID": "1_note.html",
    "href": "1_note.html",
    "title": "Note",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nJan 10, 2024\n\n\nDay5: 실습64 - 실습??\n\n\n최규빈 \n\n\n\n\nJan 5, 2024\n\n\nDSTBX2023(4)\n\n\nSEOYEON CHOI\n\n\n\n\nJan 4, 2024\n\n\nDSTBX2023(3)\n\n\nSEOYEON CHOI\n\n\n\n\nJan 3, 2024\n\n\nDSTBX2023(2)\n\n\nSEOYEON CHOI\n\n\n\n\nJan 2, 2024\n\n\nDSTBX2023(1)\n\n\nSEOYEON CHOI\n\n\n\n\nDec 31, 2023\n\n\n[Note] Tips of Linux, Git and Blog\n\n\nSEOYEON CHOI\n\n\n\n\nNov 22, 2023\n\n\n[Note] DGX station 설정_메모 추가\n\n\nGUEBIN CHOI\n\n\n\n\nDec 31, 2022\n\n\nStudy for Spaces\n\n\nSEOYEON CHOI\n\n\n\n\nDec 7, 2022\n\n\nA1: 깊은복사와 얕은복사 (12주차)\n\n\nSEOYEON CHOI\n\n\n\n\nApr 4, 2022\n\n\nIntroduction to Python 5wk\n\n\nSEOYEON CHOI\n\n\n\n\nMar 23, 2022\n\n\nIntroduction to Python 4wk\n\n\nSEOYEON CHOI\n\n\n\n\nApr 26, 2019\n\n\n[Essays] 퓨리에 변환\n\n\n신록예찬 \n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Lectures_ing",
      "**Note**"
    ]
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "",
    "text": "copy"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#틀린이유",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#틀린이유",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "틀린이유",
    "text": "틀린이유\n\nid(a)\n\n139660748276272\n\n\n\nid(b)\n\n139660748276272\n\n\n실제로는 a,b가 저장된 메모리 주소가 동일함"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제1",
    "text": "예제1\n\na=[1,2,3]\nb=a\na.append(4)\nc=[1,2,3,4]\n\n여기에서 a,b,c는 모두 같은 value를 가진다.\n\na\n\n[1, 2, 3, 4]\n\n\n\nb\n\n[1, 2, 3, 4]\n\n\n\nc\n\n[1, 2, 3, 4]\n\n\n하지만 그 id까지 같은 것은 아니다.\n\nid(a), id(b), id(c)\n\n(139660748305984, 139660748305984, 139660748286224)"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제2",
    "text": "예제2\n\na=[1,2,3] \nb=a \na=[1,2,3]+[4] \n\na를 다시 정의한 것이라 보면 될 듯\n\na,b\n\n([1, 2, 3, 4], [1, 2, 3])\n\n\n\nid(a), id(b)\n\n(139660748313296, 139660748290960)"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-1",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-1",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제1",
    "text": "예제1\n\na=1+2021\nid(a)\n\n139660748450224\n\n\n일단 할당\n\nb=2023-1\nid(b)\n\n139660748450768\n\n\n독립적으로 오브젝트 만들었으니 id가 다르지\n\nid(2022)\n\n139660748450832"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-이제-다-이해했다고-생각했는데..",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-이제-다-이해했다고-생각했는데..",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제2: 이제 다 이해했다고 생각했는데..",
    "text": "예제2: 이제 다 이해했다고 생각했는데..\n\na=1+2 \nid(a)\n\n7402432\n\n\n\nb=4-1\nid(b)\n\n7402432\n\n\n이게 왜 똑같지..?\n(해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠.\n\nid(3)\n\n7402432"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-2",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-2",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제1",
    "text": "예제1\n\n아래의 예제를 살펴보자. (참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능)\n\n\nl1 = [3, [66,55,44]]\nl2 = l1\n\n\nid(l1),id(l2)\n\n(139660748249920, 139660748249920)\n\n\n\nl1[0]=4\n\n\nl1\n\n[4, [66, 55, 44]]\n\n\n\nl2\n\n[4, [66, 55, 44]]\n\n\n\nl2.append(5)\nl2\n\n[4, [66, 55, 44], 5]\n\n\n\nl1\n\n[4, [66, 55, 44], 5]"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-r과-같이-를-쓰고-싶다면",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-r과-같이-를-쓰고-싶다면",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제2: R과 같이 = 를 쓰고 싶다면?",
    "text": "예제2: R과 같이 = 를 쓰고 싶다면?\n\nl1 = [3, [66,55,44]]\nl2 = l1.copy()\n\n\nid(l1),id(l2) ## 드디어 주소가 달라졌다.\n\n(139660748530944, 139660748530784)\n\n\n주소 달라짐!!\n\nl1[0]=100\n\n\nl1\n\n[100, [66, 55, 44]]\n\n\n\nl2\n\n[3, [66, 55, 44]]"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제3-이제-다-이해했다고-생각했는데..",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제3-이제-다-이해했다고-생각했는데..",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제3: 이제 다 이해했다고 생각했는데..",
    "text": "예제3: 이제 다 이해했다고 생각했는데..\n\n이제 다 이해했다고 생각했는데..\n\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\n\n\nid(l1),id(l2)\n\n(139660807804960, 139660807804560)\n\n\n\nl1[1].append(33)\n\n\nl1\n\n[3, [66, 55, 44, 33]]\n\n\n\nl2\n\n[3, [66, 55, 44, 33]]\n\n\n왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지?"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-3",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-3",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제1",
    "text": "예제1\n\na=2222\nb=2222\n\n\nid(a),id(b)\n\n(139660739479536, 139660739478192)\n\n\n메모리 상황\n\n2222라는 오브젝트가 어떤공간(id(a): 139753545300880)에 생성되고 그 공간에 a라는 라벨이 붙음\n2222라는 오브젝트가 어떤공간(id(b): 139753545300880)에 생성되고 그 공간에 b라는 라벨이 붙음\n\n즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-1",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-1",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제2",
    "text": "예제2\n\na=[1,2,2222]\nb=[1,2,2222]\n\n메모리 공간에 1,2는 이미 저장되어 있어서 생성할 필요 없고 2022만 메모리 공간에 생성하면 된다.\n\nid(a), [id(a[0]),id(a[1]),id(a[2])] # a=[1,2,2222]\n\n(139660739560064, [7402368, 7402400, 139660739480272])\n\n\n\nid(b), [id(b[0]),id(b[1]),id(b[2])] # b=[1,2,2222] \n\n(139660739560864, [7402368, 7402400, 139660739479312])\n\n\n\na.append(4)\n\n\na\n\n[1, 2, 2222, 4]\n\n\n\nb\n\n[1, 2, 2222]\n\n\n메모리상황\n\n-5~256까지의 숫자는 미리 메모리에 저장되어 있다.(이터닝) 이중에서 1은 id(a[0]): 7394656, 2는 id(a[1]): 7394688에 저장되어있음.\n2222가 공간 id(a[2]): 139753178093776에서 만들어진다.\n어떠한 리스트오브젝트가 공간 id(a): 139753182327904에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 a라는 포스트잇을 붙인다.\n2222가 공간 id(a)[2]: 139753178095568에서 만들어진다.\n어떠한 리스트오브젝트가 공간 id(b): 139753173818656에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 b라는 포스트잇을 붙인다.\na라는 포스트잇이 붙은 공간으로 이동하여 원소에 4를 추가시킨다.\n\n즉 -5~256이외에 4개의 메모리 공간을 추가사용 (a,b,a의 2222,b의 2222)"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제3",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제3",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제3",
    "text": "예제3\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139660748288960, [7402432, 139660739562784])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139660739539504, [7402432, 139660739562784])\n\n\n메모리상황\n\n-5~256까지의 숫자가 메모리에 저장되어 있다.\n저장된 숫자중 66,55,44를 묶어서 리스트로 구성하고 이 리스트를 공간 id(l1[1]): 139753183707216에 저장.\n숫자 3과 공간 id(l1[1]): 139753183707216에 저장된 리스트 [66,55,44]를 하나로 묶어서 새로운 리스트를 구성하고 이를 공간 id(l1): 139753183437040에 저장. 공간 id(l1): 139753183437040에 l1이라는 포스트잇 생성.\n공간 id(l2): 139753182311120에 l1의 원소들을 모아서 새로운 리스트를 구성함. 공간 id(l2): 139753182311120에 l2라는 포스트잇 생성.\n\n\nl1[0] = 7777\nl1,l2\n\n([7777, [66, 55, 44]], [3, [66, 55, 44]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139660748288960, [139660739478544, 139660739562784])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139660739539504, [7402432, 139660739562784])\n\n\n\nl1[0]은 원래 공간 7394720와 binding 되어 있었음.\n\n그런데 7777이라는 새로운 오브젝트가 공간 id(l1): 139753178092080에 생성되고 l1[0]이 공간 139753178092080와 다시 binding 됨."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제4",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제4",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제4",
    "text": "예제4\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\nl1.append(7777)\n\n\nl1,l2\n\n([3, [66, 55, 44], 7777], [3, [66, 55, 44]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1]), id(l1[2])]\n\n(139660739540064, [7402432, 139660748258672, 139660739477968])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139660748282608, [7402432, 139660748258672])\n\n\n\n예제3, 예제4를 통하여 리스트가 가변형객체라는 것을 확인할 수 있다. 예제3의 경우 l1이 저장되어있던 메모리공간의 내용물이 [3,[66,55,44]] 에서 [7777,[66,55,44]] 로 바뀌었다. 예제4의 경우 l1이 저장되어있던 메모리공간의 내용물이 [3,[66,55,44]] 에서 [3,[66,55,44],7777] 로 바뀌었다."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제5-우리를-힘들게-했던-그-예제.",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제5-우리를-힘들게-했던-그-예제.",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제5: 우리를 힘들게 했던 그 예제.",
    "text": "예제5: 우리를 힘들게 했던 그 예제.\n(시점1)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\n\n\nl1,l2\n\n([3, [66, 55, 44]], [3, [66, 55, 44]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139660748600336, [7402432, 139660748255792])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139660748237712, [7402432, 139660748255792])\n\n\n(시점2)\n\nl1[1].append(7777)\n\nl1[1]의 묶음방식이 저장된 공간에 7777 추가할 거야\n\nl1,l2\n\n([3, [66, 55, 44, 7777]], [3, [66, 55, 44, 7777]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139660748600336, [7402432, 139660748255792])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139660748237712, [7402432, 139660748255792])\n\n\n해설: 사실 시점1에서 메모리 주소상황을 잘 이해했다면 신기한 일이 아니다. .copy()는 l1과 l2의 주소만 다르게 만들 뿐 내용물인 l1[0],l1[1]는 동일하니까."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제6-신임교수최규빈이영미",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제6-신임교수최규빈이영미",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제6: 신임교수=[‘최규빈’,‘이영미’]",
    "text": "예제6: 신임교수=[‘최규빈’,‘이영미’]\n- 최규빈, 이영미는 신임교수임\n\n신임교수 = ['최규빈','이영미']\n\n\nid(신임교수), id('최규빈'), id('이영미')\n\n(139660748511984, 139660748209680, 139660748209200)\n\n\n- 신임교수를 누군가는 막내들이라고 부르기도 함.\n\n막내들 = 신임교수 \n\n참조\n\nid(막내들), id(신임교수)\n\n(139660748511984, 139660748511984)\n\n\n“막내들”이라는 단어와 “신임교수”라는 단어는 사실 같은 말임\n여기까지 참조 설명\n- 새로운 교수 “박혜원”이 뽑혔음.\n\n신임교수.append(\"박혜원\")\n\n\n신임교수, 막내들\n\n(['최규빈', '이영미', '박혜원'], ['최규빈', '이영미', '박혜원'])\n\n\n- 전북대 통계학과에서 R특강팀을 구성하여 방학중 R교육을 실시하고자함. 특강팀은 우선 신임교수들로 구성.\n\nR특강팀 = 신임교수.copy()\nR특강팀 \n\n['최규빈', '이영미', '박혜원']\n\n\n- R특강팀에 최혜미교수님 추가. (그렇지만 최혜미교수님이 막내는 아니야.. // 참조와 shallow copy의 차이점)\n\nR특강팀.append(\"최혜미\") \n\n\nR특강팀, 신임교수, 막내들\n\n(['최규빈', '이영미', '박혜원', '최혜미'], ['최규빈', '이영미', '박혜원'], ['최규빈', '이영미', '박혜원'])\n\n\n- R특강팀에서 양성준 교수를 추가하여 파이썬 특강팀을 구성\n\n파이썬특강팀 = [R특강팀, \"양성준\"]\n파이썬특강팀\n\n[['최규빈', '이영미', '박혜원', '최혜미'], '양성준']\n\n\n- 이영미교수는 다른 일이 많아서 R특강 팀에서 제외됨. (그럼 자연히 파이썬에서도 제외됨!!)\n\nR특강팀.remove(\"이영미\")\n\n\nR특강팀, 파이썬특강팀\n\n(['최규빈', '박혜원', '최혜미'], [['최규빈', '박혜원', '최혜미'], '양성준'])\n\n\n하지만 이영미교수는 여전히 신임교수이면서 막내들임\n\n신임교수, 막내들\n\n(['최규빈', '이영미', '박혜원'], ['최규빈', '이영미', '박혜원'])\n\n\n- 새로운 교수로 “손흥민”이 임용됨.\n\n막내들.append(\"손흥민\")\n\n\n막내들, 신임교수\n\n(['최규빈', '이영미', '박혜원', '손흥민'], ['최규빈', '이영미', '박혜원', '손흥민'])\n\n\n- 그렇다고 해서 손흥민 교수가 바로 R이나 파이썬 특강팀에 자동소속되는건 아님\nshallow copy로 id 주소가 각각 할당되었기 때문\n\nR특강팀, 파이썬특강팀\n\n(['최규빈', '박혜원', '최혜미'], [['최규빈', '박혜원', '최혜미'], '양성준'])"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-motivation-example",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-motivation-example",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제1: Motivation example",
    "text": "예제1: Motivation example\n- 아래의 상황을 다시 생각해보자.\n\n파이썬특강팀 = [\"양성준\",[\"최규빈\",\"이영미\",\"최혜미\"]]\nADSP특강팀 = 파이썬특강팀.copy()\n파이썬특강팀[-1].remove(\"이영미\")\n\n\n파이썬특강팀, ADSP특강팀\n\n(['양성준', ['최규빈', '최혜미']], ['양성준', ['최규빈', '최혜미']])\n\n\n이슈: 이영미교수가 파이썬특강에서 제외되면서 ADSP특강팀에서도 제외되었음. 그런데 사실 이영미교수가 파이썬특강팀에서만 제외되길 원한 것이지 ADSP특강팀에서 제외되길 원한게 아닐수도 있음.\n해결: Deep copy의 사용\n\nimport copy\n\n패키지 필요\n\n파이썬특강팀 = [\"양성준\",[\"최규빈\",\"이영미\",\"최혜미\"]]\nADSP특강팀 = copy.deepcopy(파이썬특강팀)\n파이썬특강팀[-1].remove(\"이영미\")\n\n\n파이썬특강팀, ADSP특강팀\n\n(['양성준', ['최규빈', '최혜미']], ['양성준', ['최규빈', '이영미', '최혜미']])\n\n\n\ncopy?\n\n\nType:        module\nString form: &lt;module 'copy' from '/home/csy/anaconda3/envs/py37/lib/python3.7/copy.py'&gt;\nFile:        ~/anaconda3/envs/py37/lib/python3.7/copy.py\nDocstring:  \nGeneric (shallow and deep) copying operations.\nInterface summary:\n        import copy\n        x = copy.copy(y)        # make a shallow copy of y\n        x = copy.deepcopy(y)    # make a deep copy of y\nFor module specific errors, copy.Error is raised.\nThe difference between shallow and deep copying is only relevant for\ncompound objects (objects that contain other objects, like lists or\nclass instances).\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop\n b) because deep copy copies *everything* it may copy too much, e.g.\n    administrative data structures that should be shared even between\n    copies\nPython's deep copy operation avoids these problems by:\n a) keeping a table of objects already copied during the current\n    copying pass\n b) letting user-defined classes override the copying operation or the\n    set of components copied\nThis version does not copy types like module, class, function, method,\nnor stack trace, stack frame, nor file, socket, window, nor array, nor\nany similar types.\nClasses can use the same interfaces to control copying that they use\nto control pickling: they can define methods called __getinitargs__(),\n__getstate__() and __setstate__().  See the documentation for module\n\"pickle\" for information on these methods."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-2",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-2",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제2",
    "text": "예제2\n- deepcopy\n\nl1 = [3,[66,[55,44]]] \nl2 = copy.deepcopy(l1)\n\n\nl2[1][1].append(33)\n\n\nl1,l2\n\n([3, [66, [55, 44]]], [3, [66, [55, 44, 33]]])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 139660748278352\nl2: 139660748540176\n\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 139660748278352 [7402432, 139660739509776]\nl2: 139660748540176 [7402432, 139660739569056]\n\n\n\nprint('level 3')\nprint('l1:', id(l1), [id(l1[0]),[id(l1[1][0]),id(l1[1][1])]])\nprint('l2:', id(l2), [id(l2[0]),[id(l2[1][0]),id(l2[1][1])]])\n\nlevel 3\nl1: 139660748278352 [7402432, [7404448, 139660748244224]]\nl2: 139660748540176 [7402432, [7404448, 139660739567776]]\n\n\n묶음 방식이 달라지면서 다른 주소가 할당된 모습\n- 비교를 위한 shallow copy\n\nl1 = [3,[66,[55,44]]] \nl2 = l1.copy()\n\n\nl2[1][1].append(33)\n\n\nl1,l2\n\n([3, [66, [55, 44, 33]]], [3, [66, [55, 44, 33]]])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 139660739568976\nl2: 139660748318112\n\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 139660739568976 [7402432, 139660807428768]\nl2: 139660748318112 [7402432, 139660807428768]\n\n\n\nprint('level 3')\nprint('l1:', id(l1), [id(l1[0]),[id(l1[1][0]),id(l1[1][1])]])\nprint('l2:', id(l2), [id(l2[0]),[id(l2[1][0]),id(l2[1][1])]])\n\nlevel 3\nl1: 139660739568976 [7402432, [7404448, 139660748313776]]\nl2: 139660748318112 [7402432, [7404448, 139660748313776]]\n\n\n- 비교를 위한 참조\n\nl1 = [3,[66,[55,44]]] \nl2 = l1\n\n\nl2[1][1].append(33)\n\n\nl1,l2\n\n([3, [66, [55, 44, 33]]], [3, [66, [55, 44, 33]]])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 139660748238432\nl2: 139660748238432\n\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 139660748238432 [7402432, 139660748240128]\nl2: 139660748238432 [7402432, 139660748240128]\n\n\n\nprint('level 3')\nprint('l1:', id(l1), [id(l1[0]),[id(l1[1][0]),id(l1[1][1])]])\nprint('l2:', id(l2), [id(l2[0]),[id(l2[1][0]),id(l2[1][1])]])\n\nlevel 3\nl1: 139660748238432 [7402432, [7404448, 139660748531664]]\nl2: 139660748238432 [7402432, [7404448, 139660748531664]]\n\n\n주소 다 똑같아"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-4",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제1-4",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제1",
    "text": "예제1\n- 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라.\n\nl1= [3,[66,55,44]]\nl2= l1.copy() \nl1[-1].append(33)\n\n\nl1,l2\n\n([3, [66, 55, 44, 33]], [3, [66, 55, 44, 33]])\n\n\nshallow copy 썼으니까 같이 추가된 모습"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-3",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제2-3",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제2",
    "text": "예제2\n- 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라.\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33] \n\n\nl1,l2\n\n([3, [66, 55, 44, 33]], [3, [66, 55, 44]])\n\n\n\nid(l1),id(l2)\n\n(139660748276032, 139660748245744)\n\n\nl1에 재할당한 것이라 생각하면 된다."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제3-1",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제3-1",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제3",
    "text": "예제3\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33] \nl1[-1].remove(33)\n\n\nl1,l2\n\n([3, [66, 55, 44]], [3, [66, 55, 44]])\n\n\n\nid(l1),id(l2)\n\n(139660807804240, 139660748282048)"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제4-1",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제4-1",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제4",
    "text": "예제4\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33] \nl1[-1].remove(33)\nl1[-1].append(33)\n\n(잘못된 상상) 아래의 코드와 결과가 같을거야!!\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \n# l1[-1] = l1[-1]+[33] \n# l1[-1].remove(33)\nl1[-1].append(33)\n\n\nl1,l2 \n\n([3, [66, 55, 44, 33]], [3, [66, 55, 44, 33]])\n\n\n(하지만 현실은)\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33] \nl1[-1].remove(33)\nl1[-1].append(33)\n\n\nl1,l2\n\n([3, [66, 55, 44, 33]], [3, [66, 55, 44]])\n\n\n재할당의 개념이 있었기 때문에 주소가 다른게 할당된 것이고, 결국 다른 결과가 나온다."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제5",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#예제5",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "예제5",
    "text": "예제5\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] += [33] # l1[-1] = l1[-1]+[33] \nl1[-1].remove(33)\nl1[-1].append(33)\n\n\nl1,l2\n\n([3, [66, 55, 44, 33]], [3, [66, 55, 44, 33]])\n\n\n\nid(l1),id(l2)\n\n(139660739562464, 139660739561344)\n\n\n주소는 다르지만 재할당의 개념이 없어!\nl1에 append 하는 식으로 되어서 묶음 방식이 같이 움직인다.\n\n??? 예제4랑 예제5는 같은코드가 아니었음!!! a += [1] 는 새로운 오브젝트를 만드는게 아니고, 기존의 오브젝트를 변형하는 스타일의 코드였음! (마치 append 메소드처럼)"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#motivation-example",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#motivation-example",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "Motivation example",
    "text": "Motivation example\n- 우리는 이제 아래의 내용은 마스터함\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] += [33] # l1[-1].append(33)이랑 같은거..\n\n\nl1,l2\n\n([3, [66, 55, 44, 33]], [3, [66, 55, 44, 33]])\n\n\n- 아래의 결과를 한번 예측해볼까?\n\nl1=[3,(66,55,44)]\nl2=l1.copy()\nl2[1] += (33,)\n\n이번엔 튜플로\n\nl1,l2\n\n([3, (66, 55, 44)], [3, (66, 55, 44, 33)])"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#해설",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#해설",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "해설",
    "text": "해설\n(시점1)\n\nl1=[3,(66,55,44)]\nl2=l1.copy()\n\n이번엔 리스트 안에 튜플을 넣어봄\n\nl1,l2\n\n([3, (66, 55, 44)], [3, (66, 55, 44)])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 139660739586080\nl2: 139660807832512\n\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 139660739586080 [7402432, 139660748091792]\nl2: 139660807832512 [7402432, 139660748091792]\n\n\n(시점2)\n\nl2[1] += (33,)\n\n\nl1,l2\n\n([3, (66, 55, 44)], [3, (66, 55, 44, 33)])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 139660739586080\nl2: 139660807832512\n\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 139660739586080 [7402432, 139660748091792]\nl2: 139660807832512 [7402432, 139660739627824]\n\n\n주소 139753182280032에 있는 값을 바꾸고 싶지만 불변형이라 못바꿈 \\(\\to\\) 그냥 새로 만들자. 그래서 그걸 139753174874064에 저장하자.\n튜플의 묶음 방식은 불변형! 정의: 값을 변환할 수 없는 오브젝트다~ 새로 오브젝트 만들어 저장함.\n리스트 : 값을 바꿀 수 있는 오브젝트다, 묶음 방식을 바꿀 수 있다."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#차원의-실체",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#차원의-실체",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "2차원의 실체",
    "text": "2차원의 실체\n- 2차원 array a,b를 선언하자.\n\na = np.array([[11,22,33,44]]).reshape(2,2)\nb = np.array([[11,22,33,44,55,66]]).reshape(2,3)\nc = np.array([11,22,33,44]).reshape(4,1)\nd = np.array([11,22,33,44])\n\n- a,b,c,d 속성비교\n\na.shape, b.shape, c.shape, d.shape ## 차원 \n\n((2, 2), (2, 3), (4, 1), (4,))\n\n\n\na.strides, b.strides, c.strides, d.strides ## 차원이랑 관련이 있어보임.. + 8의 배수 \n\n((16, 8), (24, 8), (8, 8), (8,))\n\n\n- strides는 무엇?\n\nstrides: (다음 행으로 가기위해서 JUMP해야하는 메모리 공간수, 다음 열로 가기위해서 JUMP해야하는 메모리 공간수)\n\n- 사실 a,b,c,d 는 모두 1차원으로 저장되어있음. (중첩된 리스트꼴이 아니라)\nshape이나 strides 등의 옵션으로 1차원이 아니게 보여지는 것 뿐"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#참조",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#참조",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "참조",
    "text": "참조\n- a를 선언, b는 a의 참조\n\na=np.array([[1,2],[3,4]])\nb=a ## 참조 \n\n\na\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n\na.shape\n\n(2, 2)\n\n\n\nb.shape\n\n(2, 2)\n\n\n- a의 shape을 바꾸어보자 \\(\\to\\) b도 같이 바뀐다\n\na.shape = (4,)\n\n\na\n\narray([1, 2, 3, 4])\n\n\n\nb\n\narray([1, 2, 3, 4])\n\n\n\nid(a),id(b)\n\n(139660739644368, 139660739644368)"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#view",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#view",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "view",
    "text": "view\n- a를 선언, b는 a의 view\n\na=np.array([[1,2],[3,4]]) \nb=a.view() ## shallow copy 라고 부르기도 한다. \n\n\na\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n\na.shape\n\n(2, 2)\n\n\n\nb.shape\n\n(2, 2)\n\n\n\na.shape= (4,1)\n\n\na\n\narray([[1],\n       [2],\n       [3],\n       [4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nid(a), id(b)\n\n(139660382911248, 139660382911344)\n\n\nview가 shallow copy 같은 이유 껍데기 주소만 복사해옴, 공간에 대한 주소는 같지 않음\n- 그런데..\n\na[0]=100\n\n\na\n\narray([[100],\n       [  2],\n       [  3],\n       [  4]])\n\n\n\nb\n\narray([[100,   2],\n       [  3,   4]])\n\n\n- 출생의 비밀\n\nb\n\narray([[100,   2],\n       [  3,   4]])\n\n\n\nb.base\n\narray([[100],\n       [  2],\n       [  3],\n       [  4]])\n\n\n\n? 이거 바뀐 a아니야?\n\n\nid(b.base), id(a)\n\n(139660382911248, 139660382911248)\n\n\n- View - b가 a의 뷰라는 의미는, b가 a를 소스로하여 만들어진 오브젝트란 의미이다. - 따라서 이때 b.base는 a가 된다. - b는 자체적으로 데이터를 가지고 있지 않으며 a와 공유한다. - 이러한 의미에서 view를 shallow copy 라고 부른다. (stride, shape과 같은 껍데기만 새로 생성, base는 유지)\nnote1 원본 ndarray의 일 경우는 .base가 None으로 나온다.\n\na.base\n\n\nprint(a.base)\n\nNone\n\n\nnote2 b.base의 shpae과 b의 shape은 아무 관련없다.\n\nb.shape\n\n(2, 2)\n\n\n\nb.base.shape\n\n(4, 1)"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#copy",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#copy",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "copy",
    "text": "copy\n- a를 선언, b는 a의 copy\n\na=np.array([[1,2],[3,4]])\nb=a.copy() # 껍데기를 새로 생성 (strides, shape) + base도 새로생성 \n\n\nid(a),id(b)\n\n(139660382910288, 139660382910000)\n\n\n- a의 shape을 바꿔도 b에는 적용되지 않음\n\na.shape = (4,1)\na\n\narray([[1],\n       [2],\n       [3],\n       [4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n- 그리고 a[0]의 값을 바꿔도 b에는 적용되지 않음.\n\na[0]=100\n\n\na\n\narray([[100],\n       [  2],\n       [  3],\n       [  4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n- b의 출생을 조사해보니..\n\na.base,b.base\n\n(None, None)\n\n\n출생의 비밀은 없었다. 둘다 원본.\n- .view() 는 껍데기만, .copy() 는 껍데기 + base 까지 새로생성\n\nAppendix: .copy의 한계(?)\n\na=np.array([1,[1,2]],dtype='O')\na\n\narray([1, list([1, 2])], dtype=object)\n\n\n\nb=a.copy()\n\n\nb\n\narray([1, list([1, 2])], dtype=object)\n\n\n\na[0]=222\n\n\na\n\narray([222, list([1, 2])], dtype=object)\n\n\n\nb\n\narray([1, list([1, 2])], dtype=object)\n\n\n\na[1][0]=333\n\n\na\n\narray([222, list([333, 2])], dtype=object)\n\n\n\nb\n\narray([1, list([333, 2])], dtype=object)\n\n\n해결책: 더 깊은 복사\n\nimport copy \n\n\na=np.array([1,[1,2]],dtype='O')\nb=copy.deepcopy(a)\n\n\na\n\narray([1, list([1, 2])], dtype=object)\n\n\n\nb\n\narray([1, list([1, 2])], dtype=object)\n\n\n\na[0]=100\n\n\na,b\n\n(array([100, list([1, 2])], dtype=object),\n array([1, list([1, 2])], dtype=object))\n\n\n\na[1][0]=200\n\n\na,b\n\n(array([100, list([200, 2])], dtype=object),\n array([1, list([1, 2])], dtype=object))\n\n\n- 중간요약\n\n사실 .copy()는 온전한 deep copy 가 아니라 level 2 deep copy 이다.\n따라서 .copy()는 base의 정보를 shallow copy 한다 (level 1 deep copy 한다.)\n그래서 base가 다시 중첩구조를 가지는 경우는 온전한 deep-copy가 수행되지 않는다.\n그런데 일반적으로 넘파이를 이용할때 자주 사용하는 데이터 구조인 행렬, 텐서등은 base가 중첩구조를 가지지 않는다. (1차원 array로만 저장되어 있음)\n따라서 행렬, 텐서에 한정하면 .copy()는 온전한 deep copy라고 이해해도 무방하다.\n\n행/열 같지 않으면 numpy쓰면 힘들걸..\n모든 데이터 구조가 2차원까지로 정리 된다."
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#별명-뷰-카피",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#별명-뷰-카피",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "별명, 뷰, 카피",
    "text": "별명, 뷰, 카피\n- test 함수 작성\n\ndef test(a,b): \n    if id(a) == id(b): \n        print(\"별명\")\n    elif id(a) == id(b.base) or id(a.base)==id(b): \n        print(\"뷰\")\n    elif (id(a.base)!=id(None) and id(b.base)!=id(None)) and id(a.base) == id(b.base):\n        print(\"공통의 base를 가짐\")\n    else: \n        print(\"카피, 혹은 아무 관련없는 오브젝트\") \n\n- 잘 동작하나?\n(테스트1)\n\na=np.array([1,2,3,4])\nb=a\n\n\ntest(a,b)\n\n별명\n\n\n참조\n(테스트2)\n\na=np.array([1,2,3,4])\nb=a.view()\n\n\ntest(a,b)\n\n뷰\n\n\n(테스트3)\n\na=np.array([1,2,3,4])\nb=a.view()\nc=a.view()\n\n\ntest(b,c)\n\n공통의 base를 가짐\n\n\n\ntest(a,b)\n\n뷰\n\n\n\ntest(a,c)\n\n뷰\n\n\n(테스트4)\n\na=np.array([1,2,3,4])\nb=a.copy()\n\n\ntest(a,b)\n\n카피, 혹은 아무 관련없는 오브젝트"
  },
  {
    "objectID": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#결론",
    "href": "posts/1_Note/2022-12-07-얕은복사_깊은복사.html#결론",
    "title": "A1: 깊은복사와 얕은복사 (12주차)",
    "section": "결론",
    "text": "결론\n- 우리가 사용했던 어떠한 것들이 뷰가 나올지 카피가 나올지 사실 잘 모른다. (그래서 원리를 이해해도 대응할 방법이 사실없음)\n\n예시1\n\na=np.array([1,2,3,4])\nb=a[:3]\n\n\na\n\narray([1, 2, 3, 4])\n\n\n\nb\n\narray([1, 2, 3])\n\n\n\ntest(a,b)\n\n뷰\n\n\n\nc=a[[0,1,2]]\nc\n\narray([1, 2, 3])\n\n\n\ntest(a,c)\n\n카피, 혹은 아무 관련없는 오브젝트\n\n\n\nd = a[3]\n\n\ntest(a,d)\n\n카피, 혹은 아무 관련없는 오브젝트\n\n\n\n\n예시2\n\na=np.array([[1,2],[3,4]])\na\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nb=a.flatten()\nc=a.ravel()\nd=a.reshape(-1)\n\n\ntest(a,b)\n\n카피, 혹은 아무 관련없는 오브젝트\n\n\n\ntest(a,c)\n\n뷰\n\n\n\ntest(a,d)\n\n뷰\n\n\n\ntest(c,d)\n\n공통의 base를 가짐\n\n\n\ntest(b,c)\n\n카피, 혹은 아무 관련없는 오브젝트"
  },
  {
    "objectID": "posts/1_Note/2022-03-28-(4주차) 3월28일.html",
    "href": "posts/1_Note/2022-03-28-(4주차) 3월28일.html",
    "title": "Introduction to Python 4wk",
    "section": "",
    "text": "개발환경의 변천사, 1세대 프로그래머부터 5세대 프로그래머까지\n\nhttps://guebin.github.io/IP2022/2022/03/28/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9428%EC%9D%BC.html\n\n강의영상\n\nyoutube: https://youtube.com/playlist?list=PLQqh36zP38-zcnjAged1xIatgznRTy93c\n\n- (1/8) 파이썬이 어려웠던 이유\n- (2/8) 1세대 프로그래머\n- (3/8) 1세대 프로그래머의 삶 with python\n- (4/8) 1세대 프로그래머의 삶 with ipython\n- (5/8) 2세대 프로그래머, 3세대 프로그래머 (1)\n- (6/8) 3세대 프로그래머(2), 4세대 프로그래머\n- (7/8) 5세대 프로그래머\n- (8/8) 다양한 개발환경 구축방법 다시 리뷰, 숙제설명\n\n\n파이썬이 어려웠던 이유\n- 파이썬 배우는 초보자에게 가장 어려운것! - 선생님마다 설치하는 방법이 모두 다름\n- 왜 저렇게 설치방법이 다른가? 왜 다른 방법으로 각각 파이썬을 실행하는가? 이런것이 너무 어려움 - 방법1: 파이썬프로그램 다운로드 -&gt; 시작버튼 눌러서 설치 - 방법2: 아나콘다 설치 (그럼 자동으로 파이썬이 설치됨) - 방법3: 아나콘다 설치 + 가상환경 - …\n- 심지어 실행하는것도 다름 - 방법1: 파이썬 프롬프트 - 방법2: .py를 이용하여 실행? - 방법3: IDLE - 방법4: 파이참 - 방법5: 스파이더 - 방법6: Visual Studio Code - 방법7: 주피터노트북, 주피터랩 - 가상환경을 만들어서 해라.. - 아나콘다 네비게이터에 주피터가 있다.. - …\n- 머리아프니까 collab을 쓰라는 사람도 있음. 아니면 도커이미지를 줄테니까 그걸 쓰라는 사람도 있음. AWS를 쓰라는 사람도 있음.. \\(\\to\\) 이게 더 머리아픔\n- 핵심: 그냥 (1) 컴퓨터에 (2) 파이썬을 깔아서 (3) 실행하는 것임\n- 의문: 그런데 방법이 왜이렇게 많은가? 엑셀처럼 프로그램 설치하고 아이콘 더블클릭하면 끝나는 식으로 만들어야 하는것 아닌가?\n\n개발환경 구축방법이 많은 이유?\n- 파이썬 개발환경 구축은 수많은 방법이 있다.\n- 이는 마치 라면의 레시피를 검색하면 수많은 방법이 나오는것과 유사함. - 방법1: 스프를 먼저 넣고 끓인다음 라면을 넣어야 합니다. - 방법2: 양은냄비에 물넣고 물이 끊으면 라면과 스프를 같이 넣고 마지막에 계란을 넣는다. - 방법3: 먹다남은 삼겹살을 후라이팬에 볶은다음에 물을 붓고 라면을 넣는다. - 방법4: 용기에 라면+스프+뜨거운물 랩을 씌운뒤에 젓가락으로 구멍을 뚫고 전자렌지에 돌린다. - …\n- 우리는 모든 방법을 나열할 순 없지만 모든 방법을 이해할 수 있다. 왜냐하면 라면을 끓이는 공통적인 맥락을 우리는 알고 있으니까\n- 파이썬을 설치하는 다양한 방법 역시 공통맥락을 파악하면 이해하기 쉽다.\n- 제목적: 파이썬을 설치하고 실행하는 공통맥락을 설명하고 싶음\n- 설치하는 방법이 다양한 이유? 파이썬이 인기있음 + 다양한 방법을 설치를 하면 각자의 장점이 뚜렷해서\n\n\n\n1세대 프로그래머\n\npython\n- 윈도우에서 anaconda prompt 실행 -&gt; python\n(base) C:\\Users\\python&gt;python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; [1,2,3]+[4]\n[1, 2, 3, 4]\n&gt;&gt;&gt; a=[1,2,3]+[4]\n&gt;&gt;&gt; a\n[1, 2, 3, 4]\n- 2개를 실행할 수도 있음. (두 환경은 각각 서로 독립적인 파이썬, 변수가 공유되지 않음) \\(\\star\\)\n- 아쉬운점: `?list’와 같이 도움말 기능이 동작하지 않음\n&gt;&gt;&gt; ?list\n  File \"&lt;stdin&gt;\", line 1\n    ?list\n    ^\nSyntaxError: invalid syntax\n&gt;&gt;&gt; \n\n\nipython\n- 윈도우에서 anaconda prompt 실행 -&gt; ipython\n(base) C:\\Users\\python&gt;ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: a=[1,2,3]\n\nIn [2]: a\nOut[2]: [1, 2, 3]\n\nIn [3]: a+[4]\nOut[3]: [1, 2, 3, 4]\n- ?list가 가능\nIn [4]: ?list\nInit signature: list(iterable=(), /)\nDocstring:\nBuilt-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\nType:           type\nSubclasses:     _HashedSeq, StackSummary, DeferredConfigList, SList, _ImmutableLineList, FormattedText, NodeList, _ExplodedList, Stack, _Accumulator, ...\n\n- 색깔이 알록달록해서 문법을 보기 편하다. (구문강조)\n\n\n1세대 프로그래머의 삶 with python\n- 1부터 10까지 합을 구하는 프로그램을 만들고 싶음\n- 시도1: python을 키고 아래와 같이 실행\n(base) C:\\Users\\python&gt;python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; total = 0\n&gt;&gt;&gt; for i in range(10):\n...     total=total+i\n...\n&gt;&gt;&gt; total\n45\n&gt;&gt;&gt;\n- 반성: 정답은 55인데 45가 출력되었다! \\(\\to\\) range(10)을 range(1,11)으로 바꿔야겠다!\n- 시도2: range(1,11)을 바꿔야겠다고 생각하고 다시 입력하다가 오타가 발생\n&gt;&gt;&gt; total =0\n&gt;&gt;&gt; for i in range(1,11):\n...     total = totla +i\n...\n\n앗 totla이라고 잘못쳤다.\n\n- 반성: 다음에는 정신을 똑바로 차려야겠다.\n- 불편한점: … 다..\n\n\n1세대 프로그래머의 삶 with ipython\n- ipython을 사용한 프로그래머는 좀더 상황이 낫다\n(base) C:\\Users\\python&gt;ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: total = 0\n\nIn [2]: for i in range(1,11):\n   ...:     total = total + i\n   ...:\n\nIn [3]: total\nOut[3]: 55\n\n편한점1: 자동으로 들여쓰기가 되어서 편함\n편한점2: 화살표를 이용해서 for문을 쓰는 도중에 위아래로 이동가능\n불편한점1: 화살표로 이동할수는 있는데 마우스로는 이동할 수 없다.\n불편한점2: 내가 작성한 코드를 관리하기 어렵다.\n\n\n\n\n2세대 프로그래머: 메모장 + anconda prompt를 이용 (.py를 이용한 python활용)\n- 메모장을 키고 아래의 내용을 적는다.\ntotal = 0 \nfor i in range(1,11): \n    total = total + i\nprint(total)\n- 파일이름을 mysum.py로 저장한다.\n- anaconda prompt에서 mysum.py파일이 저장된 폴더로 이동 -&gt; 실행\n(base) C:\\Users\\python&gt;cd Desktop\n\n(base) C:\\Users\\python\\Desktop&gt;dir\n C 드라이브의 볼륨에는 이름이 없습니다.\n 볼륨 일련 번호: 9AFD-A05F\n\n C:\\Users\\python\\Desktop 디렉터리\n\n2022-03-27  오전 11:32    &lt;DIR&gt;          .\n2022-03-27  오전 11:32    &lt;DIR&gt;          ..\n2022-03-27  오전 12:01             2,306 Chrome.lnk\n2022-03-26  오후 08:32             2,332 Microsoft Edge.lnk\n2022-03-27  오전 11:33                71 mysum.py\n               3개 파일               4,709 바이트\n               2개 디렉터리  743,643,467,776 바이트 남음\n\n(base) C:\\Users\\python\\Desktop&gt;python mysum.py\n55\n\n(base) C:\\Users\\python\\Desktop&gt;\n- 소감 - 편한점1: 마우스를 이용하여 이동가능 - 편한점2: 내가 작업한 내용은 바탕화면의 메모장에 저장이 되어있음 - 아쉬운점: ipython의 장점은 활용못함 (구문강조, 도움말기능)\n\n\n3세대 프로그래머: 메모장 + ipython\n- 전체적인 개발방식 - 메모장: 코드를 편집, 저장 - ipython: anaconda prompt처럼 메모장의 코드를 실행하고 결과를 확인 + 구문강조, 도움말확인기능 등을 이용하여 짧은 코드를 빠르게 작성\n- 기능 - ipython에서 !python mysum.py를 입력하면 anaconda prompt에서 python mysum.py를 입력한 것과 같은 효과 - ipython에서 %run mysum을 입력하면 메모장에서 mysum.py에 입력된 내용을 복사해서 ipython에 붙여넣어 실행한것과 같은 효과\n\n\n4세대 프로그래머: IDE(통합개발환경)를 사용\n- 메모장과 ipython을 하나로 통합한 프로그램이 등장! - jupyter notebook, jupyter lab - spyder - idle - VScode - …\n- 주피터의 트릭 (실제로 주피터는 ipython에 기생할 뿐 아무런 역할도 안해요)\n\n주피터를 실행\n새노트북을 생성 (파이썬으로 선택)\n\n\n컴퓨터는 내부적으로 ipython을 실행하고 그 ipython이랑 여러분이 방금만든 그 노트북과 연결\n\n\n처음보이는 cell에 1+1을 입력 -&gt; 쉬프트엔터 -&gt; 결과2가 출력\n\n\n처음보이는 cell하나 = 자동으로 열린 하나의 메모장\ncell 1+1을 입력 = 메모장에 1+1을 적음\n쉬프트+엔터후 결과2를 출력 = cell의 내용을 복사 -&gt; ipython에 붙여넣음 -&gt; ipython 계산된 결과를 복사 -&gt; cell로 돌아와 붙여넣기\n\n\n새로운 cell을 추가하고 2+2을 입력 -&gt; 쉬프트엔터 -&gt; 결과4가 출력\n\n\n새로운 cell을 추가 = 새로운 메모장 추가\ncell 2+2을 입력 = 새로운 메모장에 2+2를 적음\n쉬프트+엔터후 결과4를 출력 = cell의 내용을 복사 -&gt; ipython에 붙여넣음 -&gt; ipython 계산된 결과를 복사 -&gt; cell로 돌아와 붙여넣기\n\n- 중요한 사실들 - IDE는 내부적으로 연산을 수행하는 능력이 없다. (생각해볼것: 왜 R을 꼭 설치하고 Rstudio를 설치해야 했을까?) - 주피터에서 커널을 재시작한다는 의미는 메모장이 열린채로 ipython을 껐다가 다시 실행한다는 의미 - 주피터는 단순히 ’메모장의 내용을 복사하여 붙여넣는 기계’라고 볼 수 있다. 이렇게 생각하면 주피터는 꼭 ipython에 연결할 이유는 없다. 실제로 주피터에 R을 연결해서 쓸 수 있다. 즉 하나의 IDE가 여러개의 언어와 연결될 수 있다. - Jupyterlab이라는 프로그램은 크롬에 있는 내용과 ipython간의 통신을 제어하는 프로그램일 뿐이다.\n\n\n5세대 프로그래머: 가상컴퓨터(anaconda), 원격컴퓨터(server), 클라우드컴퓨터(colab)의 개념 등장\n- 지금까지는 ipython이 실행되는 컴퓨터와 크롬이 실행되는 컴퓨터가 동일하다는 전제였음.\n- 생각해보니까 어차피 ipython이 실행된 컴퓨터에서 내가 크롬에 입력한 명령 “전달”되기만 하면 되므로 꼭 같은 컴퓨터일 필요는 없다.\n\n모델1: 원격컴퓨터\n- 준비상태 - 전북대컴퓨터: ipython을 실행 + 이 컴퓨터는 인터넷 연결이 되어있어야함 - 우리집노트북: 크롬실행 + 이 컴퓨터도 인터넷이 연결되어 있어야함\n- 명령입력 - 우리집노트북 크롬에서 1+1을 입력하고 쉬프트 엔터를 누름\n- 우리집노트북 -&gt; 전북대컴퓨터 - 우리집 노트북의 내부의 어떤프로그램은 1+1이라는 명령을 복사하여 카카오톡으로 전북대 컴퓨터에 전달 - 전북대 컴퓨터의 내부의 어떤프로그램은 1+1이라는 명령을 카톡으로 받아서 그것을 ipython에게 전달\n- 전북대컴퓨터 -&gt; 우리집노트북 - 전북대컴퓨터 내부의 ipython은 2라는 출력결과를 계산함 - 전북대컴퓨터 내부의 어떤프로그램은 계산결과를 카톡으로 우리집 노트북에 알려줌 - 나는 우리집 노트북에서 계산결과를 받아볼 수 있다.\n\n\n모델2: 원격컴퓨터 + 가상컴퓨터\n- 준비상태 - 성능좋은 전북대 컴퓨터 1개 - 내 노트북 1개 (그냥 싸고 가벼운거) - 대학원생 아이패드 1개 (그냥 싸고 가벼운거)\n- 아이디어\n\n성능좋은 전북대 컴퓨터를 논리적으로 3개로 분리 \\(\\to\\) 이를 각각 (base) (py39jl17) (py38r40) 컴퓨터라고 하자.\n나는 (py39jl17)에 접속하여 파이썬 3.9와 줄리아 1.7을 설치한뒤 실습한다.\n대학원생은 (py38r40)에 접속하여 파이썬 3.8과 R 4.0을 설치하고 실습한다.\n(base)는 예비용으로 아무것도 설치안한 깨끗한 상태 유지\n내가 뭘 실수해서 (py39jl17)컴퓨터가 망가졌으나 (py38r40)은 아무 타격없다.\n나는 (py39jl17)를 삭제하고 (base)로 부터 다시 새로운 컴퓨터를 복사하여 (py39jl17)을 다시 만든다.\n\n\n\n모델3: 가상컴퓨터\n- 여러분들 사례 - 여러분들의 컴퓨터는 (base), (py39) 2개의 컴퓨터로 나누어져 있음 - 여러분들이 (py39)에만 주피터랩을 설치 - (py39)에 있는 ipython과 여러분의 크롬창이 서로 통신하면서 실습 - 장점: 서로 다른 환경에 서로다른 파이썬과 R등을 설치할 수 있다. \\(\\to\\) 패키지간의 충돌이 최소화 (파이썬 입문 수업을 듣고, 이후에 파이썬을 이용하는 어떤수업을 들음)\n\n\n모델4: 클라우드\n- 사례1 - 성능이 그저그런 컴퓨터 27개 - 대학원생을 포함하여 쓸 사람은 5명 - 한사람당 27/5(=5.4)대의 컴퓨터식 할당\n- 사례2: 구글코랩 - 구글에 여러가지 성능을 가진 컴퓨터가 \\(n\\)대 있음 - \\(m\\)명의 사람이 \\(n\\)대의 컴퓨터에 접속 - 적당히 컴퓨터 자언을 분배하여 사용\n\n\n\n요약 및 정리\n- 결국 (1) 컴퓨터에 (2) 파이썬을 설치하고 (3) 실행하는 과정은 생각보다 다양한 선택의 조합이 가능하다.\n\n그냥 내 노트북에 파이썬을 설치할지? 내 노트북안에 가상컴퓨터를 만들고 거기에 파이썬을 설치할지? 학교의 데스크탑에 파이썬을 설치하고 쓸지? 설치를 안하고 구글컴퓨터에 설치된 파이썬을 난 쓰기만 할지?\npython설치할지? ipython를 설치할지? 어차피 가상환경을 쓸꺼니가 anaconda를 설치할지? 아니면 코랩쓸꺼니까 설치안할지?\n어떤 IDE를 쓸지? IDE를 쓰지 않을지? 내가 IDE를 직접구성해서 만들지?\n\n하지만 공통적으로 관통하는 원리가 있다\n\n\n숙제\n- 주피터랩에서 ’myprod.py’파일을 만들고 1부터 5까지의 곱을 계산하는 코드를 작성후 %run myprod를 실행하여 출력결과를 확인"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html",
    "title": "DSTBX2023(3)",
    "section": "",
    "text": "- 186에서 깃+깃헙연결할때 어려운점.\n\n토큰을 쳐야한다는게 어려움.\n윈도우에서는 직접로그인으로 인증했음. 코드스페이스에서는 별도의 인증과정이 필요없었음.\n일반서버에서는 토큰으로 해결해야함. (다른 방법도 있는데 그냥 이게 젤 편함)\n\n- 비밀번호 치는게 귀찮으면?\ngit config credential.helper store # 이걸실행하고 이후에 한번만 푸시하면 된다. \ngit add .\ngit commit -m . \ngit push"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습26-186-컴퓨터에서-깃깃헙연결하기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습26-186-컴퓨터에서-깃깃헙연결하기",
    "title": "DSTBX2023(3)",
    "section": "",
    "text": "- 186에서 깃+깃헙연결할때 어려운점.\n\n토큰을 쳐야한다는게 어려움.\n윈도우에서는 직접로그인으로 인증했음. 코드스페이스에서는 별도의 인증과정이 필요없었음.\n일반서버에서는 토큰으로 해결해야함. (다른 방법도 있는데 그냥 이게 젤 편함)\n\n- 비밀번호 치는게 귀찮으면?\ngit config credential.helper store # 이걸실행하고 이후에 한번만 푸시하면 된다. \ngit add .\ngit commit -m . \ngit push"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습27-작업하던-블로그를-강의실-윈도우로-clone",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습27-작업하던-블로그를-강의실-윈도우로-clone",
    "title": "DSTBX2023(3)",
    "section": "실습27: 작업하던 블로그를 강의실 윈도우로 clone",
    "text": "실습27: 작업하던 블로그를 강의실 윈도우로 clone\n- 아래를 실행하면 됩니당\ngit clone {repo-name} # 처음부터 새로만듦"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습28-블로그-생성원리-이해하기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습28-블로그-생성원리-이해하기",
    "title": "DSTBX2023(3)",
    "section": "실습28: 블로그 생성원리 이해하기",
    "text": "실습28: 블로그 생성원리 이해하기\n- 아래를 실행하고 git switch를 사용할시 무슨일이 생기는지 파악\n# git add . \n# git commit -m . # 이거 2개가 깃에서의 save 라고 생각하자. \ngit switch gh-pages\ngit switch main \n- 위의 과정을 반복해보면서 폴더를 관찰. 느낀점 서술\n- git switch gh-pages한 상태에서 폴더에 존재하는 html파일들을 열어볼 것.\n\n\n\n\n\n\nNote\n\n\n\ngit switch gh-pages - html 로 열리는 about 등 파일\ngit switch main - qmd 로 열리는 about 등 파일"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습29-블로그-깨기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습29-블로그-깨기",
    "title": "DSTBX2023(3)",
    "section": "실습29: 블로그 깨기",
    "text": "실습29: 블로그 깨기\n- git swtich gh-pages한 상태에서 폴더에 존재하는 모든 파일을 삭제 \\(\\to\\) 본인 홈페이지에 가보자. 홈페이지는 살아 있는가?\n- 아래를 실행하고 본인홈페이지에 방문해보자. 홈페이지는 살아있는가?\ngit add . \ngit commit -m .\ngit push\n- 왜 죽었다고 생각하는가?\n- 깃헙 특수기능 중 하나인 웹페이지 배포능력에 대하여 스스로 이해한 바를 서술해보자."
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습30-코드를-숨기는-블로그-야메",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습30-코드를-숨기는-블로그-야메",
    "title": "DSTBX2023(3)",
    "section": "실습30: 코드를 숨기는 블로그 (야메)",
    "text": "실습30: 코드를 숨기는 블로그 (야메)\n- 주피터다운로드 후 블로그를 만드는 것은 포스트를 엄청 빠르게 만드는 사기적 능력임\n\nhttps://scikit-learn.org/stable/auto_examples/index.html\nhttps://matplotlib.org/stable/gallery/index.html\n\n- 내가 베낄때는 좋지만 누군가가 내 블로그를 베낀다 생각하면 기분나쁠 수 있음\n- 실습29를 응용하여 코드가 없는 블로그를 만들어보자"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습31-코드를-숨기는-블로그-합법",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습31-코드를-숨기는-블로그-합법",
    "title": "DSTBX2023(3)",
    "section": "실습31: 코드를 숨기는 블로그 (합법)",
    "text": "실습31: 코드를 숨기는 블로그 (합법)\n- 의문점: 그런데 작업내용을 블로그에 올릴때 꼭\ngit add . \ngit commit -m . \ngit push\nquarto publish --no-browser --no-prompt\n순서로 업로드 해야하는가? 그냥 단순히\nquarto publish --no-browser --no-prompt\n만 하면 안되는가? (경험상 되던데요?)\n- 코드를 숨길 수 있는 블로그를 만들고 싶다면? 어떻게 하면 좋을지 생각해보자."
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습32-pull-push-잘-쓰면-편해",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습32-pull-push-잘-쓰면-편해",
    "title": "DSTBX2023(3)",
    "section": "실습32: pull + push (잘 쓰면 편해)",
    "text": "실습32: pull + push (잘 쓰면 편해)\n- 186 컴퓨터 (혹은 본인이 주로 쓰는 서버 컴퓨터) 에서 pull\n- 186 컴퓨터에서 수정 \\(\\to\\) push\n- 실습실 컴퓨터에서 다시 pull\n- 실습실 컴퓨터에서 수정 \\(\\to\\) push\n- 소감:"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습33-pull-push-난-불편해",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습33-pull-push-난-불편해",
    "title": "DSTBX2023(3)",
    "section": "실습33: pull + push (난 불편해)",
    "text": "실습33: pull + push (난 불편해)\n- 186 컴퓨터 (혹은 본인이 주로 쓰는 서버 컴퓨터) 에서 pull\n- 186 컴퓨터에서 수정 \\(\\to\\) push 안함\n- 실습실 컴퓨터에서 수정 \\(\\to\\) push\n- 186컴퓨터는 뭐야? \\(\\to\\) push 시도.. \\(\\to\\) 실패\n- 해결책:"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습34-gh-pages에서-만들기-싫다면..",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습34-gh-pages에서-만들기-싫다면..",
    "title": "DSTBX2023(3)",
    "section": "실습34: gh-pages에서 만들기 싫다면..?",
    "text": "실습34: gh-pages에서 만들기 싫다면..?\n- 생각해보니까 딱히 내 코드가 비밀은 아님\n- 브랜치를 쓰는게 이론상 깔끔하긴 한데 막상 쓰려니까 불편함. (그 파일이 순간적으로 없어지는 거잖아요?.. 엄청 찝찝해요)\n- quarto publish는 아래동작의 결합이다.\nquarto render \n# html파일들이 어딘가 만들어져있음. \ngit switch gh-pages\n# 만들어진 html파일들이 복사됨. \ngit add .\ngit commit -m . \ngit push \ngit switch main \n- 아래와 같이 수정하고 싶다면?\nquarto render \n# html파일들을 docs라는 폴더에 저장\ngit add .\ngit commit -m . \ngit push \n그리고 깃헙설정을 변경한다면?\n- 하는방법\nstep1\ngit switch main # 으로 와서\ngit push origin --delete gh-pages # 로칼에서 브랜치삭제 + 원격으로 업데이트\ngit switch gh-pages # rm -rf -a 해서 다 지우고\ngit switch main #\n\n\ngit add .\ngit commit -m .\ngit push \nstep2\n\b_quarto.yml 수정하기\n\n\n_quarto.yml\n\nproject:\n  type: website\n  output-dir: docs # &lt;- 이거 추가하세요\n# 이 아래는 수정필요없음 \n\nstep3\n이후 https://github.com/{user-name}/{repo-name}/settings/pages 로 이동하여 셋팅을 변경하면 된다.\n\nsetting 에서 pages를 docs로 변경"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습35-파이썬-버전확인하기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습35-파이썬-버전확인하기",
    "title": "DSTBX2023(3)",
    "section": "실습35: 파이썬 버전확인하기",
    "text": "실습35: 파이썬 버전확인하기\n- 기본명령\npython --version \n- 이걸 이용해서 코랩의 파이썬 버전을 확인해보자."
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습36-가상환경-py310생성-pip으로-판다스-설치하고-버전확인",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습36-가상환경-py310생성-pip으로-판다스-설치하고-버전확인",
    "title": "DSTBX2023(3)",
    "section": "실습36: 가상환경 py310생성 + pip으로 판다스 설치하고 버전확인",
    "text": "실습36: 가상환경 py310생성 + pip으로 판다스 설치하고 버전확인\n- 우리의 무기1: pip list\npip list \nPackage    Version\n---------- -------\npip        23.3.1\nsetuptools 68.2.2\nwheel      0.41.2\n- 우리의 무기2: conda list\nconda list \n# packages in environment at /root/anaconda3/envs/py310:\n#\n# Name                    Version                   Build  Channel\n_libgcc_mutex             0.1                        main  \n_openmp_mutex             5.1                       1_gnu  \nbzip2                     1.0.8                h7b6447c_0  \nca-certificates           2023.12.12           h06a4308_0  \nld_impl_linux-64          2.38                 h1181459_1  \nlibffi                    3.4.4                h6a678d5_0  \nlibgcc-ng                 11.2.0               h1234567_1  \nlibgomp                   11.2.0               h1234567_1  \nlibstdcxx-ng              11.2.0               h1234567_1  \nlibuuid                   1.41.5               h5eee18b_0  \nncurses                   6.4                  h6a678d5_0  \nopenssl                   3.0.12               h7f8727e_0  \npip                       23.3.1          py310h06a4308_0  \npython                    3.10.13              h955ad1f_0  \nreadline                  8.2                  h5eee18b_0  \nsetuptools                68.2.2          py310h06a4308_0  \nsqlite                    3.41.2               h5eee18b_0  \ntk                        8.6.12               h1ccaba5_0  \ntzdata                    2023c                h04d1e81_0  \nwheel                     0.41.2          py310h06a4308_0  \nxz                        5.4.5                h5eee18b_0  \nzlib                      1.2.13               h5eee18b_0  \n- 판다스의 설치\npip install pandas # 터미널에서 하는게 적성입니다. 나머지 야메에요\n- pip list로 확인\nPackage         Version\n--------------- ------------\nnumpy           1.26.3\npandas          2.1.4\npip             23.3.1\npython-dateutil 2.8.2\npytz            2023.3.post1\nsetuptools      68.2.2\nsix             1.16.0\ntzdata          2023.4\nwheel           0.41.2\n- conda list로 확인\n# packages in environment at /root/anaconda3/envs/py310:\n#\n# Name                    Version                   Build  Channel\n_libgcc_mutex             0.1                        main  \n_openmp_mutex             5.1                       1_gnu  \nbzip2                     1.0.8                h7b6447c_0  \nca-certificates           2023.12.12           h06a4308_0  \nld_impl_linux-64          2.38                 h1181459_1  \nlibffi                    3.4.4                h6a678d5_0  \nlibgcc-ng                 11.2.0               h1234567_1  \nlibgomp                   11.2.0               h1234567_1  \nlibstdcxx-ng              11.2.0               h1234567_1  \nlibuuid                   1.41.5               h5eee18b_0  \nncurses                   6.4                  h6a678d5_0  \nnumpy                     1.26.3                   pypi_0    pypi\nopenssl                   3.0.12               h7f8727e_0  \npandas                    2.1.4                    pypi_0    pypi\npip                       23.3.1          py310h06a4308_0  \npython                    3.10.13              h955ad1f_0  \npython-dateutil           2.8.2                    pypi_0    pypi\npytz                      2023.3.post1             pypi_0    pypi\nreadline                  8.2                  h5eee18b_0  \nsetuptools                68.2.2          py310h06a4308_0  \nsix                       1.16.0                   pypi_0    pypi\nsqlite                    3.41.2               h5eee18b_0  \ntk                        8.6.12               h1ccaba5_0  \ntzdata                    2023.4                   pypi_0    pypi\nwheel                     0.41.2          py310h06a4308_0  \nxz                        5.4.5                h5eee18b_0  \nzlib                      1.2.13               h5eee18b_0  \n- 방법3: 파이썬에서\nimport pandas as pd\npd.__version__"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습37-저의-가장-최신-흑역사-재현",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습37-저의-가장-최신-흑역사-재현",
    "title": "DSTBX2023(3)",
    "section": "실습37: 저의 가장 최신 흑역사 재현",
    "text": "실습37: 저의 가장 최신 흑역사 재현\n- 기억하고 싶지 않았음: https://guebin.github.io/DV2023/posts/13wk-2.html\n- py310 환경에서 아래의 코드를 실행한다.\ndf = pd.DataFrame({'A':[2143,2143],'B':['-',3456]})\ndf.map(lambda x: 0 if x == '-' else x)\n- colab 환경의 python과 pandas 버전을 조사하고 유사환경을 만든다.\n# 이렇게 하면됩니당\nconda create -n co python=3.10.12\nconda activate co \npip install pandas==1.5.3\n- 아래의 코드를 실행해보자.\ndf = pd.DataFrame({'A':[2143,2143],'B':['-',3456]})\ndf.map(lambda x: 0 if x == '-' else x)\n- 학생들 질문: 제 컴퓨터에서는 안되는데요.. 어쩌죠?\n\n답변1: 코랩에서 하세요..\n\n- 학생들 질문2: pip install pandas 해도 안되는데요, 어쩌죠?\n\n답변1: 코랩해서 하세요..\n진짜 많이 겪는 상황: 저는 꼭 제 노트북으로 해야겠습니다.. -&gt; 아나콘다 쓰시나요? -&gt; 쓰긴쓰는데…….. -&gt; 환경분리해서 실습했어요? -&gt; ????? -&gt; 제가 볼게요.. (찾아보니까) base에 있음..\n답변2: 일단은 pip install pandas -U 해보세요\n\n- 답변2가 적절할까?\n- 가장 좋아하는 답변: 환경 새로 파세요\n- 최악의 상황\n\n일단 아나콘다는 깔아놓았음.\n잘 몰라서 (base) 상태에서 이것저것 깔기 시작함.\n교수랑 코드 “똑.같.이.” 쳤는데 내 컴퓨터에서는 안됨.\n교수가 맥이라서 그런가보다 하고 인터넷에서 해결책 찾기 시작함.\n뭐 하라는 대로 해서 이제까지 해결해 왔음. (버전은 점점 엉키기 시작함)\n안되는건 잘하는 선배찾아가서 물어봤는데 귀신같이 해결해줌. (하지만 버전은 점점 더 엉키고 있음)\n그런데 또 문제가 생겼고 이제는 해결못하겠음.\n교수한테 찾아감 -&gt; 교수가 해준다면서 (base)에서 새로운 환경 (py310)을 만들어서 이것저것 시도해 봄.\n성공하면 다행인데, 실패함1\n이건 방법이 없다며 아나콘다를 지우고 재설치 시도. 그런데 윈도우에서는 아나콘다 지우는게 까다로움. (먼가 설정이 자꾸 남아있단 말이에요)\n새로 계정만들어서 아나콘다 설치시도 -&gt; 실패\n교수도 사실 윈도우 잘 모른다고 하면서 회피.\n포맷\n다시 아나콘다 깔고 1-13을 반복함.\n\n1 4학년쯤에는 이미 (base) 가 손쓸 수 없는 상태로 깨져있는 경우가 허다함. 공부를 열심히 한 학생일수록 그러함. 이럴경우 소생가능성이 없음- 부작용: 아나콘다 트라우마 발생해서 “리눅스에서 쓰는 모든 명령” 을 (base) 상태에서 실행해야하는지 (py310) 상태에서 실행해야 하는지 알고 싶어하고, 그게 명확하지 않을 경우 두려워함.\n- 부작용을 극복하는 방법: 서버사용하세요. 막 쓰세요. 컴퓨터 망가뜨리면 찾아오세요. 모든 자료는 언제든 클론가능하게 깃헙에 저장하세요."
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습38-여러개의-가상환경-생성",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습38-여러개의-가상환경-생성",
    "title": "DSTBX2023(3)",
    "section": "실습38: 여러개의 가상환경 생성",
    "text": "실습38: 여러개의 가상환경 생성\n- 가능하면 프로젝트별로 환경을 분리하는게 좋다.\n- 하나의 환경에 모든 패키지를 때려밖아 설치하는건 패키지 충돌나라고 기도하는 꼴이다."
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습39-주피터랩-설정변경",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습39-주피터랩-설정변경",
    "title": "DSTBX2023(3)",
    "section": "실습39: 주피터랩 설정변경",
    "text": "실습39: 주피터랩 설정변경\n- root유저의 홈에서 ls, ls -a를 쳐보자.\n- 들어가서 jupyter_notebook_config.py를 열어보자.\n없다면 아래를 이용하여 만들자.\njupyter notebook --generate-config\n- 아래의 내용을 변경\nc.ServerApp.ip = \"0.0.0.0\" \nc.ServerApp.port = 8888 # 8888아니구요. 본인이 쓸수 있는 포트중에서 좋아하는거 쓰세여 \nc.ServerApp.allow_root = True \nc.ServerApp.allow_remote_access = True # 당장필요한건 아닌데요.. 해놓으세여 \nc.ServerApp.allow_remote_access 이 설정은 Jupyter Notebook 애플리케이션에서 원격 액세스를 허용하도록 하는 것\nroot일때\n- 이제 켜보세요.."
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습40-주피터랩-평생-켜놓기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습40-주피터랩-평생-켜놓기",
    "title": "DSTBX2023(3)",
    "section": "실습40: 주피터랩 평생 켜놓기",
    "text": "실습40: 주피터랩 평생 켜놓기\n- 아래와 같이 하면 됩니다.\nnohup jupyter lab --ip=\"0.0.0.0\" --port={MY-PORT} --allow-root &gt; /dev/null 2&gt;&1 &"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습41-rpython-사용가능한-개발환경-만들기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습41-rpython-사용가능한-개발환경-만들기",
    "title": "DSTBX2023(3)",
    "section": "실습41: R+Python 사용가능한 개발환경 만들기",
    "text": "실습41: R+Python 사용가능한 개발환경 만들기\n- 아래를 실행\nconda create -n rpy \nconda activate rpy\nconda install -c conda-forge r-essentials\nconda install -c conda-forge plotly\nconda install -c conda-forge rpy2\n- 여기에서 conda install -c conda-forge r-essentials로 인하여 R, Python, Jupyter 가 모두 최신버전으로 설치된다.\n- 또한 R에는 이미 tidyverse, IRkernel 등의 패키지가 기본으로 깔려있다.\n- R이 설치된 경로를 찾아보자.\n- 수틀리면 이 R을 지우면 된다.\n- R이 설치될 수 있는 3가지 시나리오\nsudo apt-get install r-base # r 공식홈페이지, 수틀리면 리눅스 포맷  \n(base) conda install -c conda-forge ... # 수틀리면 아나콘다 삭제해야함. \n(rpy) conda install -c conda-forge ... # 수틀리면 가상환경 삭제"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습42-여러가지-프로그램-여러가지-설치방법",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습42-여러가지-프로그램-여러가지-설치방법",
    "title": "DSTBX2023(3)",
    "section": "실습42: 여러가지 프로그램, 여러가지 설치방법",
    "text": "실습42: 여러가지 프로그램, 여러가지 설치방법\n- 우분투자체의 프로그램\n\n우분투 자체의 프로그램 예시: git, quarto, python, R, anaconda, vi, ssh, wget, vscode\n우분투 자체의 프로그램은 다시 모든 유저가 영향을 받는 받는 프로그램과 그렇지 않은 프로그램이 있음\n우분투 자체의 프로그램을 설치하는 방법들\n\nsudo apt install git \nsudo apt-get install git \nsudo dpkg -i quarto-1.4.533-linux-amd64.deb \nbash Anaconda3-2019.03-Linux-x86_64.sh\nsudo gdebi rstudio-server-1.2.5033-amd64.deb\n# 기타 파일을 넣을 수 있는 모든 방법 (예를들면 압축파일 다운로드후 풀기) \n- 아나콘다(=base)에 종속된 프로그램\n\n아나콘다내에 종속된 프로그램의 예시: conda, python, R, jupyter\n아나콘다에 종속된 프로그램은 anaconda3 폴더안에 있음.\n\n- 아나콘다환경에 종속시킬 수 “있는” 프로그램\n\n아나콘다내에 종속된 프로그램의 예시: python, R, jupyter\n아나콘다환경에 종속된 프로그램은 anaconda3/envs/py310 와 같은 형식의 폴더안에 있음.\n\n- 파이썬에 종속된 프로그램 (=파이썬패키지=파이썬라이브러리=파이썬모듈)\n\n파이썬에 종속된 프로그램 예시: numpy, pandas\n얘네들이 어디에 깔리는지는 그때그때 다름\n지우는 방법도 그때그때 다르겠지? (젤 편하고 깔끔하게 지우려면?)\n\n- R에 종속된 프로그램 (=R패키지=R라이브러리)\n\nR에 종속된 프로그램의 예시: tidyverse\n얘들이 어디 깔리는지도 그때그때 다름\n지우는 방법도 그때그때 다르겠지? (젤 편하고 깔끔하게 지우려면?)\n\n- 질문1: pip install vs conda install\n\n설치되는 레벨의 차이\n설치에서 느껴지는 편안함의 차이\n삭제할때 느껴지는 불편함의 차이\npip install pandas는 사실 install.packages(\"tidyverse\")에 대응되는 것임\n\n- 질문2: 언제 pip install을 쓰고 언제 conda install을 써야할까? 답은없어요. 저는 대충 아래와 같이 합니다. (해보고 수틀리면 그냥 환경날리세여)\n\n만만한 패키지는 pip install 로 설치: numpy, pandas\n까다로운 패키지는 conda install 로 설치: torch, autogluon"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습43-base에서-rpy에-있는-r-실행",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습43-base에서-rpy에-있는-r-실행",
    "title": "DSTBX2023(3)",
    "section": "실습43: (base)에서 (rpy)에 있는 R 실행",
    "text": "실습43: (base)에서 (rpy)에 있는 R 실행\n- 원래는 불가능한 일이겠죠?\n- 억지로 가능하게 하려면?"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습44-rpy에서-ept라는-r패키지-설치하고-위치파악하기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습44-rpy에서-ept라는-r패키지-설치하고-위치파악하기",
    "title": "DSTBX2023(3)",
    "section": "실습44: (rpy)에서 EPT라는 R패키지 설치하고 위치파악하기",
    "text": "실습44: (rpy)에서 EPT라는 R패키지 설치하고 위치파악하기\n- R을 실행\nconda activate rpy\nR\n- 또다른 터미널을 열고 아래의 폴더로 이동 + 패키지확인\ncd ~/anaconda3/envs/rpy/lib/R/library\nls\n- EPT패키지 설치\ninstall.packages(\"EPT\")\n- ~/anaconda3/envs/rpy/lib/R/library에서 확인"
  },
  {
    "objectID": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습45-rpy에-설치된-r과-주피터-연결하기",
    "href": "posts/1_Note/2024-01-04-DSTBX2023(3).html#실습45-rpy에-설치된-r과-주피터-연결하기",
    "title": "DSTBX2023(3)",
    "section": "실습45: (rpy)에 설치된 R과 주피터 연결하기",
    "text": "실습45: (rpy)에 설치된 R과 주피터 연결하기\n- R을 실행\nIRkernel::installspec()\n- 주피터 실행"
  },
  {
    "objectID": "posts/1_Note/2022-04-03-(5주차) 4월2일.html",
    "href": "posts/1_Note/2022-04-03-(5주차) 4월2일.html",
    "title": "Introduction to Python 5wk",
    "section": "",
    "text": "소스코드 관리, 모듈, 패키지, 라이브러리\n\nhttps://guebin.github.io/IP2022/2022/04/03/(5%EC%A3%BC%EC%B0%A8)-4%EC%9B%942%EC%9D%BC.html\n\n강의영상\n\nyoutube: https://youtube.com/playlist?list=PLQqh36zP38-yzovneTfJptA4K705FOG1f\n\n- (1/7) intro\n- (2/7) import 사용방법, 도움말 작성기능\n- (3/7) import 사용시 주의점\n- (4/7) import 고급\n- (5/7) site-packages 1\n- (6/7) site-packages 2\n- (7/7) 모듈, 패키지, 라이브러리, 숙제설명\n\n\nintro\n- 현재 파이썬은 길이가 2인 벡터의 덧셈을 지원하지 않음\n\na=[1,2]\nb=[3,4]\na+b\n\n[1, 2, 3, 4]\n\n\n- 아래와 같은 기능을 구현하는 함수를 만들고 싶음\n[1,2], [3,4] -&gt; [4,6]\n- 구현\n\ndef vec2_add(a,b): \n    return [a[0]+b[0], a[1]+b[1]]\n\n- test\n\na=[1,2]\nb=[3,4]\n\n\nvec2_add(a,b)\n\n[4, 6]\n\n\n\n\nmake myfuns.py\n- 생각해보니까 vec2_add는 내가 앞으로 자주 쓸 기능임\n- 그런데 현재 사용방법으로는 내가 노트북파일을 새로 만들떄마다 def vec2_add(a,b): 와 같은 형태로 vec2_add를 매번 정의해줘야 하는 불편한이 있다.\n\n해결1\n- 자주 사용하는 함수를 myfuns.py에 저장한다.\n# myfuns.py\ndef vec2_add(a,b): \n    return [a[0]+b[0], a[1]+b[1]]\n- %run myfuns를 실행\n준비: “00” -&gt; 커널재시작\n\n%run myfuns \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\n\n해결2\n- 자주 사용하는 함수를 myfuns.py에 저장한다.\n# myfuns.py\ndef vec2_add(a,b): \n    return [a[0]+b[0], a[1]+b[1]]\n- import myfuns를 이용\n(준비) “00” -&gt; 커널재시작\n\nimport myfuns \n\n\na=[1,2]\nb=[3,4]\nmyfuns.vec2_add(a,b)\n\n[4, 6]\n\n\n\n\n\nimport 기본\n\n사용방법\n- 사용방법1\n준비: “00” -&gt; 커널재시작\n\nimport myfuns \n\n\nmyfuns.vec2_add([1,2],[3,4]) \n\n[4, 6]\n\n\n\nmyfuns.vec2_add 의 의미: myfuns.py 라는 파일안에 vec2_add라는 함수가 있음. 그것을 실행하라.\n.의 의미: 상위.하위의 개념!\n\n(주의) 아래와 같이 사용불가능 하다.\n\nvec2_add([1,2],[3,4])\n\nNameError: name 'vec2_add' is not defined\n\n\n- 사용방법2\n준비: “00” -&gt; 커널재시작\n\nfrom myfuns import vec2_add \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n(주의) 이 경우는 오히려 아래가 불가능함\n\nmyfuns.vec2_add([1,2],[3,4]) # myfuns안의 vec2_add만 임포트했지 myfuns자체를 임포트 한것은 아님 \n\nNameError: name 'myfuns' is not defined\n\n\n- 사용방법3\n준비: “00” -&gt; 커널재시작\n\nimport myfuns\nfrom myfuns import vec2_add\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n- 사용방법4\n준비: “00” -&gt; 커널재시작\n\nfrom myfuns import vec2_add, vec2_sub \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n- 사용방법5\n준비: “00” -&gt; 커널재시작\n\nfrom myfuns import * #*는 all의 의미 \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n- 사용방법6\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nmf.vec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n(오히려 아래는 실행불가능)\n\nmyfuns.vec2_add([1,2],[3,4])\n\nNameError: name 'myfuns' is not defined\n\n\n\nmyfuns.vec2_sub([1,2],[3,4])\n\nNameError: name 'myfuns' is not defined\n\n\n- 잘못된 사용방법1\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \nfrom mf import vec2_add \n\nModuleNotFoundError: No module named 'mf'\n\n\n- 사용방법7\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \nfrom myfuns import vec2_add \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n- 사용방법8\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \nfrom myfuns import vec2_add as add \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\nNameError: name 'vec2_add' is not defined\n\n\n\nadd([1,2],[3,4])\n\n[4, 6]\n\n\n\n\n도움말 작성기능\n- mf란 무엇인가?\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \n\n\nmf\n\n&lt;module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'&gt;\n\n\n\nmf?\n\n\nType:        module\nString form: &lt;module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'&gt;\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py\nDocstring:   &lt;no docstring&gt;\n\n\n\n\n\ntype(mf)\n\nmodule\n\n\n\nmf의 타입은 모듈이라고 나옴, 현재 단계에서는 무엇인지 알기 어려움\n\n- Docstring의 내용을 채울 수 있을까?\n준비1: myfuns.py 파일을 아래와 같이 수정한다.\n준비2: “00” -&gt; 커널재시작\n\nimport myfuns as mf \n\n\nmf?\n\n\nType:        module\nString form: &lt;module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'&gt;\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py\nDocstring:   이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.\n\n\n\n\n\n\n주의점\n- myfuns.py는 최초 한번만 import 된다.\n준비: “00” -&gt; 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\nmyfuns.py파일을 열고 함수를 아래와 같이 바꾸자.\n\"\"\"이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.\"\"\" \ndef vec2_add(a,b): \n    print(\"이것은 myfuns.py에 정의된 함수입니다\") \n    return [a[0]+b[0], a[1]+b[1]]\ndef vec2_sub(a,b): \n    return [a[0]-b[0], a[1]-b[1]]\n다시 myfuns를 로드하고 myfuns.vec2_add 를 실행하여 보자.\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n바뀐내용이 적용되지 않는다.\n커널을 다시 시작하고 임포트해보자.\n“00” -&gt; 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n이것은 myfuns.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n- myfuns.py는 주피터노트북파일과 같은 폴더에 존재해야 한다.\n준비1: “00” -&gt; 커널재시작\n준비2: myfuns.py을 복사하여 다른 폴더로 이동. 예를들면 IP0403 폴더를 만들고 그 폴더안에 myfuns.py파일을 복사해서 붙여넣은뒤에 파일이름을 myfuns2.py 로 변경.\n\nimport myfuns # 주피터노트북파일과 같은 폴더에 있는 myfuns는 잘 로드되지만 \n\n\nimport myfuns2 # 주피터노트북파일과 다른 폴더에 있는 myfuns2는 그렇지 않다. \n\nModuleNotFoundError: No module named 'myfuns2'\n\n\n- IP0403 폴더에 있는 myfuns2.py를 실행하기 위해서는 아래와 같이 할 수 있다.\n준비: “00” -&gt; 커널재시작\n\nfrom IP0403 import myfuns2\n\n\nmyfuns2.vec2_add([1,2],[3,4]) \n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n- 아래도 가능하다.\n준비: “00” -&gt; 커널재시작\n\nfrom IP0403.myfuns2 import vec2_add as add \n\n\nadd([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n참고로 아래는 모두 정의되지 않음\n\nIP0403.myfuns2.vec2_add([1,2],[3,4]) \n\nNameError: name 'IP0403' is not defined\n\n\n\nmyfuns2.vec2_add([1,2],[3,4]) \n\nNameError: name 'myfuns2' is not defined\n\n\n\nvec2_add([1,2],[3,4]) \n\nNameError: name 'vec2_add' is not defined\n\n\n\n\n\nimport 고급\n\n폴더와 함께 사용할시\n- 언뜻 생각하면 아래가 가능할 것 같다.\nimport IP0403 \nIP0403.myfuns2.vec2_add([1,2],[3,4]) \n- 하지만 불가능하다.\n준비: “00” -&gt; 커널재시작\n\nimport IP0403 \n\n\n되는거아냐?\n\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])\n\nAttributeError: module 'IP0403' has no attribute 'myfuns2'\n\n\n\n여기서 불가능하다.\n\n- (암기) IP0403 폴더안에 __init__.py라는 파일을 만들고 내용에 아래와 같이 쓰면 가능하다.\n# ./IP0403/__init__.py \nfrom . import myfuns2\n준비1: 위의 지침을 따른다.\n준비2: “00” -&gt; 커널재시작\n\nimport IP0403 \n\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n컴퓨터 상식 - .: 현재폴더를 의미 - ..: 상위폴더를 의미 - ./myfuns.py: 현재폴더안에 있는 myfuns.py를 의미 - ./IP0403/myfuns2.py: 현재폴더만에 IP0403폴더안의 myfuns2.py 파일을 의미 - ../myfuns.py: 현재폴더보다 한단계상위폴더에 있는 myfuns.py를 의미 - cd ./IP0403: 현재폴더안에 있는 IP0403폴더로 이동해라. (cd IP0403으로 줄여쓸 수 있음) - cd .. 현재폴더보다 한단계 상위폴더로 이동하라.\n따라서 from . import myfuns2는 현재폴더에서 myfuns2를 찾아서 임포트 하라는 의미로 해석가능\n- 의미상으로 보면 아래가 실행가능할듯 한데 불가능하다.\n\n#import myfuns\nfrom . import myfuns\n\nImportError: attempted relative import with no known parent package\n\n\n\n\n\nsite-packages (실습금지)\n- 의문: 왜 현재폴더에 numpy.py라든가 numpy라는 이름의 폴더가 없는데도 import 가능한지?\n준비: “00” -&gt; 커널재시작\n\nimport numpy as np\n\n\nimport IP0403 as ip \n\n\nip?\n\n\nType:        module\nString form: &lt;module 'IP0403' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py'&gt;\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py\nDocstring:   &lt;no docstring&gt;\n\n\n\n\n\nnp?\n\n\nType:        module\nString form: &lt;module 'numpy' from '/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py'&gt;\nFile:        ~/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py\nDocstring:  \nNumPy\n=====\nProvides\n  1. An array object of arbitrary homogeneous items\n  2. Fast mathematical operations over arrays\n  3. Linear Algebra, Fourier Transforms, Random Number Generation\nHow to use the documentation\n----------------------------\nDocumentation is available in two forms: docstrings provided\nwith the code, and a loose standing reference guide, available from\n`the NumPy homepage &lt;https://www.scipy.org&gt;`_.\nWe recommend exploring the docstrings using\n`IPython &lt;https://ipython.org&gt;`_, an advanced Python shell with\nTAB-completion and introspection capabilities.  See below for further\ninstructions.\nThe docstring examples assume that `numpy` has been imported as `np`::\n  &gt;&gt;&gt; import numpy as np\nCode snippets are indicated by three greater-than signs::\n  &gt;&gt;&gt; x = 42\n  &gt;&gt;&gt; x = x + 1\nUse the built-in ``help`` function to view a function's docstring::\n  &gt;&gt;&gt; help(np.sort)\n  ... # doctest: +SKIP\nFor some objects, ``np.info(obj)`` may provide additional help.  This is\nparticularly true if you see the line \"Help on ufunc object:\" at the top\nof the help() page.  Ufuncs are implemented in C, not Python, for speed.\nThe native Python help() does not know how to view their help, but our\nnp.info() function does.\nTo search for documents containing a keyword, do::\n  &gt;&gt;&gt; np.lookfor('keyword')\n  ... # doctest: +SKIP\nGeneral-purpose documents like a glossary and help on the basic concepts\nof numpy are available under the ``doc`` sub-module::\n  &gt;&gt;&gt; from numpy import doc\n  &gt;&gt;&gt; help(doc)\n  ... # doctest: +SKIP\nAvailable subpackages\n---------------------\ndoc\n    Topical documentation on broadcasting, indexing, etc.\nlib\n    Basic functions used by several sub-packages.\nrandom\n    Core Random Tools\nlinalg\n    Core Linear Algebra Tools\nfft\n    Core FFT routines\npolynomial\n    Polynomial tools\ntesting\n    NumPy testing tools\nf2py\n    Fortran to Python Interface Generator.\ndistutils\n    Enhancements to distutils with support for\n    Fortran compilers support and more.\nUtilities\n---------\ntest\n    Run numpy unittests\nshow_config\n    Show numpy build configuration\ndual\n    Overwrite certain functions with high-performance SciPy tools.\n    Note: `numpy.dual` is deprecated.  Use the functions from NumPy or Scipy\n    directly instead of importing them from `numpy.dual`.\nmatlib\n    Make everything matrices.\n__version__\n    NumPy version string\nViewing documentation using IPython\n-----------------------------------\nStart IPython with the NumPy profile (``ipython -p numpy``), which will\nimport `numpy` under the alias `np`.  Then, use the ``cpaste`` command to\npaste examples into the shell.  To see which functions are available in\n`numpy`, type ``np.&lt;TAB&gt;`` (where ``&lt;TAB&gt;`` refers to the TAB key), or use\n``np.*cos*?&lt;ENTER&gt;`` (where ``&lt;ENTER&gt;`` refers to the ENTER key) to narrow\ndown the list.  To view the docstring for a function, use\n``np.cos?&lt;ENTER&gt;`` (to view the docstring) and ``np.cos??&lt;ENTER&gt;`` (to view\nthe source code).\nCopies vs. in-place operation\n-----------------------------\nMost of the functions in `numpy` return a copy of the array argument\n(e.g., `np.sort`).  In-place versions of these functions are often\navailable as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.\nExceptions to this rule are documented.\n\n\n\n\n- 추측: ~/anaconda3/envs/py310/lib/python3.10/site-packages/를 찾아가보자. 그곳에 numpy폴더가 있을 것이다.\n\n!ls ~/anaconda3/envs/py310/lib/python3.10/site-packages | grep numpy\n\nnumpy\nnumpy-1.22.2.dist-info\n\n\n- 추측2: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에 내가 자주 쓰는 기능을 폴더로 만들어서 모아두면 어디서든지 import 할 수 있다.\n\n!mkdir ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin # guebin 폴더 생성 \n\n\n!cp ./myfuns.py ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin \n# 현폴더에 있는 myfuns.py를 아까만든 guebin 폴더로 복사 \n\n\nfrom guebin import myfuns\n\n\nmyfuns?\n\n\nType:        module\nString form: &lt;module 'guebin.myfuns' from '/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py'&gt;\nFile:        ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py\nDocstring:   이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.\n\n\n\n\n\n!rm  ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin -rf # guebin 폴더삭제 \n\n- 추측3: guebin이 사라진 상태에서는 from guebin import myfuns 이 동작하지 않을 것이다.\n준비: “00” -&gt; 커널재시작\n\nfrom guebin import myfuns\n\nModuleNotFoundError: No module named 'guebin'\n\n\n- 추측4: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에서 numpy를 지운다면 numpy를 import할 수 없다.\n준비: “00” -&gt; 커널재시작\n\nimport numpy as np\n\nModuleNotFoundError: No module named 'numpy'\n\n\n- 추측5: !pip install numpy를 하면 다시 폴더가 생길 것이다.\n\n!pip uninstall numpy -y \n\nFound existing installation: numpy 1.22.2\nUninstalling numpy-1.22.2:\n  Successfully uninstalled numpy-1.22.2\n\n\n\n!pip install numpy \n\nCollecting numpy\n  Downloading numpy-1.22.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (16.8 MB)\n     |████████████████████████████████| 16.8 MB 11.4 MB/s eta 0:00:01\nInstalling collected packages: numpy\nSuccessfully installed numpy-1.22.3\n\n\n\n\n모듈, 패키지, 라이브러리?\n- 모듈의 개념은 아까 살펴본것과 같다. (import를 하여 생기게 되는 오브젝트)\n- 교수님들: 모듈이 모이면 패키지라고 부른다. 그리고 라이브러리는 패키지보다 큰 개념이다.\n- 그런데 구분이 모호하다.\n\nimport numpy as np\n\n\ntype(np)\n\nmodule\n\n\n- python에서의 numpy의 type은 모듈\n- 그런데 numpy package 라고 검색하면 검색이 된다.\n- 심지어 numpy library 라고 해도 검색가능\n- 내생각: 넘파이모듈, 넘파이패키지, 넘파이라이브러리 다 맞는 말임\n\n\n숙제\nmyfuns.py 도움말 만드는 예제에서\n이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다\n대신에\n이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다. (학번: 2022-43052) \n와 같이 출력되도록 하고 스크린샷 제출"
  },
  {
    "objectID": "posts/1_Note/2024-01-10-DSTBX2023(5).html",
    "href": "posts/1_Note/2024-01-10-DSTBX2023(5).html",
    "title": "Day5: 실습64 - 실습??",
    "section": "",
    "text": "ref: https://rocker-project.org/\n- 다커실행파일 다운로드\n\nhttps://docs.docker.com/desktop/install/windows-install/\n\n- docker 이미지 다운로드\n방법1\ndocker pull rocker/rstudio\n방법2\n\n사실 잘 몰라요 ㅎㅎ\n\n- 다운받은 이미지 확인하기\n방법1\ndocker images\n방법2\n\nGUI\n\n- 이미지에서 컨테이너생성 (컨테이너는 인스턴스라고 생각하자..)\n방법1\ndocker run -ti -e PASSWORD=\"jbnu\" -p 8787:8787 rocker/rstudio\n방법2\n\nGUI\n\n\n\n\n\n\n\nNote\n\n\n\nrocker/rstudio\n이게 이미지\n비밀번호는 큰 따옴표로 하거나 아예 안 쓰기\n\n\n\n\n\n\n\n\nTip\n\n\n\n이미지는 python의 class\n컨테이너는 python의 함수\n\n\n\n\n\n\n\n\nTip\n\n\n\ndocker run: Docker 컨테이너를 실행하는 명령어.\n-ti: 터미널 상호작용을 가능하게 하는 옵션으로, 이 옵션을 사용하면 컨테이너가 실행되면서 사용자와 상호작용할 수 있습니다.\n-e PASSWORD=“jbnu”: 컨테이너 내부에서 사용할 RStudio Server의 비밀번호를 설정하는 옵션입니다. 이 예제에서는 “jbnu”로 비밀번호를 설정했습니다.\n-p 8787:8787: 호스트 머신의 8787 포트를 컨테이너의 8787 포트와 연결하는 옵션입니다. RStudio Server는 기본적으로 8787 포트에서 실행됩니다.\nrocker/rstudio: Docker 이미지의 이름입니다. rocker는 R언어 및 RStudio를 설치하고 설정한 이미지입니다.\n\n\n\n\n\n\n\n\nTip\n\n\n\ndocker ps -a\n실행했던 ( 과거의 히스토리까지) 모든 결과 보여줌\ndocker ps\n현재 실행하는 컨테이너 보여줌\ndocker images\n현재 있는 이미지 보여줌\n\n\n\n\n\n\n\n\nTip\n\n\n\n이미지의 컨테이너에 들어가서 r 작업하면\n컨테이너 꺼도 다시 시작하면 히스토리가 남아있음\n–&gt; 이 말은 컨테이너 끄고 컨테이너 삭제해야 이미지도 삭제할 수 있다는 뜻\n\n\n\n\n\n\n\n\nNote\n\n\n\n어떻게 돌아가느냐 - 컨테이너에 패키지 다 설치해서 그걸 share 해 그 share 한 공간에서 추가 패키지 설치하든 알아서 사용 가능\n\n\n- Rstudio 사용"
  },
  {
    "objectID": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습64-docker로-rstudio-실행하기실습실-컴퓨터",
    "href": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습64-docker로-rstudio-실행하기실습실-컴퓨터",
    "title": "Day5: 실습64 - 실습??",
    "section": "",
    "text": "ref: https://rocker-project.org/\n- 다커실행파일 다운로드\n\nhttps://docs.docker.com/desktop/install/windows-install/\n\n- docker 이미지 다운로드\n방법1\ndocker pull rocker/rstudio\n방법2\n\n사실 잘 몰라요 ㅎㅎ\n\n- 다운받은 이미지 확인하기\n방법1\ndocker images\n방법2\n\nGUI\n\n- 이미지에서 컨테이너생성 (컨테이너는 인스턴스라고 생각하자..)\n방법1\ndocker run -ti -e PASSWORD=\"jbnu\" -p 8787:8787 rocker/rstudio\n방법2\n\nGUI\n\n\n\n\n\n\n\nNote\n\n\n\nrocker/rstudio\n이게 이미지\n비밀번호는 큰 따옴표로 하거나 아예 안 쓰기\n\n\n\n\n\n\n\n\nTip\n\n\n\n이미지는 python의 class\n컨테이너는 python의 함수\n\n\n\n\n\n\n\n\nTip\n\n\n\ndocker run: Docker 컨테이너를 실행하는 명령어.\n-ti: 터미널 상호작용을 가능하게 하는 옵션으로, 이 옵션을 사용하면 컨테이너가 실행되면서 사용자와 상호작용할 수 있습니다.\n-e PASSWORD=“jbnu”: 컨테이너 내부에서 사용할 RStudio Server의 비밀번호를 설정하는 옵션입니다. 이 예제에서는 “jbnu”로 비밀번호를 설정했습니다.\n-p 8787:8787: 호스트 머신의 8787 포트를 컨테이너의 8787 포트와 연결하는 옵션입니다. RStudio Server는 기본적으로 8787 포트에서 실행됩니다.\nrocker/rstudio: Docker 이미지의 이름입니다. rocker는 R언어 및 RStudio를 설치하고 설정한 이미지입니다.\n\n\n\n\n\n\n\n\nTip\n\n\n\ndocker ps -a\n실행했던 ( 과거의 히스토리까지) 모든 결과 보여줌\ndocker ps\n현재 실행하는 컨테이너 보여줌\ndocker images\n현재 있는 이미지 보여줌\n\n\n\n\n\n\n\n\nTip\n\n\n\n이미지의 컨테이너에 들어가서 r 작업하면\n컨테이너 꺼도 다시 시작하면 히스토리가 남아있음\n–&gt; 이 말은 컨테이너 끄고 컨테이너 삭제해야 이미지도 삭제할 수 있다는 뜻\n\n\n\n\n\n\n\n\nNote\n\n\n\n어떻게 돌아가느냐 - 컨테이너에 패키지 다 설치해서 그걸 share 해 그 share 한 공간에서 추가 패키지 설치하든 알아서 사용 가능\n\n\n- Rstudio 사용"
  },
  {
    "objectID": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습65-docker로-ubuntu-실행하기실습실-컴퓨터",
    "href": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습65-docker로-ubuntu-실행하기실습실-컴퓨터",
    "title": "Day5: 실습64 - 실습??",
    "section": "실습65: docker로 ubuntu 실행하기(실습실 컴퓨터)",
    "text": "실습65: docker로 ubuntu 실행하기(실습실 컴퓨터)\n- 우분투 이미지 다운로드\ndocker pull ubuntu\n- 실행\ndocker run -ti -d -t ubuntu /bin/bash\ndocker exec -ti {넣고 싶은 name 쓰기} bash"
  },
  {
    "objectID": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습65-docker로-ubuntu-실행하기-183컴퓨터",
    "href": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습65-docker로-ubuntu-실행하기-183컴퓨터",
    "title": "Day5: 실습64 - 실습??",
    "section": "실습65: docker로 ubuntu 실행하기 (183컴퓨터)",
    "text": "실습65: docker로 ubuntu 실행하기 (183컴퓨터)\n- 우분투안에서 우분투 실행\ndocker run -ti -d -t -p ?????:????? --name guebin ubuntu /bin/bash\ndocker exec -ti guebin bash \n- 아래를 수행\npasswd root\napt update \napt install gcc\napt install build-essential\napt install vim"
  },
  {
    "objectID": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습66-코드스페이스-사용하기",
    "href": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습66-코드스페이스-사용하기",
    "title": "Day5: 실습64 - 실습??",
    "section": "실습66: 코드스페이스 사용하기",
    "text": "실습66: 코드스페이스 사용하기\n- 아래를 이용하여 코드스페이스 설치\napt-get install curl\ncurl -Lk 'https://code.visualstudio.com/sha/download?build=stable&os=cli-alpine-x64' --output vscode_cli.tar.gz\ntar -xf vscode_cli.tar.gz\n- 아래를 이용하여 초기설정\n./code tunnel \n\n컴퓨터 이름 잘 써야해요…\n외워야 하는 이름이에요..\n\n\n\n\n\n\n\nNote\n\n\n\n두 개 선택하라고 나오는데 여기서 Github Account 선택하고 터미널에서 나온 코드 입력\n\n\n- 코드스페이스 평생켜놓기\nnohup ./code tunnel &gt; /dev/null 2&gt;&1 &\n- 코드스페이스의 장점\n\n별도의 포트를 먹지 않는다.\n하나의 창에서 모든 가상환경을 동시에 이용할 수 있다. &lt;– 제가 이거때문에 씁니당..\n보안접속이 가능하다."
  },
  {
    "objectID": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습67-rstudio-사용하기",
    "href": "posts/1_Note/2024-01-10-DSTBX2023(5).html#실습67-rstudio-사용하기",
    "title": "Day5: 실습64 - 실습??",
    "section": "실습67: Rstudio 사용하기",
    "text": "실습67: Rstudio 사용하기\n- 아래를 이용하여 Rstudio를 설치 (base환경인지 r환경인지는 무의미)\nsudo apt-get install gdebi-core\nwget https://download2.rstudio.org/server/jammy/amd64/rstudio-server-2022.12.0-353-amd64.deb\nsudo gdebi rstudio-server-2022.12.0-353-amd64.deb\n- grst가 만든 rstudio-server-conda를 클론\ngit clone https://github.com/grst/rstudio-server-conda.git\n\n\n\n\n\n\nNote\n\n\n\nlocal 파일 들어가서\nstart_rstudio_server.sh 를 vi로 보기\n--www-port=$1 \\\n를\n--www-port=8888\n원하는 주소로 설정\n그 밑에\n--auth-minimum-user-id=0\n추가\n\n\n- 내용을 수정\n{.bash filename= \"~/rstudio-server-conda/local/start_rstudio_server.sh\"} ... blalba ... /usr/lib/rstudio-server/bin/rserver --server-daemonize=0 \\   --www-port=????? \\ ### &lt;--- 여기 수정!!!!!   --auth-minimum-user-id=0 \\ ### &lt;--- 여기 추가!!!!!   --secure-cookie-key-file=$COOKIE_KEY_PATH \\   --server-pid-file=\"$CWD/rstudio-server.pid\" \\   --server-data-dir=\"$CWD/rstudio-server\" \\   --rsession-which-r=$(which R) \\   --rsession-ld-library-path=$CONDA_PREFIX/lib \\   --rsession-path=\"$CWD/rsession.sh\" \\   --server-user $USER \\   --database-config-file \"$CWD/database.conf\" \\   $REVOCATION_LIST_PAR\n- start_rstudio_server.sh를 실행"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html",
    "title": "DSTBX2023(2)",
    "section": "",
    "text": "git switch gh-pages\ngit add .\ngit commit -m .\ngit switch main\ngit add .\ngit commit -m .\ngit push\n!ls\n리눅스 명령어 주피터 노트북에서 쓰기\n!ls ..\n상위 목록 보기\n!ls .. &gt; ttt.txt\n상위 폴더에 있는 파일 이름들 txt파일로 만들기\n!cat ttt.txt\n파일 확인 하는 방법\n!chmod +x ddd.sh\n\n\n\n\n\n\nNote\n\n\n\n리눅스에서 cat 명령어는 concatenate(연결)의 약자로, 파일의 내용을 화면에 출력하거나 파일을 합쳐주는 데 사용됩니다. 주로 텍스트 파일의 내용을 확인하거나 여러 파일을 하나로 합칠 때 사용됩니다.\n\n\nfnames=(\n    \"sss.txt\"\n)\nfor fname in \"${fnames[@]}\"; do\n    echo \"File: $fname\"\n    cat \"../1dayhw/$fname\"\n    echo \"----------------\"\ndone"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습13-숙제검사",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습13-숙제검사",
    "title": "DSTBX2023(2)",
    "section": "실습13: 숙제검사",
    "text": "실습13: 숙제검사\n- 이거 클론하세요\n- 방법1\n\n!ls ../1dayhw \n\nbaek_gm.txt   guebin.txt     jinsil.txt   seongjoon.txt\nchoyun.txt    handoehee.txt  junhan.txt   seunghoon.txt\ncoco.txt      hyeonji.txt    leejjae.txt  soonwon.txt\ndaehyeon.txt  jeongmin.txt   mingu.txt    suwhan.txt\n\n\n\n!cat ../1dayhw/choyun.txt\n\n- 방법2\n\n!ls ../1dayhw &gt; fnames.txt\n\n\n!chmod +x show.sh\n\n\n#!./show.sh\n\nsh 확장자는 bash로 하자\n- 방법3: 아래의 파일을 생성하고 출력\n\n\nshow2.sh\n\nfnames=(\n    \"baek_gm.txt\" \"guebin.txt\" \"jinsil.txt\" \"seongjoon.txt\"\n    \"choyun.txt\" \"handoehee.txt\" \"junhan.txt\" \"seunghoon.txt\"\n    \"coco.txt\" \"hyeonji.txt\" \"leejjae.txt\" \"soonwon.txt\"\n    \"daehyeon.txt\" \"jeongmin.txt\" \"mingu.txt\" \"suwhan.txt\"\n)\nfor fname in \"${fnames[@]}\"; do\n    echo \"File: $fname\"\n    cat \"../1dayhw/$fname\"\n    echo \"----------------\"\ndone\n\n\n#!bash show2.sh\n\n- ./show2.sh 와 bash show2.sh 의 차이?\n\n스크립트의 권한, 셸 지정\n잘 모르겠어요\n\n\n\n\n\n\n\nNote\n\n\n\n!bash show.sh 명령어는 show.sh 스크립트를 Bash 셸에서 실행하는 명령어입니다. 이 명령어는 일반적으로 사용자가 현재 셸에서 직접 스크립트를 실행하고자 할 때 사용됩니다.\n\n\n\n저 숙제를 바탕으로 183 컴퓨터에 계정을 생성했습니다.\n그냥 참고용.. 이렇게도 가능함 ㅎㅎ\n\nfile_names = [\n    \"baek_gm\", \"guebin\", \"jinsil\", \"seongjoon\",\n    \"choyun\", \"handoehee\", \"junhan\", \"seunghoon\",\n    \"coco\", \"hyeonji\", \"leejjae\", \"soonwon\",\n    \"daehyeon\", \"jeongmin\", \"mingu\", \"suwhan\"\n]\n\n\nfor username in file_names:\n    print(f'adduser {username} --gecos \"\" --disabled-password && echo \"{username}:jbnu\" | chpasswd && usermod -aG sudo {username}')\n\nadduser baek_gm --gecos \"\" --disabled-password && echo \"baek_gm:jbnu\" | chpasswd && usermod -aG sudo baek_gm\nadduser guebin --gecos \"\" --disabled-password && echo \"guebin:jbnu\" | chpasswd && usermod -aG sudo guebin\nadduser jinsil --gecos \"\" --disabled-password && echo \"jinsil:jbnu\" | chpasswd && usermod -aG sudo jinsil\nadduser seongjoon --gecos \"\" --disabled-password && echo \"seongjoon:jbnu\" | chpasswd && usermod -aG sudo seongjoon\nadduser choyun --gecos \"\" --disabled-password && echo \"choyun:jbnu\" | chpasswd && usermod -aG sudo choyun\nadduser handoehee --gecos \"\" --disabled-password && echo \"handoehee:jbnu\" | chpasswd && usermod -aG sudo handoehee\nadduser junhan --gecos \"\" --disabled-password && echo \"junhan:jbnu\" | chpasswd && usermod -aG sudo junhan\nadduser seunghoon --gecos \"\" --disabled-password && echo \"seunghoon:jbnu\" | chpasswd && usermod -aG sudo seunghoon\nadduser coco --gecos \"\" --disabled-password && echo \"coco:jbnu\" | chpasswd && usermod -aG sudo coco\nadduser hyeonji --gecos \"\" --disabled-password && echo \"hyeonji:jbnu\" | chpasswd && usermod -aG sudo hyeonji\nadduser leejjae --gecos \"\" --disabled-password && echo \"leejjae:jbnu\" | chpasswd && usermod -aG sudo leejjae\nadduser soonwon --gecos \"\" --disabled-password && echo \"soonwon:jbnu\" | chpasswd && usermod -aG sudo soonwon\nadduser daehyeon --gecos \"\" --disabled-password && echo \"daehyeon:jbnu\" | chpasswd && usermod -aG sudo daehyeon\nadduser jeongmin --gecos \"\" --disabled-password && echo \"jeongmin:jbnu\" | chpasswd && usermod -aG sudo jeongmin\nadduser mingu --gecos \"\" --disabled-password && echo \"mingu:jbnu\" | chpasswd && usermod -aG sudo mingu\nadduser suwhan --gecos \"\" --disabled-password && echo \"suwhan:jbnu\" | chpasswd && usermod -aG sudo suwhan"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습14-183-컴퓨터-접속-passwd",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습14-183-컴퓨터-접속-passwd",
    "title": "DSTBX2023(2)",
    "section": "실습14: 183 컴퓨터 접속 + passwd",
    "text": "실습14: 183 컴퓨터 접속 + passwd\npasswd"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습15-183에서-git의-설치-및-연결",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습15-183에서-git의-설치-및-연결",
    "title": "DSTBX2023(2)",
    "section": "실습15: 183에서 git의 설치 및 연결",
    "text": "실습15: 183에서 git의 설치 및 연결\nwhich git\n\n!which git\n\n/usr/bin/git\n\n\n\n위치 확인\n\nls gi*\ngi로 시작되는 파일들 찾아줘\nsudo apt-get install git\n\n리눅스 배포판에서 사용되는 패키지 관리 도구인 apt-get\n\n설치\nsudo apt-get remove git\n삭제\n\n\n\n\n\n\nNote\n\n\n\n일반 사용자, 슈퍼 사용자, 루트 사용자는 리눅스 및 유닉스 기반 운영 체제에서 사용되는 용어로 각각 다른 권한 수준을 나타냅니다.\n\n일반 사용자 (Regular User):\n\n일반적인 사용자 계정으로, 시스템에 로그인하여 일반적인 작업을 수행합니다.\n시스템 리소스 및 파일에 대한 접근 권한이 제한적입니다.\n시스템 전반을 관리하거나 변경할 수 있는 특별한 권한이 없습니다.\n\n슈퍼 사용자 (Superuser 또는 sudoer):\n\n일반 사용자 중에서 일시적으로 슈퍼 사용자의 권한을 얻을 수 있는 계정을 의미합니다.\nsudo 명령어를 사용하여 특정 명령어나 작업을 슈퍼 사용자 권한으로 실행할 수 있습니다.\n필요한 경우, sudo 명령어를 사용하여 일시적으로 루트 권한을 얻을 수 있습니다.\n\n루트 사용자 (Root User):\n\n시스템에서 최상위 권한을 가진 사용자로, 시스템의 모든 부분에 접근하고 모든 작업을 수행할 수 있습니다.\n일반적으로 시스템의 관리자 또는 슈퍼 사용자로서 시스템의 설정, 관리, 유지보수 등을 책임집니다.\n보안상의 이유로, 루트 계정으로 로그인하는 것은 권장되지 않으며, 슈퍼 사용자 계정을 통해 필요한 경우에만 루트 권한을 얻는 것이 일반적입니다.\n\n\n요약하면, 루트 사용자는 시스템에서 모든 권한을 가지며, 슈퍼 사용자는 필요에 따라 일시적으로 슈퍼 사용자 권한을 얻을 수 있습니다. 그리고 일반 사용자는 보다 제한된 권한을 갖고 일반적인 사용자 작업을 수행합니다."
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습16-183에서-quarto의-설치",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습16-183에서-quarto의-설치",
    "title": "DSTBX2023(2)",
    "section": "실습16: 183에서 quarto의 설치",
    "text": "실습16: 183에서 quarto의 설치\n\nwhich quarto\nwget https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.533/quarto-1.4.533-linux-amd64.deb\n\ncd ~\n최상위 폴더\nsudo dpkg -i quarto-1.4.533-linux-amd64.deb \nsudo dpkg -r quarto \ni는 install r은 remove"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습17-183에서-아나콘다-설치",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습17-183에서-아나콘다-설치",
    "title": "DSTBX2023(2)",
    "section": "실습17: 183에서 아나콘다 설치",
    "text": "실습17: 183에서 아나콘다 설치\n\nhttps://www.anaconda.com/download &lt;- 여기서 다운받을 수 있는 주소 get 하세여\nbash Anaconda3-2019.03-Linux-x86_64.sh\n\n아나콘다와 git/quarto의 차이는?"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습18-183에서-주피터랩-설치",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습18-183에서-주피터랩-설치",
    "title": "DSTBX2023(2)",
    "section": "실습18: 183에서 주피터랩 설치",
    "text": "실습18: 183에서 주피터랩 설치\n\nconda create py310 python=3.10\nconda activate py310\nconda install -c conda-forge jupyterlab\nconda install -c conda-forge notebook\n\n- 접속하는 방법1\n주피터 오픈 후\njupyter lab --ip=\"0.0.0.0\" --port={8888}\nhttp://127.0.0.1:1212/lab?token=b07f224ffe23a846b907c496234868acfb52bc381df8f4fd\n-&gt;\nhttp://210.117.173.183:1212/lab?token=b07f224ffe23a846b907c496234868acfb52bc381df8f4fd\nip 바꿔서 들어가면 됌\n- 접속하는 방법2\n\njupyter notebook password\n\n비밀번호 설정해서 들어가기\n이번엔 ip 치고 들어가기\njupyter lab --ip=\"210.117.178.183\" --port={8888}"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습19-1일차-숙제-쉽게-하는-방법",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습19-1일차-숙제-쉽게-하는-방법",
    "title": "DSTBX2023(2)",
    "section": "실습19: 1일차 숙제 쉽게 하는 방법",
    "text": "실습19: 1일차 숙제 쉽게 하는 방법\nhttps://guebin.github.io/IP2022/2022/03/28/(4주차)-3월28일.html\n- 깃헙에서 홈페이지 만들경우 대응하는 레포지토리를 찾으면 쉽게 복사가능.\n\n#!wget \"https://raw.githubusercontent.com/guebin/IP2022/master/_notebooks/2022-03-28-(4%EC%A3%BC%EC%B0%A8)%203%EC%9B%9428%EC%9D%BC.ipynb\"\n\n!wget 주소 or !wget \"주소\""
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습20-블로그-꾸미기",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습20-블로그-꾸미기",
    "title": "DSTBX2023(2)",
    "section": "실습20: 블로그 꾸미기",
    "text": "실습20: 블로그 꾸미기"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습21-이미지-그리기-슈퍼유저",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습21-이미지-그리기-슈퍼유저",
    "title": "DSTBX2023(2)",
    "section": "실습21: 이미지 그리기 (슈퍼유저)",
    "text": "실습21: 이미지 그리기 (슈퍼유저)\n- 방법1\n\n!wget https://imgs.xkcd.com/comics/sandwich.png\n\n--2024-01-03 14:08:48--  https://imgs.xkcd.com/comics/sandwich.png\nResolving imgs.xkcd.com (imgs.xkcd.com)... 146.75.48.67, 2a04:4e42:7c::67\nConnecting to imgs.xkcd.com (imgs.xkcd.com)|146.75.48.67|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 11828 (12K) [image/png]\nSaving to: ‘sandwich.png’\n\nsandwich.png        100%[===================&gt;]  11.55K  --.-KB/s    in 0s      \n\n2024-01-03 14:08:48 (69.3 MB/s) - ‘sandwich.png’ saved [11828/11828]\n\n\n\n\n# ![](sandwich.png)\n\n- 방법2\n\n# ![](https://imgs.xkcd.com/comics/sandwich.png)\n\n- 방법3: 스크린샷"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습22-182-ssh차단-우회하기-배운적x",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습22-182-ssh차단-우회하기-배운적x",
    "title": "DSTBX2023(2)",
    "section": "실습22: 182 ssh차단 우회하기 (배운적X)",
    "text": "실습22: 182 ssh차단 우회하기 (배운적X)\nsudo vi /etc/ssh/sshd_config \n원래 기본으로 22번으로 인식해서 포트 번호 입력 안 해도 ssh로 들어갈 수 있었음.\n위 코드에서 port 주석처리 풀어주고 포트 번호 지정해준 후\nsudo systemctl restart ssh.service\n하면 ssh 이름@0.0.0.0 -p 번호\n로 들어갈 수 있음"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습23-186-컴퓨터-접속",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습23-186-컴퓨터-접속",
    "title": "DSTBX2023(2)",
    "section": "실습23: 186 컴퓨터 접속",
    "text": "실습23: 186 컴퓨터 접속"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습24-186-ssh차단-우회하기-배운적x",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습24-186-ssh차단-우회하기-배운적x",
    "title": "DSTBX2023(2)",
    "section": "실습24: 186 ssh차단 우회하기 (배운적X)",
    "text": "실습24: 186 ssh차단 우회하기 (배운적X)"
  },
  {
    "objectID": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습25-186-컴퓨터-개발환경-셋팅하기",
    "href": "posts/1_Note/2024-01-03-DSTBX2023(2).html#실습25-186-컴퓨터-개발환경-셋팅하기",
    "title": "DSTBX2023(2)",
    "section": "실습25: 186 컴퓨터 개발환경 셋팅하기",
    "text": "실습25: 186 컴퓨터 개발환경 셋팅하기"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html",
    "href": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html",
    "title": "Regular Graph",
    "section": "",
    "text": "summary\n모든 노드가 동일한 degree를 갖는 그래프, degree matrix가 \\(I\\)나 \\(kI\\)로 나타낼 수 있는 그래프\ndegree matrix: the degree matrix of an undirected graph is a diagonal matrix which contains information about the degree of each vertex—that is, the number of edges attached to each vertex."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-1",
    "href": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-1",
    "title": "Regular Graph",
    "section": "0-regular graph",
    "text": "0-regular graph\n\n참고 아래도 동일 차수이므로 regular graph\n\n\nw = np.array([[1., 0., 0., 0., 0.],\n       [0., 1., 0., 0., 0.],\n       [0., 0., 1., 0., 0.],\n       [0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 1.]])\n\n\nd= w.sum(axis=1)\nD= np.diag(d)\n\n\nDegree matrix = \\(I\\)\n\n\nD\n\narray([[1., 0., 0., 0., 0.],\n       [0., 1., 0., 0., 0.],\n       [0., 0., 1., 0., 0.],\n       [0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 1.]])\n\n\n\nlst = []\nfor i in range(5):\n    for j in range(5):\n        if w[i,j] == 1:\n            lst.append([i,j])\n\n\nG = nx.Graph()\n\n\nG.add_edges_from(np.array(lst))\n\n\nplt.figure(figsize=(10, 10)) \nnx.draw_networkx(G, with_labels=True, font_weight='bold', node_color='orange', node_size=1500, font_color='white', font_size=30,width=5)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-2",
    "href": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-2",
    "title": "Regular Graph",
    "section": "1-regular graph",
    "text": "1-regular graph\n\nw = np.array([\n       [0., 1., 0., 0., 0., 0.],\n       [1., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 1., 0., 0.],\n       [0., 0., 1., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 1.],\n       [0., 0., 0., 0., 1., 0.]])\n\n\nd= w.sum(axis=1)\nD= np.diag(d)\n\n\nDegree matrix = \\(I\\)\n\n\nD\n\narray([[1., 0., 0., 0., 0., 0.],\n       [0., 1., 0., 0., 0., 0.],\n       [0., 0., 1., 0., 0., 0.],\n       [0., 0., 0., 1., 0., 0.],\n       [0., 0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 0., 1.]])\n\n\n\nlst = []\nfor i in range(6):\n    for j in range(6):\n        if w[i,j] == 1:\n            lst.append([i,j])\n\n\nG = nx.Graph()\n\n\nG.add_edges_from(np.array(lst))\n\n\nplt.figure(figsize=(10, 10)) \nnx.draw_networkx(G, with_labels=True, font_weight='bold', node_color='orange', node_size=1500, font_color='white', font_size=30,width=5)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-3",
    "href": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-3",
    "title": "Regular Graph",
    "section": "2-regular graph",
    "text": "2-regular graph\n\nw = np.array([\n       [0., 1., 1., 0., 0., 0.],\n       [1., 0., 1., 0., 0., 0.],\n       [1., 1., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 1.],\n       [0., 0., 0., 1., 0., 1.],\n       [0., 0., 0., 1., 1., 0.]])\n\n\nd= w.sum(axis=1)\nD= np.diag(d)\n\n\nDegree matrix = \\(2I\\)\n\n\nD\n\narray([[2., 0., 0., 0., 0., 0.],\n       [0., 2., 0., 0., 0., 0.],\n       [0., 0., 2., 0., 0., 0.],\n       [0., 0., 0., 2., 0., 0.],\n       [0., 0., 0., 0., 2., 0.],\n       [0., 0., 0., 0., 0., 2.]])\n\n\n\nlst = []\nfor i in range(6):\n    for j in range(6):\n        if w[i,j] == 1:\n            lst.append([i,j])\n\n\nG = nx.Graph()\n\n\nG.add_edges_from(np.array(lst))\n\n\nplt.figure(figsize=(10, 10)) \nnx.draw_networkx(G, with_labels=True, font_weight='bold', node_color='orange', node_size=1500, font_color='white', font_size=30,width=5)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-4",
    "href": "posts/2_Studies/GRAPH/2023-06-30-Regular Graph.html#regular-graph-4",
    "title": "Regular Graph",
    "section": "3-regular graph",
    "text": "3-regular graph\n\nw = np.array([\n       [0., 1., 1., 0., 0., 1.],\n       [1., 0., 1., 1., 0., 0.],\n       [1., 1., 0., 0., 1., 0.],\n       [0., 1., 0., 0., 1., 1.],\n       [0., 0., 1., 1., 0., 1.],\n       [1., 0., 0., 1., 1., 0.]])\n\n\nd= w.sum(axis=1)\nD= np.diag(d)\n\n\nDegree matrix = \\(3I\\)\n\n\nD\n\narray([[3., 0., 0., 0., 0., 0.],\n       [0., 3., 0., 0., 0., 0.],\n       [0., 0., 3., 0., 0., 0.],\n       [0., 0., 0., 3., 0., 0.],\n       [0., 0., 0., 0., 3., 0.],\n       [0., 0., 0., 0., 0., 3.]])\n\n\n\nlst = []\nfor i in range(6):\n    for j in range(6):\n        if w[i,j] == 1:\n            lst.append([i,j])\n\n\nG = nx.Graph()\n\n\nG.add_edges_from(np.array(lst))\n\n\nplt.figure(figsize=(10, 10)) \nnx.draw_networkx(G, with_labels=True, font_weight='bold', node_color='orange', node_size=1500, font_color='white', font_size=30,width=5)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "",
    "text": "using LinearAlgebra, FFTW"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#cyclic-shfit-operator-bf-b",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#cyclic-shfit-operator-bf-b",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "Cyclic shfit operator \\({\\bf B}\\)",
    "text": "Cyclic shfit operator \\({\\bf B}\\)\nThe matrix \\({\\bf B}\\) representing the periodic shift is\n\nB= [0 0 0 0 1\n    1 0 0 0 0 \n    0 1 0 0 0\n    0 0 1 0 0\n    0 0 0 1 0]\n\n5×5 Matrix{Int64}:\n 0  0  0  0  1\n 1  0  0  0  0\n 0  1  0  0  0\n 0  0  1  0  0\n 0  0  0  1  0\n\n\nThis matrix is the cyclic shift.\nnote: \\({\\bf B}\\) is orthogonal matrix.\n\nB'B\n\n5×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  1  0  0  0\n 0  0  1  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n\n\n(ex1) Define \\({\\bf s}\\) as\n\ns = [1,2,3,4,5]\ns\n\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\n\nObserve that\n\nB*s\n\n5-element Vector{Int64}:\n 5\n 1\n 2\n 3\n 4\n\n\n\nB^2*s\n\n5-element Vector{Int64}:\n 4\n 5\n 1\n 2\n 3\n\n\n\nB^3*s\n\n5-element Vector{Int64}:\n 3\n 4\n 5\n 1\n 2\n\n\nThus we can interprete the matrix \\({\\bf B}\\) as cyclic shift operator such that\n\\[\n{\\bf B}s_n =s_{n-1}\n\\]\nfor \\(n=1,\\dots, N-1\\) and \\({\\bf B}s_0 =s_N\\).\nnote: \\({\\bf B}\\)는 시계열에서 다루는 backshift operator 와 비슷함."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#dft",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#dft",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "DFT",
    "text": "DFT\nThe matrix \\({\\bf B}\\) can be expressed as\n\\({\\bf B}={\\bf DFT}^\\ast \\cdot {\\bf \\Lambda} \\cdot {\\bf DFT}\\)\nwhere \\({\\bf DFT}\\) is unitary and symmetric matrix and \\(\\bf \\Lambda\\) is diagonal matrix.\n\nλ, Ψ = eigen(B)\n\nEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}\nvalues:\n5-element Vector{ComplexF64}:\n -0.8090169943749472 - 0.5877852522924725im\n -0.8090169943749472 + 0.5877852522924725im\n 0.30901699437494734 - 0.9510565162951536im\n 0.30901699437494734 + 0.9510565162951536im\n  0.9999999999999998 + 0.0im\nvectors:\n5×5 Matrix{ComplexF64}:\n  0.138197+0.425325im   0.138197-0.425325im  …  0.447214+0.0im\n -0.361803-0.262866im  -0.361803+0.262866im     0.447214+0.0im\n  0.447214-0.0im        0.447214+0.0im          0.447214+0.0im\n -0.361803+0.262866im  -0.361803-0.262866im     0.447214+0.0im\n  0.138197-0.425325im   0.138197+0.425325im     0.447214+0.0im\n\n\n\nB ≈ Ψ * Diagonal(λ) * Ψ'\n\ntrue\n\n\nDefine \\({\\boldsymbol \\Psi}^\\ast={\\bf DFT}\\).\n\nDFT = Ψ'\n\n5×5 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n  0.138197-0.425325im  -0.361803+0.262866im  …  0.138197+0.425325im\n  0.138197+0.425325im  -0.361803-0.262866im     0.138197-0.425325im\n -0.361803-0.262866im  -0.361803+0.262866im     0.138197-0.425325im\n -0.361803+0.262866im  -0.361803-0.262866im     0.138197+0.425325im\n  0.447214-0.0im        0.447214-0.0im          0.447214-0.0im\n\n\nNote that the eigenvalues are not ordered in julia.\n\nλ[5], exp(-im* 2π/5 * 0)\n\n(0.9999999999999998 + 0.0im, 1.0 - 0.0im)\n\n\n\nλ[3], exp(-im* 2π/5 * 1)\n\n(0.30901699437494734 - 0.9510565162951536im, 0.30901699437494745 - 0.9510565162951535im)\n\n\n\nλ[1], exp(-im* 2π/5 * 2)\n\n(-0.8090169943749472 - 0.5877852522924725im, -0.8090169943749473 - 0.5877852522924732im)\n\n\n\nλ[2], exp(-im* 2π/5 * 3)\n\n(-0.8090169943749472 + 0.5877852522924725im, -0.8090169943749475 + 0.587785252292473im)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#spectral-components-and-frequencies",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#spectral-components-and-frequencies",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "Spectral components and Frequencies",
    "text": "Spectral components and Frequencies\nWe remark:\n(1) Spectral components: For \\(k = 0,1,2,\\dots, N-1\\), the \\(k\\)-th column of \\({\\bf DFT}^\\ast\\) is defined by\n\\[\\Psi_k:=\\frac{1}{\\sqrt{N}}\\begin{bmatrix} 1 \\\\ e^{j\\frac{2\\pi}{N}k} \\\\ e^{j\\frac{2\\pi}{N}2k} \\\\ e^{j\\frac{2\\pi}{N}3k} \\\\  \\dots \\\\ e^{j\\frac{2\\pi}{N}(N-1)k} \\end{bmatrix}.\\]\nNote that \\(\\Psi_k\\) can be also interpreted as \\(\\ell\\)-th eigenvector of \\({\\bf A}\\) correspoding \\(\\lambda_\\ell = e^{-j\\frac{2\\pi}{N}k}\\). Those eigenvectors\n\\[\\big\\{{\\bf 1},\\Psi_1,\\Psi_2, \\dots, \\Psi_{N-1}\\big\\}\\]\nform a complete orthonomal basis of \\(\\mathbb{C}^N\\). These vectors are called spectral components.\n(2) Frequencies: The diagonal entries of \\({\\bf \\Lambda}\\) are the eigenvalues of the time shift \\({\\bf B}\\). In Physics and in operator theory, these eigenvalues are the frequencies of the signal. In DSP it is more common to call frequencies\n\\[\\Omega_k=\\frac{-1}{2\\pi j}\\ln\\lambda_k=\\frac{-1}{2\\pi j}\\ln e^{-j \\frac{2\\pi}{N}k}=\\frac{k}{N}, \\quad k=0,1,2,\\dots,N-1.\\]\n\nThe \\(N\\) (time) frequencies \\(\\Omega_k\\) are all distinct, positive, equally spaced, and increasing from \\(0\\) to \\(\\frac{N-1}{N}\\). The spectral components are the complex exponential sinusiodal functions. For example, corresponding to the zero frequency is the DC spectral component (a vector whose entries are constant and all equal to \\(\\frac{1}{\\sqrt{N}}\\))."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#dft-1",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#dft-1",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "DFT",
    "text": "DFT\n일반적으로 우리가 알고있는 DFT1는 아래와 같다. (이 그림은 위키피디아에서 캡쳐한 것이다)\n1 discrete Fourier transform\n\n\n그림1: 위키에서 긁어온 DFT의 정의\n\n\n즉 DFT는 임의의 신호 \\(\\{{\\bf x}_n\\}:=x_0,x_1,\\dots,x_{N-1}\\)를 적당한 규칙2에 따라서 \\(\\{{\\bf X}_k\\}:=X_0,X_1,\\dots,X_{N-1}\\)로 바꾸는 변환을 이라고 이해할 수 있다. 이때 사용되는 적당한 규칙은 구체적으로 아래의 수식을 의미한다.\n2 \\(X_k = \\sum_{n=0}^{N-1}x_n\\cdot e^{-i\\frac{2\\pi}{N}kn}\\)\\[X_k = \\sum_{n=0}^{N-1}x_n\\cdot e^{-i\\frac{2\\pi}{N}kn}\\]\n그런데 매트릭스를 활용하면 위의 수식을 아래와 같이 표현할 수 있다.\n\\[\\begin{bmatrix} X_1 \\\\ X_2 \\\\ X_3 \\\\ \\dots \\\\ X_{N-1} \\end{bmatrix}\n=\\begin{bmatrix}\n1 & 1 & 1 & \\dots & 1 \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 1} & e^{-i \\frac{2\\pi}{N}\\cdot 2} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)}\\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 2} & e^{-i \\frac{2\\pi}{N}\\cdot 4} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)}\\\\\n\\dots & \\dots & \\dots & \\dots & \\dots \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)} & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)^2}\n\\end{bmatrix}\n\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ \\dots \\\\ x_{N-1} \\end{bmatrix}\\]\n편의상 \\({\\bf X}\\)와 \\({\\bf x}\\)를 \\(N \\times 1\\) col-vec이라고 생각하고 DFT를 아래와 같은 matrix로 정의하자.\n\\[{\\bf DFT} = \\begin{bmatrix}\n1 & 1 & 1 & \\dots & 1 \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 1} & e^{-i \\frac{2\\pi}{N}\\cdot 2} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)}\\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 2} & e^{-i \\frac{2\\pi}{N}\\cdot 4} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)}\\\\\n\\dots & \\dots & \\dots & \\dots & \\dots \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)} & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)^2}\n    \\end{bmatrix}\\]\n그러면\n\\[{\\bf X} = {\\bf DFT} \\cdot {\\bf x}\\]\n와 같이 표현할 수 있고 \\({\\bf x}\\)에서 \\({\\bf X}\\)로 바꾸는 과정을 단순히 \\({\\bf DFT}\\)행렬을 \\({\\bf x}\\)의 왼쪽에 곱하는 과정으로 이해할 수 있다.\n(참고) 사실 아래와 같이 \\({\\bf DFT}\\)를 정의하는 버전도 있다. (둘이 혼용해서 쓰인다)\n\\[{\\bf DFT} = \\frac{1}{\\sqrt{N}}\\begin{bmatrix}\n1 & 1 & 1 & \\dots & 1 \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 1} & e^{-i \\frac{2\\pi}{N}\\cdot 2} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)}\\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 2} & e^{-i \\frac{2\\pi}{N}\\cdot 4} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)}\\\\\n\\dots & \\dots & \\dots & \\dots & \\dots \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)} & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)^2}\n    \\end{bmatrix}\\]\n\n예제1 아래는 위키에서 긁어온 예제이다. 이 예제를 따라가보자.\n\n\n\n그림2: 위키에서 긁어온 예제이미지\n\n\n예제를 풀기위해서 우선 아래와 같은 벡터를 선언하다.\n\nx = [1, 2-im, -im, -1+2im]\n\n4-element Vector{Complex{Int64}}:\n  1 + 0im\n  2 - 1im\n  0 - 1im\n -1 + 2im\n\n\n(풀이1)\n\\(4\\times 4\\)의 크기를 가지는 DFT행렬을 선언한다.\n(step1) 아래의 매트릭스 생성\n\n_DFT = reshape([i*j for i in 0:3 for j in 0:3], (4,4))\n_DFT\n\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  1  2  3\n 0  2  4  6\n 0  3  6  9\n\n\n(step2) _DFT의 각 원소에 함수 \\(f: x \\to \\exp(-i\\frac{2\\pi}{4}x)\\)를 취함\n\nf = x -&gt; exp(-im * (2π/4) * x)\nDFT = _DFT .|&gt; f\n\n4×4 Matrix{ComplexF64}:\n 1.0-0.0im           1.0-0.0im          …           1.0-0.0im\n 1.0-0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im\n 1.0-0.0im          -1.0-1.22465e-16im             -1.0-3.67394e-16im\n 1.0-0.0im  -1.83697e-16+1.0im              5.51091e-16-1.0im\n\n\n이제 \\({\\bf X}\\)를 구하면 아래와 같다.\n\nDFT * x\n\n4-element Vector{ComplexF64}:\n                   2.0 + 0.0im\n   -1.9999999999999998 - 2.0000000000000004im\n 8.881784197001252e-16 - 1.9999999999999998im\n    3.9999999999999987 + 4.000000000000001im\n\n\n위키의 답이 잘 나옴\n(풀이2)\n참고로 아래와 같이 패키지를 이용하여 구할 수도 있다.\n\nfft(x)\n\n4-element Vector{ComplexF64}:\n  2.0 + 0.0im\n -2.0 - 2.0im\n  0.0 - 2.0im\n  4.0 + 4.0im"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#inverse-dft",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#inverse-dft",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "Inverse DFT",
    "text": "Inverse DFT\n앞으로는 \\({\\bf DFT}\\)를 아래와 같이 정의하자.\n\\[{\\bf DFT} = \\frac{1}{\\sqrt{N}}\\begin{bmatrix}\n1 & 1 & 1 & \\dots & 1 \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 1} & e^{-i \\frac{2\\pi}{N}\\cdot 2} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)}\\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot 2} & e^{-i \\frac{2\\pi}{N}\\cdot 4} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)}\\\\\n\\dots & \\dots & \\dots & \\dots & \\dots \\\\\n1 & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)} & e^{-i \\frac{2\\pi}{N}\\cdot 2(N-1)} & \\dots & e^{-i \\frac{2\\pi}{N}\\cdot (N-1)^2}\n    \\end{bmatrix}\\]\n\\({\\bf DFT}\\)행렬에는 몇 가지 특징이 있다.\n특징1: 유니터리행렬이다. 즉 \\({\\bf DFT}^\\ast \\cdot {\\bf DFT} = {\\bf DFT}^\\ast \\cdot{\\bf DFT} = {\\bf I}\\) 이다.\n\n_DFT = reshape([i*j for i in 0:3 for j in 0:3], (4,4))\nf = x -&gt; exp(-im * (2π/4) * x)\nDFT = _DFT .|&gt; f\nDFT # 아까의 예제의 DFT!\n\n4×4 Matrix{ComplexF64}:\n 1.0-0.0im           1.0-0.0im          …           1.0-0.0im\n 1.0-0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im\n 1.0-0.0im          -1.0-1.22465e-16im             -1.0-3.67394e-16im\n 1.0-0.0im  -1.83697e-16+1.0im              5.51091e-16-1.0im\n\n\n\nDFT = (1/√4)*DFT # 새로운 DFT의 정의 \nDFT'DFT .|&gt; round # 유니터리행렬임을 확인!\n\n4×4 Matrix{ComplexF64}:\n  1.0+0.0im  -0.0-0.0im   0.0-0.0im   0.0-0.0im\n -0.0+0.0im   1.0+0.0im  -0.0-0.0im   0.0-0.0im\n  0.0+0.0im  -0.0+0.0im   1.0+0.0im  -0.0-0.0im\n  0.0+0.0im   0.0+0.0im  -0.0+0.0im   1.0+0.0im\n\n\n특징2: \\({\\bf DFT}\\)는 대칭행렬이다. 따라서 이 행렬의 켤레전치는 DFT의 각 원소에서 단순히 \\(i=\\sqrt{-1}\\) 대신에 \\(-i\\) 를 넣은 것과 같다.\n특징1-2를 조합하면 아래와 같이 \\({\\bf DFT}\\)에서 \\(i\\) 대신에 \\(-i\\)를 넣은 행렬이 변환 DFT를 취소시킬 수 있음을 이해할 수 있다. 3\n3 아래의 행렬은 \\({\\bf DFT}^\\ast\\) 혹은 \\({\\bf DFT}\\)의 conjugate matrix 혹은 \\({\\bf DFT}^{-1}\\)로 생각할 수 있음\\[\\frac{1}{\\sqrt{N}}\\begin{bmatrix}\n1 & 1 & 1 & \\dots & 1 \\\\\n1 & e^{i \\frac{2\\pi}{N}\\cdot 1} & e^{i \\frac{2\\pi}{N}\\cdot 2} & \\dots & e^{i \\frac{2\\pi}{N}\\cdot (N-1)}\\\\\n1 & e^{i \\frac{2\\pi}{N}\\cdot 2} & e^{i \\frac{2\\pi}{N}\\cdot 4} & \\dots & e^{i \\frac{2\\pi}{N}\\cdot 2(N-1)}\\\\\n\\dots & \\dots & \\dots & \\dots & \\dots \\\\\n1 & e^{i \\frac{2\\pi}{N}\\cdot (N-1)} & e^{i \\frac{2\\pi}{N}\\cdot 2(N-1)} & \\dots & e^{i \\frac{2\\pi}{N}\\cdot (N-1)^2}\n    \\end{bmatrix}\\]\n행렬 \\({\\bf DFT}\\)를 discrete Fourier transform으로 생각했듯이 위의 행렬을 inverse discrete Fourier transform으로 해석할 수 있다."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#dft의-또-다른-정의",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#dft의-또-다른-정의",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "DFT의 또 다른 정의",
    "text": "DFT의 또 다른 정의\n이번에는 \\({\\bf DFT}\\)에 대한 다른 정의를 생각해보자. 우선 아래와 같은 행렬 \\({\\bf B}\\)를 고려하자.\n\nB= [0 0 0 1 \n    1 0 0 0 \n    0 1 0 0\n    0 0 1 0]\n\n4×4 Matrix{Int64}:\n 0  0  0  1\n 1  0  0  0\n 0  1  0  0\n 0  0  1  0\n\n\n이것은 길이가 4인 임의의 column vector를 아래로 한칸씩 이동시키는 매트릭스이다.\n\nx = [1, 2-im, -im, -1+2im]\n\n4-element Vector{Complex{Int64}}:\n  1 + 0im\n  2 - 1im\n  0 - 1im\n -1 + 2im\n\n\n\nB*x # 아래로 한칸이동 \n\n4-element Vector{Complex{Int64}}:\n -1 + 2im\n  1 + 0im\n  2 - 1im\n  0 - 1im\n\n\n\nB^2*x # 아래로 두칸이동, B^2*x = B*(Bx) 이므로 \n\n4-element Vector{Complex{Int64}}:\n  0 - 1im\n -1 + 2im\n  1 + 0im\n  2 - 1im\n\n\n한편 이 매트릭스 \\({\\bf B}\\)는 아래와 같이 고유분해가 가능하다.\n\\[ {\\bf B} = {\\bf \\Psi} {\\bf \\Lambda} {\\bf \\Psi}^\\ast\\]\n\n\\({\\bf \\Psi}\\): make \\(\\frac{1}{\\sqrt{N}}[e^{\\sqrt{-1} \\frac{2\\pi}{N} ij}~\\text{ for }~ i=0,1,2,\\dots,N-1~\\text{ for }~j=0,1,2,\\dots,N-1]\\) and apply reshape function with \\((N,N)\\).\n\\({\\bf \\Lambda}\\): make \\([e^{-\\sqrt{-1}\\frac{2\\pi}{N}i}~\\text{ for }~ i=0,1,2\\dots,N-1]\\) and apply Diagonal function.\n\n\nN = 4 \nλ = [exp(-im * (2π/N) *i) for i in 0:(N-1)]\nΛ = Diagonal(λ)\n_Ψ = 1/√N *[exp(im * (2π/N) * i*j) for i in 0:(N-1) for j in 0:(N-1)]\nΨ = reshape(_Ψ, (N,N))\nB ≈ Ψ * Λ * Ψ'\n\ntrue\n\n\n그런데 위에서 정의된 \\({\\bf \\Psi}^\\ast\\)는 우리가 그전에 정의하였던 \\({\\bf DFT}\\)의 행렬과 같다.\n\n_DFT = reshape([i*j for i in 0:3 for j in 0:3], (4,4))\nDFT = _DFT .|&gt; (x -&gt; exp(-im * (2π/4) * x)) \nDFT = DFT * 1/√N\n\n4×4 Matrix{ComplexF64}:\n 0.5-0.0im           0.5-0.0im          …           0.5-0.0im\n 0.5-0.0im   3.06162e-17-0.5im             -9.18485e-17+0.5im\n 0.5-0.0im          -0.5-6.12323e-17im             -0.5-1.83697e-16im\n 0.5-0.0im  -9.18485e-17+0.5im              2.75546e-16-0.5im\n\n\n\nΨ' == DFT \n\ntrue\n\n\n결국 요약하면 길이가 \\(N\\)인 신호의 \\({\\bf DFT}\\)행렬은 아래의 과정으로 구할 수 있음을 알 수 있다.\n\nForward operator \\({\\bf A}\\)를 정의한다.\n\\({\\bf A}\\)의 고유벡터행렬 \\({\\bf \\Psi}\\)을 구한다. 4\n\\({\\bf \\Psi}\\)의 conjugate transpose matrix \\({\\bf \\Psi}^\\ast\\) 를 구한다. 이것이 \\({\\bf DFT}\\) matrix 이다. 5\n\n4 고유벡터행렬은 고유값 \\(e^{-\\sqrt{-1}\\frac{2\\pi}{N}i}\\)에 의하여 정렬되어 있어야 함.5 사실 이미 대칭행렬이므로 conjugate matrix만 구하면 된다."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#spectral-component-and-frequencies",
    "href": "posts/2_Studies/GRAPH/2022-12-24-Chap-8.3.html#spectral-component-and-frequencies",
    "title": "[CGSP] Chap 8.3: Discrete Fourier Transform",
    "section": "Spectral component and Frequencies",
    "text": "Spectral component and Frequencies\n\\({\\bf A}\\)의 고유벡터 \\({\\bf \\Psi}\\)의 각 column을 spectral component라고 부른다.\n\nψ₁ = Ψ[:,1] # ψ₁ is first spectral component \nψ₂ = Ψ[:,2] # ψ₂ is seconde spectral component \nψ₃ = Ψ[:,3] # ψ₃ is third spectral component \nψ₄ = Ψ[:,4] # ψ₄ is last spectral component\n\n그리고 아래와 같은 수열을 \\(\\Omega_{k}=\\frac{k}{N}\\)을 frequency 라고 부른다.\n\nN=4 \nΩ = [k/N for k in 0:(N-1)]\nΩ\n\n4-element Vector{Float64}:\n 0.0\n 0.25\n 0.5\n 0.75"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-01-15-Chap-12.4.html",
    "href": "posts/2_Studies/GRAPH/2023-01-15-Chap-12.4.html",
    "title": "[CGSP] Chap 12.4: Node Subsampling for PSD Estimation",
    "section": "",
    "text": "using LinearAlgebra, Plots, FFTW, Statistics\n\n\ncolumnwise_kron = \n(C,D) -&gt; hcat([kron(C[:,i],D[:,i]) for i in 1:size(C)[2]]...)\n\n#49 (generic function with 1 method)\n\n\n\n12.4.1 The Sampling Problem\n아래와 같이 길이가 \\(N=10\\) 인 신호 \\({\\bf x}\\)를 고려하자.\n\nx = rand(10)\n\n10-element Vector{Float64}:\n 0.03235208758206609\n 0.5069925854414447\n 0.5795228508497553\n 0.682832351742401\n 0.64422613488741\n 0.24116013388795854\n 0.8439116925218157\n 0.6362602319916778\n 0.386069828675059\n 0.5313655894235898\n\n\n여기에서 1,3,4,5 번째 원소만 추출하여길이가 \\(K=4\\) 인 신호 \\({\\bf y}\\)를 만들고 싶다.\n\ny = x[[1,3,4,5]]\n\n4-element Vector{Float64}:\n 0.03235208758206609\n 0.5795228508497553\n 0.682832351742401\n 0.64422613488741\n\n\n이 과정은 아래와 같이 수행할 수도 있다.\n\nΦ= [1 0 0 0 0 0 0 0 0 0\n    0 0 1 0 0 0 0 0 0 0\n    0 0 0 1 0 0 0 0 0 0\n    0 0 0 0 1 0 0 0 0 0]\n\n4×10 Matrix{Int64}:\n 1  0  0  0  0  0  0  0  0  0\n 0  0  1  0  0  0  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0\n 0  0  0  0  1  0  0  0  0  0\n\n\n\nΦ*x\n\n4-element Vector{Float64}:\n 0.03235208758206609\n 0.5795228508497553\n 0.682832351742401\n 0.64422613488741\n\n\n즉 적당한 \\(K\\times N\\) selection matrix를 선언하여 subsampling을 수행할 수 있다. 이때 매트릭스 \\({\\bf \\Phi}\\)를 subsampling matrix 혹은 sparse sampling matrix 라고 부른다.\n\n\n12.4.2 Compressed LS Estimator\n\nN = 10\nV = [i*j for i in 0:(N-1) for j in 0:(N-1)] |&gt; \n    x -&gt; reshape(x,(N,N)) .|&gt; \n    x -&gt; exp(im * (2π/N) * x) \n\n10×10 Matrix{ComplexF64}:\n 1.0+0.0im        1.0+0.0im          …        1.0+0.0im\n 1.0+0.0im   0.809017+0.587785im         0.809017-0.587785im\n 1.0+0.0im   0.309017+0.951057im         0.309017-0.951057im\n 1.0+0.0im  -0.309017+0.951057im        -0.309017-0.951057im\n 1.0+0.0im  -0.809017+0.587785im        -0.809017-0.587785im\n 1.0+0.0im       -1.0+1.22465e-16im  …       -1.0+1.10218e-15im\n 1.0+0.0im  -0.809017-0.587785im        -0.809017+0.587785im\n 1.0+0.0im  -0.309017-0.951057im        -0.309017+0.951057im\n 1.0+0.0im   0.309017-0.951057im         0.309017+0.951057im\n 1.0+0.0im   0.809017-0.587785im         0.809017+0.587785im\n\n\n\nG = columnwise_kron(conj(V),V)\n\n100×10 Matrix{ComplexF64}:\n 1.0+0.0im        1.0+0.0im          …        1.0+0.0im\n 1.0+0.0im   0.809017+0.587785im         0.809017-0.587785im\n 1.0+0.0im   0.309017+0.951057im         0.309017-0.951057im\n 1.0+0.0im  -0.309017+0.951057im        -0.309017-0.951057im\n 1.0+0.0im  -0.809017+0.587785im        -0.809017-0.587785im\n 1.0+0.0im       -1.0+1.22465e-16im  …       -1.0+1.10218e-15im\n 1.0+0.0im  -0.809017-0.587785im        -0.809017+0.587785im\n 1.0+0.0im  -0.309017-0.951057im        -0.309017+0.951057im\n 1.0+0.0im   0.309017-0.951057im         0.309017+0.951057im\n 1.0+0.0im   0.809017-0.587785im         0.809017+0.587785im\n 1.0+0.0im   0.809017-0.587785im     …   0.809017+0.587785im\n 1.0+0.0im        1.0+0.0im                   1.0+0.0im\n 1.0+0.0im   0.809017+0.587785im         0.809017-0.587785im\n    ⋮                                ⋱  \n 1.0+0.0im        1.0+0.0im                   1.0+0.0im\n 1.0+0.0im   0.809017+0.587785im         0.809017-0.587785im\n 1.0+0.0im   0.809017+0.587785im     …   0.809017-0.587785im\n 1.0+0.0im   0.309017+0.951057im         0.309017-0.951057im\n 1.0+0.0im  -0.309017+0.951057im        -0.309017-0.951057im\n 1.0+0.0im  -0.809017+0.587785im        -0.809017-0.587785im\n 1.0+0.0im       -1.0-1.11022e-16im          -1.0+2.27596e-15im\n 1.0+0.0im  -0.809017-0.587785im     …  -0.809017+0.587785im\n 1.0+0.0im  -0.309017-0.951057im        -0.309017+0.951057im\n 1.0+0.0im   0.309017-0.951057im         0.309017+0.951057im\n 1.0+0.0im   0.809017-0.587785im         0.809017+0.587785im\n 1.0+0.0im        1.0+0.0im                   1.0+0.0im\n\n\n- 방법1\n\nĉx = vec(x*x')\np̂ = inv(G' * G) * G' * ĉx\n\n10-element Vector{ComplexF64}:\n    0.25854107856772546 + 2.245922875954761e-20im\n   0.004743491121735806 - 1.3138893409553828e-18im\n   0.006946482731189413 - 9.791191432641327e-19im\n   0.001721693617954179 - 1.9827974128203887e-18im\n   0.011344167525098774 + 2.6827005818057562e-19im\n 0.00012662617844242917 - 3.748573865136995e-20im\n   0.011344167525098762 + 2.7448152053954017e-18im\n  0.0017216936179541913 - 9.35534609073096e-19im\n   0.006946482731189404 + 1.954408900185458e-18im\n   0.004743491121735756 - 2.561030398375897e-18im\n\n\n- 방법2\n\nĉy = vec(y*y')\np̂ = (kron(Φ,Φ)*G)' * ĉy\n\n10-element Vector{ComplexF64}:\n   3.759462826821233 + 0.0im\n   2.765185174577697 - 2.0816681711721685e-17im\n   1.077337414764992 + 2.7755575615628914e-17im\n 0.11594812606807317 + 2.0816681711721685e-17im\n 0.08838298603932843 + 3.903127820947816e-17im\n 0.32863702713833354 + 4.622231866529366e-33im\n 0.08838298603932859 + 9.540979117872439e-18im\n  0.1159481260680729 - 2.0816681711721685e-17im\n  1.0773374147649915 + 0.0im\n  2.7651851745776965 - 2.0816681711721685e-17im"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-07-02-GSO.html",
    "href": "posts/2_Studies/GRAPH/2023-07-02-GSO.html",
    "title": "Graph Shift Operator",
    "section": "",
    "text": "Definition(Djuric and Richard 2018): Given a normal shift operator \\({\\bf S}\\), we say that a graph signal \\({\\bf y}\\) is weakly stationary with respect to \\({\\bf S}\\) if, for all \\(a\\), \\(b\\), and \\(c \\leq b\\), the following equality holds:\nDjuric, Petar, and Cédric Richard. 2018. Cooperative and Graph Signal Processing: Principles and Applications. Academic Press.\n\n\\[\\mathbb{E} \\bigg[ \\big({\\bf S}^a{\\bf y}\\big)\\Big(\\big({\\bf S}^H)^b {\\bf y}\\Big)^H  \\bigg]=\\mathbb{E}\\bigg[\\big({\\bf S}^{a+c}{\\bf y}\\big)\\Big(\\big({\\bf S}^H\\big)^{b-c}{\\bf y} \\Big)^H \\bigg].\\]\n\n\n\n\n\n\nNote\n\n\n\nUsing \\({\\bf S}\\) as the periodic shift operator \\({\\bf S}=\\begin{cases} 1 & j-j = 1 \\\\ 0 & o.w.\\end{cases}.\\), the definition is equivalent to the traditional stationarity definition in time series analysis.\n\n\n\nConjugate\n\\(E(y)=0\\)을 가정하고, \\(y = (y_1,y_2)\\)의 벡터를 가정했을 때,\n\\(Cov(y) = \\begin{pmatrix} cov(y_1,y_2) & cov(y_1,y_2) \\\\ cov(y_2,y_1) & cov(y_2,y_2) \\end{pmatrix}\\)\n\n\\(cov(y_1,y_1) = V(y_1) = E(y_1 - \\mu_1)^2 = E(y_1)^2 (\\therefore \\mu = 0)\\)\n\\(cov(y_2,y_1) = E(y_2 - \\mu_2)E(y_1 - \\mu_1) = E(y_2-y_1)\\)\n\\(cov(y_2,y_2) = V(y_2) = E(y_2 - \\mu_2)^2 = E(y_2)^2 (\\therefore \\mu = 0)\\)\n\\(cov(y_1,y_2) = E(y_1 - \\mu_1)E(y_2 - \\mu_2) = E(y_1-y_2)\\)\n\n\\(= E \\begin{pmatrix} y_1^2 & y_1y_2 \\\\ y_2 y_1 & y_2^2 \\end{pmatrix} = E(y y^\\top)\\)\n\\(y = (y_q y_2)^\\top\\)\n\\(y^\\top = (y_1,y_2)\\)\n\\(y y^\\top = \\begin{bmatrix} y1 \\\\ y_2 \\end{bmatrix} \\begin{bmatrix} y2 & y_2 \\end{bmatrix} = \\begin{bmatrix} y_1^2 & y_1y_2 \\\\ y_2y_1 & y_2^2 \\end{bmatrix}\\)\n\\(cov(y) = E(y t^\\top) = E(y y^H)\\) -&gt; 확률변수가 복소수일 경우 가정 가능하다\n\\(cov(y\\text{의 } a \\text{만큼 평행이동}) = cov(y\\text{의 } b \\text{만큼 평행이동})\\)\n\\(cov((S^ay)(S^b y)^\\top) = cov((S^c y)(S^d y)^\\top)\\)\n\n결국, normal GSO가 주어질 때, \\(y\\)는 약정상성을 S에 대해 가지고 있다는 말이 된다.\n정상성 조건: 평균, 분산이 일정할때, 자기 공분산이 시차 t에만 의존할 때"
  },
  {
    "objectID": "posts/2_Studies/EPT/2024-01-07-EPT_review.html",
    "href": "posts/2_Studies/EPT/2024-01-07-EPT_review.html",
    "title": "[EPT]Review(EPT: An R package for ensemble patch transform)",
    "section": "",
    "text": "R\n\ninstall.(EPT)\n\nERROR: Error in library(EPT): there is no package called ‘EPT’\n\n\n다변량 신호의 다중척도 분석을 위한 새로운 방법론 제시\none-dimensional signals 및 two-dimensional images에 대한 다중척도 분석을 위해 제안\n\npatch process\n\n다양한 패치 크기에 따라 데이터의 로컬 특성을 추출하고 요약하는 역할\n\nensemble process.\n\n신호의 시간적 변동을 효과적으로 나타내기 위해 패치의 위치를 변환\n원래 다중 스케일 특성을 가지고 있음.\n\n\n두 프로세스로 구성됌.\n다양한 필터(비선형 필터 포함)를 디자인할 수 있어 로컬 특성 및 스케일 패턴을 식별하는 데 유용\n유연한 필터 디자인을 통해 신호 분해에 적용 가능\nR packag 내용\n\neptransf()\nmeptransf()\neptplot()\neptdecomp()\neptransf2d()\nmeptransf2d()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Seoyeon",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nMar 1, 2024\n\n\n[GPT] Models\n\n\nSEOYEON CHOI\n\n\n\n\nJan 10, 2024\n\n\nDay5: 실습64 - 실습??\n\n\n최규빈 \n\n\n\n\nJan 7, 2024\n\n\n[EPT]Review(EPT: An R package for ensemble patch transform)\n\n\nSEOYEON CHOI\n\n\n\n\nJan 5, 2024\n\n\nDSTBX2023(4)\n\n\nSEOYEON CHOI\n\n\n\n\nJan 4, 2024\n\n\nDSTBX2023(3)\n\n\nSEOYEON CHOI\n\n\n\n\nJan 3, 2024\n\n\nDSTBX2023(2)\n\n\nSEOYEON CHOI\n\n\n\n\nJan 2, 2024\n\n\nDSTBX2023(1)\n\n\nSEOYEON CHOI\n\n\n\n\nDec 31, 2023\n\n\n[Note] Tips of Linux, Git and Blog\n\n\nSEOYEON CHOI\n\n\n\n\nNov 22, 2023\n\n\n[Note] DGX station 설정_메모 추가\n\n\nGUEBIN CHOI\n\n\n\n\nJul 2, 2023\n\n\nGraph Shift Operator\n\n\nSEOYEON CHOI\n\n\n\n\nJul 1, 2023\n\n\nNon-Euclidean vs Euclidean\n\n\nSEOYEON CHOI\n\n\n\n\nJun 30, 2023\n\n\nGraph Signal\n\n\nSEOYEON CHOI\n\n\n\n\nJun 30, 2023\n\n\nRegular Graph\n\n\nSEOYEON CHOI\n\n\n\n\nJan 15, 2023\n\n\n[CGSP] Chap 12.4: Node Subsampling for PSD Estimation\n\n\n신록예찬 \n\n\n\n\nDec 31, 2022\n\n\nStudy for Spaces\n\n\nSEOYEON CHOI\n\n\n\n\nDec 27, 2022\n\n\n[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators\n\n\n신록예찬 \n\n\n\n\nDec 26, 2022\n\n\n[CGSP] Chap 12.2: Weakly Stationary Graph Processes\n\n\n신록예찬 \n\n\n\n\nDec 24, 2022\n\n\n[CGSP] Chap 8.3: Discrete Fourier Transform\n\n\n신록예찬 \n\n\n\n\nDec 7, 2022\n\n\nA1: 깊은복사와 얕은복사 (12주차)\n\n\nSEOYEON CHOI\n\n\n\n\nApr 4, 2022\n\n\nIntroduction to Python 5wk\n\n\nSEOYEON CHOI\n\n\n\n\nMar 23, 2022\n\n\nIntroduction to Python 4wk\n\n\nSEOYEON CHOI\n\n\n\n\nApr 26, 2019\n\n\n[Essays] 퓨리에 변환\n\n\n신록예찬 \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "2_gpt.html",
    "href": "2_gpt.html",
    "title": "GPT",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nMar 1, 2024\n\n\n[GPT] Models\n\n\nSEOYEON CHOI\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Lectures_ing",
      "**Studies**",
      "GPT"
    ]
  },
  {
    "objectID": "posts/2_Studies/GPT/2024-01-03-GPT_study.html",
    "href": "posts/2_Studies/GPT/2024-01-03-GPT_study.html",
    "title": "[GPT] Models",
    "section": "",
    "text": "# bibliography: ref.bib\n\n\nflowchart\n\n\n\n\n\nflowchart LR\n    Aid1([Real\\nData]):::base --&gt; B[Experiment 1]:::ex1\n    Cid1([Real\\nData]):::base & Eid1([Synthetic\\nData]):::base --&gt; D[Experiment 2]:::ex2\n    Fid1([Synthetic\\nData]):::base --&gt; G[Experiment 3]:::ex3\n    classDef ex1 fill:#34cceb\n    classDef ex2 fill:#34eb64\n    classDef ex3 fill:#eb9e34\n    classDef base fill:#faf9f7\n\n\n\n\n\n\n\n\nImprot\n\nimport pandas as pd\n\n\n\nWeightedEnsembleModel(Caruana et al. 2004)\n\nCaruana, Rich, Alexandru Niculescu-Mizil, Geoff Crew, and Alex Ksikes. 2004. “Ensemble Selection from Libraries of Models.” In Proceedings of the Twenty-First International Conference on Machine Learning, 18.\nWeighted ensemble meta-model that implements Ensemble Selection\nhttps://auto.gluon.ai/0.8.1/tutorials/multimodal/text_prediction/beginner_text.html#other-examples\n\n%matplotlib inline\n\nimport numpy as np\nimport warnings\nimport matplotlib.pyplot as plt\n\nwarnings.filterwarnings('ignore')\nnp.random.seed(123)\n\n\nfrom autogluon.core.utils.loaders import load_pd\ntrain_data = load_pd.load('https://autogluon-text.s3-accelerate.amazonaws.com/glue/sst/train.parquet')\ntest_data = load_pd.load('https://autogluon-text.s3-accelerate.amazonaws.com/glue/sst/dev.parquet')\nsubsample_size = 1000  # subsample data for faster demo, try setting this to larger values\ntrain_data = train_data.sample(n=subsample_size, random_state=0)\ntrain_data.head(10)\n\nLoaded data from: https://autogluon-text.s3-accelerate.amazonaws.com/glue/sst/train.parquet | Columns = 2 / 2 | Rows = 67349 -&gt; 67349\nLoaded data from: https://autogluon-text.s3-accelerate.amazonaws.com/glue/sst/dev.parquet | Columns = 2 / 2 | Rows = 872 -&gt; 872\n\n\n\n\n\n\n\n\n\nsentence\nlabel\n\n\n\n\n43787\nvery pleasing at its best moments\n1\n\n\n16159\n, american chai is enough to make you put away the guitar , sell the amp , and apply to medical school .\n0\n\n\n59015\ntoo much like an infomercial for ram dass 's latest book aimed at the boomer\n0\n\n\n5108\na stirring visual sequence\n1\n\n\n67052\ncool visual backmasking\n1\n\n\n35938\nhard ground\n0\n\n\n49879\nthe striking , quietly vulnerable personality of ms. ambrose\n1\n\n\n51591\npan nalin 's exposition is beautiful and mysterious , and\n1\n\n\n56780\nwonderfully loopy\n1\n\n\n28518\nmost beautiful , evocative\n1\n\n\n\n\n\n\n\n\nfrom autogluon.multimodal import MultiModalPredictor\nimport uuid\nmodel_path = f\"./tmp/{uuid.uuid4().hex}-automm_sst\"\npredictor = MultiModalPredictor(label='label', eval_metric='acc', path=model_path)\npredictor.fit(train_data, time_limit=180)\n\n=================== System Info ===================\nAutoGluon Version:  1.0.0\nPython Version:     3.11.5\nOperating System:   Linux\nPlatform Machine:   x86_64\nPlatform Version:   #86~20.04.2-Ubuntu SMP Mon Jul 17 23:27:17 UTC 2023\nCPU Count:          28\nPytorch Version:    2.0.1+cu117\nCUDA Version:       11.7\nMemory Avail:       139.10 GB / 251.39 GB (55.3%)\nDisk Space Avail:   457.17 GB / 915.32 GB (49.9%)\n===================================================\nAutoGluon infers your prediction problem is: 'binary' (because only two unique label-values observed).\n    2 unique label values:  [1, 0]\n    If 'binary' is not the correct problem_type, please manually specify the problem_type parameter during predictor init (You may specify problem_type as one of: ['binary', 'multiclass', 'regression'])\n\nAutoMM starts to create your model. ✨✨✨\n\nTo track the learning progress, you can open a terminal and launch Tensorboard:\n    ```shell\n    # Assume you have installed tensorboard\n    tensorboard --logdir /home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst\n    ```\n\nINFO: Global seed set to 0\nGPU Count: 1\nGPU Count to be Used: 1\nGPU 0 Name: NVIDIA GeForce RTX 3090\nGPU 0 Memory: 0.0GB/23.69GB (Used/Total)\n\nINFO: Using 16bit Automatic Mixed Precision (AMP)\nINFO: GPU available: True (cuda), used: True\nINFO: TPU available: False, using: 0 TPU cores\nINFO: IPU available: False, using: 0 IPUs\nINFO: HPU available: False, using: 0 HPUs\nINFO: You are using a CUDA device ('NVIDIA GeForce RTX 3090') that has Tensor Cores. To properly utilize them, you should set `torch.set_float32_matmul_precision('medium' | 'high')` which will trade-off precision for performance. For more details, read https://pytorch.org/docs/stable/generated/torch.set_float32_matmul_precision.html#torch.set_float32_matmul_precision\nINFO: LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0]\nINFO: \n  | Name              | Type                         | Params\n-------------------------------------------------------------------\n0 | model             | HFAutoModelForTextPrediction | 108 M \n1 | validation_metric | MulticlassAccuracy           | 0     \n2 | loss_func         | CrossEntropyLoss             | 0     \n-------------------------------------------------------------------\n108 M     Trainable params\n0         Non-trainable params\n108 M     Total params\n435.573   Total estimated model params size (MB)\nINFO: Epoch 0, global step 3: 'val_acc' reached 0.54000 (best 0.54000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=0-step=3.ckpt' as top 3\nINFO: Epoch 0, global step 7: 'val_acc' reached 0.64500 (best 0.64500), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=0-step=7.ckpt' as top 3\nINFO: Epoch 1, global step 10: 'val_acc' reached 0.73000 (best 0.73000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=1-step=10.ckpt' as top 3\nINFO: Epoch 1, global step 14: 'val_acc' reached 0.89000 (best 0.89000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=1-step=14.ckpt' as top 3\nINFO: Epoch 2, global step 17: 'val_acc' reached 0.89000 (best 0.89000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=2-step=17.ckpt' as top 3\nINFO: Epoch 2, global step 21: 'val_acc' reached 0.88500 (best 0.89000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=2-step=21.ckpt' as top 3\nINFO: Epoch 3, global step 24: 'val_acc' was not in top 3\nINFO: Epoch 3, global step 28: 'val_acc' reached 0.91000 (best 0.91000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=3-step=28.ckpt' as top 3\nINFO: Epoch 4, global step 31: 'val_acc' reached 0.90500 (best 0.91000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=4-step=31.ckpt' as top 3\nINFO: Epoch 4, global step 35: 'val_acc' was not in top 3\nINFO: Epoch 5, global step 38: 'val_acc' reached 0.90000 (best 0.91000), saving model to '/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst/epoch=5-step=38.ckpt' as top 3\nINFO: Epoch 5, global step 42: 'val_acc' was not in top 3\nINFO: Epoch 6, global step 45: 'val_acc' was not in top 3\nINFO: Epoch 6, global step 49: 'val_acc' was not in top 3\nINFO: Epoch 7, global step 52: 'val_acc' was not in top 3\nINFO: Epoch 7, global step 56: 'val_acc' was not in top 3\nINFO: Epoch 8, global step 59: 'val_acc' was not in top 3\nINFO: Epoch 8, global step 63: 'val_acc' was not in top 3\nStart to fuse 3 checkpoints via the greedy soup algorithm.\nAutoMM has created your model. 🎉🎉🎉\n\nTo load the model, use the code below:\n    ```python\n    from autogluon.multimodal import MultiModalPredictor\n    predictor = MultiModalPredictor.load(\"/home/csy/Dropbox/sy_hub/posts/2_Studies/GPT/tmp/6e8112a4b9be49ada3aab9f73a63cb61-automm_sst\")\n    ```\n\nIf you are not satisfied with the model, try to increase the training time, \nadjust the hyperparameters (https://auto.gluon.ai/stable/tutorials/multimodal/advanced_topics/customization.html),\nor post issues on GitHub (https://github.com/autogluon/autogluon/issues).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;autogluon.multimodal.predictor.MultiModalPredictor at 0x7f186bb7cb50&gt;\n\n\n\ntest_score = predictor.evaluate(test_data)\nprint(test_score)\n\n\n\n\n{'acc': 0.8922018348623854}\n\n\n\ntest_score = predictor.evaluate(test_data, metrics=['acc', 'f1'])\nprint(test_score)\n\n\n\n\n{'acc': 0.8922018348623854, 'f1': 0.8929384965831435}\n\n\n\nsentence1 = \"it's a charming and often affecting journey.\"\nsentence2 = \"It's slow, very, very, very slow.\"\npredictions = predictor.predict({'sentence': [sentence1, sentence2]})\nprint('\"Sentence\":', sentence1, '\"Predicted Sentiment\":', predictions[0])\nprint('\"Sentence\":', sentence2, '\"Predicted Sentiment\":', predictions[1])\n\n\n\n\n\"Sentence\": it's a charming and often affecting journey. \"Predicted Sentiment\": 1\n\"Sentence\": It's slow, very, very, very slow. \"Predicted Sentiment\": 0\n\n\n\nprobs = predictor.predict_proba({'sentence': [sentence1, sentence2]})\nprint('\"Sentence\":', sentence1, '\"Predicted Class-Probabilities\":', probs[0])\nprint('\"Sentence\":', sentence2, '\"Predicted Class-Probabilities\":', probs[1])\n\n\n\n\n\"Sentence\": it's a charming and often affecting journey. \"Predicted Class-Probabilities\": [5.8611616e-04 9.9941385e-01]\n\"Sentence\": It's slow, very, very, very slow. \"Predicted Class-Probabilities\": [0.98935777 0.01064222]\n\n\n\ntest_predictions = predictor.predict(test_data)\ntest_predictions.head()\n\n\n\n\n0    1\n1    1\n2    1\n3    1\n4    0\nName: label, dtype: int64\n\n\n\n\nfrom autogluon.core.models import WeightedEnsembleModel\n\n\nmodel_path = f\"./tmp/{uuid.uuid4().hex}-automm_sst\"\npredictor = WeightedEnsembleModel(label='label', eval_metric='acc', path=model_path)\npredictor.fit(train_data, time_limit=180)\n\nTypeError: BaggedEnsembleModel.__init__() missing 1 required positional argument: 'model_base'\n\n\n\ntest_score = predictor.evaluate(test_data)\nprint(test_score)\n\n\n\n\n{'acc': 0.8922018348623854}\n\n\n\ntest_score = predictor.evaluate(test_data, metrics=['acc', 'f1'])\nprint(test_score)\n\n\n\n\n{'acc': 0.8922018348623854, 'f1': 0.8929384965831435}\n\n\n\nsentence1 = \"it's a charming and often affecting journey.\"\nsentence2 = \"It's slow, very, very, very slow.\"\npredictions = predictor.predict({'sentence': [sentence1, sentence2]})\nprint('\"Sentence\":', sentence1, '\"Predicted Sentiment\":', predictions[0])\nprint('\"Sentence\":', sentence2, '\"Predicted Sentiment\":', predictions[1])\n\n\n\n\n\"Sentence\": it's a charming and often affecting journey. \"Predicted Sentiment\": 1\n\"Sentence\": It's slow, very, very, very slow. \"Predicted Sentiment\": 0\n\n\n\nprobs = predictor.predict_proba({'sentence': [sentence1, sentence2]})\nprint('\"Sentence\":', sentence1, '\"Predicted Class-Probabilities\":', probs[0])\nprint('\"Sentence\":', sentence2, '\"Predicted Class-Probabilities\":', probs[1])\n\n\n\n\n\"Sentence\": it's a charming and often affecting journey. \"Predicted Class-Probabilities\": [5.8611616e-04 9.9941385e-01]\n\"Sentence\": It's slow, very, very, very slow. \"Predicted Class-Probabilities\": [0.98935777 0.01064222]\n\n\n\ntest_predictions = predictor.predict(test_data)\ntest_predictions.head()\n\n\n\n\n0    1\n1    1\n2    1\n3    1\n4    0\nName: label, dtype: int64"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html",
    "href": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html",
    "title": "[CGSP] Chap 12.2: Weakly Stationary Graph Processes",
    "section": "",
    "text": "using LinearAlgebra, DSP"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#simultaneously-diagonalizable",
    "href": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#simultaneously-diagonalizable",
    "title": "[CGSP] Chap 12.2: Weakly Stationary Graph Processes",
    "section": "Simultaneously Diagonalizable",
    "text": "Simultaneously Diagonalizable\n매트릭스 \\({\\bf A}\\)와 \\({\\bf B}\\)가 대각화 가능하다는 것은 아래의 표현을 만족하는 적당한 invertible matrix \\({\\bf \\Psi}_A\\), \\({\\bf \\Psi}_B\\)와 대각행렬 \\({\\bf \\Lambda}_A\\), \\({\\bf \\Lambda}_B\\)가 존재한다는 의미가 된다.\n\\[{\\bf A} = {\\bf V}_{A} {\\bf \\Lambda}_A {\\bf V}_{A}^{-1}\\]\n\\[{\\bf B} = {\\bf V}_{B} {\\bf \\Lambda}_B {\\bf V}_{B}^{-1}\\]\n그리고 만약에 \\({\\bf V}_{A}={\\bf V}_{B}\\)이라면 즉\n\\[{\\bf A} = {\\bf V} {\\bf \\Lambda}_A {\\bf V}^{-1}\\]\n\\[{\\bf B} = {\\bf V} {\\bf \\Lambda}_B {\\bf V}^{-1}\\]\n이라면 \\(\\{{\\bf A},{\\bf B}\\}\\)가 simultaneously diagonalzable 하다고 표현한다."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#commute",
    "href": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#commute",
    "title": "[CGSP] Chap 12.2: Weakly Stationary Graph Processes",
    "section": "Commute",
    "text": "Commute\n두 matrix \\({\\bf A}\\)와 \\({\\bf B}\\)에 대하여\n\\[{\\bf A}{\\bf B}= {\\bf B}{\\bf A}\\]\n인 관계가 성립하면 두 매트릭스가 commute 한다고 표현한다. 그런데 \\({\\bf A}{\\bf B}={\\bf A}{\\bf B}\\)의 조건은 \\({\\bf A}, {\\bf B}\\)가 동시대각화가능할 (simultaneously diagonalzable) 조건과 같다. 1 따라서 simultaneously diagonalzable 는 commute와 같은 말이라 생각해도 무방하다.\n1 필요충분조건이다.\n참고: 위키피디아.."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#shift-invariant-filter",
    "href": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#shift-invariant-filter",
    "title": "[CGSP] Chap 12.2: Weakly Stationary Graph Processes",
    "section": "Shift Invariant Filter",
    "text": "Shift Invariant Filter\n\nref: Djuric and Richard (2018) Chap 8.3 의 내용 중 일부\n\nDjuric, Petar, and Cédric Richard. 2018. Cooperative and Graph Signal Processing: Principles and Applications. Academic Press.\n\nDefine the matrix \\({\\bf B}\\) as periodic shift matrix such that\n\\[\n{\\bf B} = \\begin{bmatrix}\n0 & 0 & 0 & \\dots  & 0 & 1 \\\\\n1 & 0 & 0 & \\dots & 0 & 0 \\\\\n0 & 1 & 0 & \\dots & 0 & 0 \\\\\n\\dots & \\dots & \\dots & \\dots & \\dots & \\dots\\\\\n0 & 0 & \\dots & 1 & 0 & 0 \\\\\n0 & 0 & \\dots & 0 & 1 & 0 \\\\\n\\end{bmatrix}.\\]\nA generic filter \\({\\boldsymbol h}\\) is given by its \\(z\\)-transform\n\\[h(z)=h_0z^0+h_1z^{-1}+\\cdots +h_{N-1}z^{-(N-1)}\\]\nwhere \\(s_{n-1}=z^{-1}s_n\\). In vector notation, and with respect to the standard basis \\({\\bf I}\\), the filter is represented by the matrix \\({\\bf H}\\), a polynomial in the cyclic shift\n\\[{\\bf H}=h({\\bf B})=h_0{\\bf B}^0+h_1{\\bf B}^1+\\cdots+h_{N-1}{\\bf B}^{N-1}.\\]\nFilters are shift invariant iff\n\\[z\\cdot h(z) = h(z)\\cdot z\\]\nor from the matrix representation\n\\[{\\bf B}h({\\bf B})=h({\\bf B}){\\bf B}.\\]\nExample\nLet \\({\\bf B}\\) as\n\nB= [0 1 0 0 0 0 0\n    0 0 1 0 0 0 0 \n    0 0 0 1 0 0 0 \n    0 0 0 0 1 0 0 \n    0 0 0 0 0 1 0 \n    0 0 0 0 0 0 1 \n    1 0 0 0 0 0 0]\n\n7×7 Matrix{Int64}:\n 0  1  0  0  0  0  0\n 0  0  1  0  0  0  0\n 0  0  0  1  0  0  0\n 0  0  0  0  1  0  0\n 0  0  0  0  0  1  0\n 0  0  0  0  0  0  1\n 1  0  0  0  0  0  0\n\n\nDefine \\({\\boldsymbol h}\\) as\n\nh = [1/3,1/3,1/3]\n\n3-element Vector{Float64}:\n 0.3333333333333333\n 0.3333333333333333\n 0.3333333333333333\n\n\nFurthermore define \\({\\bf H}=h({\\bf B})=h_0{\\bf B}^0+h_1{\\bf B}^1+h_2{\\bf B}^2\\)\n\nH = (1/3)*B^0 + (1/3)*B^1 + (1/3)*B^2 \n\n7×7 Matrix{Float64}:\n 0.333333  0.333333  0.333333  0.0       0.0       0.0       0.0\n 0.0       0.333333  0.333333  0.333333  0.0       0.0       0.0\n 0.0       0.0       0.333333  0.333333  0.333333  0.0       0.0\n 0.0       0.0       0.0       0.333333  0.333333  0.333333  0.0\n 0.0       0.0       0.0       0.0       0.333333  0.333333  0.333333\n 0.333333  0.0       0.0       0.0       0.0       0.333333  0.333333\n 0.333333  0.333333  0.0       0.0       0.0       0.0       0.333333\n\n\nObserve following:\n\nB*H == H*B \n\ntrue\n\n\nThus, filter \\({\\boldsymbol h}\\) is shift invariant filter and matrix \\({\\bf H}\\) is shift invariant operator.\nnote: \\({\\boldsymbol h}\\) is moving average filter.\nnote: for any \\({\\bf x}\\), \\({\\bf H}{\\bf x}\\) is definded by\n\\[\\left[\\frac{x_{n-1}+x_n+x_1}{3},\\frac{x_n+x_1+x_2}{3},\\dots,\\frac{x_{n-3}+x_{n-2}+x_n}{3}\\right].\\]\n\nx = [1,1,1,1,2,2,2]\nH*x\n\n7-element Vector{Float64}:\n 1.0\n 1.0\n 1.3333333333333333\n 1.6666666666666665\n 2.0\n 1.6666666666666665\n 1.3333333333333333\n\n\nnote: In some sense, the matrix \\({\\bf H}{\\bf x}\\) can be thought as generalized version of \\({\\boldsymbol h}\\star {\\bf x}\\) where \\(\\star\\) is convolution up to shift\n\nconv(h,x)\n\n9-element Vector{Float64}:\n 0.3333333333333334\n 0.6666666666666667\n 1.0\n 1.0\n 1.3333333333333333\n 1.6666666666666667\n 2.0\n 1.3333333333333333\n 0.6666666666666667\n\n\nFinally, we observe that, from the Cayley-Hamilton Theorem, \\({\\bf B}\\) satisfies its characteristic polynomial \\(\\Delta({\\bf B})\\), where \\(\\Delta(\\lambda)\\) is the determinant of \\(\\lambda{\\bf I}-{\\bf B}\\). The characteristic polynomial \\(\\Delta({\\bf B})\\) has degree \\(N\\), so, in DSP, as described so far, linear filters are (matrix) polynomial with degree at most \\(N-1\\).\n\n이 부분은 책에 써있길래 가져오긴 했는데, 무슨 의미인지 모르겠음"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#coexisting-approaches",
    "href": "posts/2_Studies/GRAPH/2022-12-26-Chap-12.2.html#coexisting-approaches",
    "title": "[CGSP] Chap 12.2: Weakly Stationary Graph Processes",
    "section": "Coexisting Approaches",
    "text": "Coexisting Approaches\nStationary graph processes were first defined and analyzed in (Girault 2015). The fundamental problem identified there is that GSOs do not preserve energy in general and therefore cannot be isometric (Gavili and Zhang 2017). This problem is addressed in (Girault, Gonçalves, and Fleury 2015) with the definition of an isometric graph shift that preserves the eigenvector space of the Laplacian GSO but modifies its eigenvalues.\n\nGirault, Benjamin. 2015. “Stationary Graph Signals Using an Isometric Graph Translation.” In 2015 23rd European Signal Processing Conference (EUSIPCO), 1516–20. IEEE.\n\nGavili, Adnan, and Xiao-Ping Zhang. 2017. “On the Shift Operator, Graph Frequency, and Optimal Filtering in Graph Signal Processing.” IEEE Transactions on Signal Processing 65 (23): 6303–18.\n\nGirault, Benjamin, Paulo Gonçalves, and Éric Fleury. 2015. “Translation on Graphs: An Isometric Shift Operator.” IEEE Signal Processing Letters 22 (12): 2416–20.\nA stationary graph process is then defined as one whose probability distributions are invariant with respect to multiplications with the isometric shift. One drawback of this approach is that the isometric shift is a complex-valued operator and has a sparsity structure (if any) different from \\({\\bf S}\\). By contrast, the vertex-based definition in\n\\[\\mathbb{E} \\bigg[ \\big({\\bf S}^a{\\bf x}\\big)\\Big(\\big({\\bf S}^H)^b {\\bf x}\\Big)^H  \\bigg]=\\mathbb{E}\\bigg[\\big({\\bf S}^{a+c}{\\bf x}\\big)\\Big(\\big({\\bf S}^H\\big)^{b-c}{\\bf x} \\Big)^H \\bigg]\\]\nis based on the original GSO \\({\\bf S}\\), which is local and real-valued. As a result, above Eq. provides intuition on the relations between stationarity and locality, which can be leveraged to develop stationarity tests or estimation schemes that work with local information. Graph stationarity was also studied in (Perraudin and Vandergheynst 2017) where the requirement of having a covariance matrix diagonalizable by the eigenvectors of the Laplacian GSO is adopted as a definition. This condition is shown to be equivalent to statistical invariance with respect to the translation operator introduced in (Shuman, Ricaud, and Vandergheynst 2016). When the shift \\({\\bf S}\\) coincides with the Laplacian of the graph and the eigenvalues of \\({\\bf S}\\) are all distinct, Definitions 12.1 and 12.2 are equivalent to those in Perraudin and Vandergheynst (2017). Hence, the definitions presented here differ from (Perraudin and Vandergheynst 2017) in that we consider general normal shifts instead of Laplacians and that we see Definition 12.1 as a definition, not a property. These are mathematically minor differences that are important in practice though; see Segarra et al. (2017) for more details.\n\nPerraudin, Nathanaël, and Pierre Vandergheynst. 2017. “Stationary Signal Processing on Graphs.” IEEE Transactions on Signal Processing 65 (13): 3462–77.\n\nShuman, David I, Benjamin Ricaud, and Pierre Vandergheynst. 2016. “Vertex-Frequency Analysis on Graphs.” Applied and Computational Harmonic Analysis 40 (2): 260–91.\n\nSegarra, Santiago, Antonio G Marques, Gonzalo Mateos, and Alejandro Ribeiro. 2017. “Network Topology Inference from Spectral Templates.” IEEE Transactions on Signal and Information Processing over Networks 3 (3): 467–83."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "",
    "text": "using LinearAlgebra, Plots, FFTW, Statistics"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#kronecker-product",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#kronecker-product",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "Kronecker product",
    "text": "Kronecker product\n크로네커곱의 정의는 아래와 같다.\n\\[{\\bf A} \\otimes {\\bf B}\n=\\begin{bmatrix}\na_{11}{\\bf B} & a_{12}{\\bf B} & \\dots & a_{1m}{\\bf B} \\\\\na_{21}{\\bf B} & a_{22}{\\bf B} & \\dots & a_{2m}{\\bf B} \\\\\n\\dots & \\dots & \\dots & \\dots \\\\\na_{n1}{\\bf B} & a_{n2}{\\bf B} & \\dots & a_{nm}{\\bf B} \\\\\n\\end{bmatrix}\\]\n두 행렬 \\({\\bf A}_{m\\times n}\\), \\({\\bf B}_{p\\times q}\\)의 크로네커곱 \\({\\bf A}\\otimes {\\bf B}\\)의 차원은 \\(mp \\times nq\\) 가 된다. 계산예시는 아래와 같다.\n\n\n\n위키에서 긁은 예제, 글씨가 좀 작음\n\n\n크로네커곱에 대한 성질들이 위키에 많이 있으니 참고하면 좋다.\n(예제1)\n\nA= [1 2\n    3 4]\nB= [0 5\n    6 7]\nC = kron(A, B)\n\n4×4 Matrix{Int64}:\n  0   5   0  10\n  6   7  12  14\n  0  15   0  20\n 18  21  24  28\n\n\n(예제2)\n\nA= [1 -4 7; -2 3 3]\nB= [8 -9 -6 -5; 1 -3 -4 7; 2 8 -8 -3; 1 2 -5 -1]\nC = kron(A, B)\n\n8×12 Matrix{Int64}:\n   8   -9  -6   -5  -32   36   24   20  56  -63  -42  -35\n   1   -3  -4    7   -4   12   16  -28   7  -21  -28   49\n   2    8  -8   -3   -8  -32   32   12  14   56  -56  -21\n   1    2  -5   -1   -4   -8   20    4   7   14  -35   -7\n -16   18  12   10   24  -27  -18  -15  24  -27  -18  -15\n  -2    6   8  -14    3   -9  -12   21   3   -9  -12   21\n  -4  -16  16    6    6   24  -24   -9   6   24  -24   -9\n  -2   -4  10    2    3    6  -15   -3   3    6  -15   -3"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#khatrirao-product",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#khatrirao-product",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "Khatri–Rao product",
    "text": "Khatri–Rao product\n카트리-라오곱은 매트릭스 \\({\\bf A}\\)와 \\({\\bf B}\\)가 같은 차원의 블락매트릭스로 정의될때 각 서브매트릭스의 크로네커 곱으로 정의된다. 정의와 계산예시는 아래와 같다.\n\n\n\n예시1: 위키에서 긁은 그림\n\n\n또 다른 계산예시는 아래와 같다. 이 예제는 중요하니까 구현해보자.\n\n\n\n예시2: 위키에서 긁은 그림\n\n\n(예제1)\n\nC= [1 2 3 \n    4 5 6 \n    7 8 9] \nD= [1 4 7\n    2 5 8\n    3 6 9]\n\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\n\n\nhcat([kron(C[:,i],D[:,i]) for i in 1:3]...)\n\n9×3 Matrix{Int64}:\n  1   8  21\n  2  10  24\n  3  12  27\n  4  20  42\n  8  25  48\n 12  30  54\n  7  32  63\n 14  40  72\n 21  48  81\n\n\n이건 자주 쓸일이 있을것 같으니까 함수로 저장하자.\n\ncolumnwise_kron = \n(C,D) -&gt; hcat([kron(C[:,i],D[:,i]) for i in 1:size(C)[2]]...)\n\n#181 (generic function with 1 method)\n\n\n\ncolumnwise_kron(C,D)\n\n9×3 Matrix{Int64}:\n  1   8  21\n  2  10  24\n  3  12  27\n  4  20  42\n  8  25  48\n 12  30  54\n  7  32  63\n 14  40  72\n 21  48  81"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#그래프-표현",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#그래프-표현",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "그래프 표현",
    "text": "그래프 표현\n아래의 그림을 살펴보자.\n\n\n\n그래프의 개념을 이해하는 필요한 그림, 일단 오른쪽의 \\({\\bf S}\\)는 무시할 것\n\n\n오른쪽의 \\({\\bf S}\\)는 무시하고 왼쪽의 그래프만 살펴보자. 이 그림에는 6개의 노드가 있고 각각의 노드는 저 마다의 연결구조를 가진다. 이러한 연결구조는 \\({\\bf G}=({\\bf N},{\\bf E})\\) 으로 표현할 수 있는데 여기에서 \\({\\bf N}\\)은 노드들의 집합이고 \\({\\bf E}\\)는 엣지들의 집합이다.1 보통 \\({\\cal E}\\)는 복잡하므로 연결정보를 매트릭스 \\({\\bf E}\\)로 표현하는데 이러한 \\({\\bf E}\\)를 인접행렬이라고 부른다. 인접행렬의 각 원소는 \\(E_{ij}= \\begin{cases} 1 & (i,j) \\in {\\cal E} \\\\ 0 & o.w \\end{cases}\\) 와 같이 정의한다. 이 그림의 경우 \\({\\cal N}\\) 와 \\({\\cal E}\\), \\({\\bf E}\\) 는 아래와 같다.\n1 노드 \\(i\\)에서 노드 \\(j\\)로 향하는 연결이 있다면 \\((i,j) \\in {\\cal E}\\)이다.\n\\({\\cal N}=\\{1,2,3,4,5,6\\}\\)\n\\({\\bf E}=\\begin{bmatrix} 0 & 1 & 0 & 0 & 1 & 0 \\\\ 1 & 0 & 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\end{bmatrix}\\)\n\\({\\cal E} = \\{(i,j) : E_{ij}=1 \\}\\)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#gso",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#gso",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "GSO",
    "text": "GSO\n후에 자세히 서술하겠지만 전통적인 시계열분석기법을 그래프신호로 확장하기 위해서는 단지 퓨리에변환 대신에 그래프퓨리에 변환을 사용하면 된다. 즉 퓨리에변환을 일반화한 그래프퓨리에변환을 잘 정의하면 된다.\n전통적인 신호처리 영역에서의 퓨리에변환은 시계열자료의 인접성을 의미하는 행렬 \\({\\bf B}\\)2의 고유행렬의 켤레전치로 정의할 수 있다. 이를 이용하면 그래프 퓨리에변환은 그래프자료의 인접성을 의미하는 행렬3의 고유행렬의 켤레전치로 정의할 수 있음을 유추할 수 있다. 즉 비유클리드 자료에서도 \\({\\bf B}\\)에 대응하는 어떠한 매트릭스가 정의되어야 하는데 (그리고 이 매트릭스는 그래프자료의 인접성에 대한 정보가 있어야 한다) 이 매트릭스를 \\({\\bf S}\\)라고 정의하고 grahp shift operator (GSO) 라고 이름 붙인다.\n2 원래는 평행이동을 의미하는 행렬이지만, 이걸 인접성을 의미하는 행렬로 해석할 수도 있다. 어차피 인접한 곳으로 이동할 수 있으니까..3 예를들면 인접행렬 \\({\\bf E}\\)와 같은 행렬주어진 그래프 \\({\\cal G}=({\\cal N},{\\cal E})\\) 에 대하여 GSO \\({\\bf S}\\)는 \\({\\bf E}+{\\bf I}\\)의 값이 1인 영역에만 값이 있는 어떠한 행렬이다. 다시 아래의 그림을 생각하여 보자.\n\n\n\nGSO의 개념을 이해하는데 필요한 그림\n\n\n왼쪽그래프의 GSO는 오른쪽과 같은 행렬 \\({\\bf S}\\)가 된다. 이제 \\({\\bf S}\\) 의 고유벡터행렬을 구한 뒤에 그것의 켤레전치를 \\({\\bf GFT}\\) 행렬로 정의하면 될 것 같다. 문제는 “\\({\\bf S}\\)의 고유벡터행렬이 항상 존재하는가?” 인데, 사실 이게 항상 존재한다는 보장이 없다. 즉 \\({\\bf S}\\)의 고유벡터 행렬이 존재 안할 수도 있다. 따라서 GSO \\({\\bf S}\\)가 고유분해가능하다는 조건이 추가적으로 필요한데 이러한 조건을 만족하는 GSO를 normal GSO라고 부른다. 우리는 당연히 normal GSO에 대해서만 관심이 있으므로 앞으로 특별한 언급이 없는한 GSO는 모두 normal GSO라고 가정한다."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#periodogram-correlogram-and-ls-estimator",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#periodogram-correlogram-and-ls-estimator",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "Periodogram, correlogram, and LS estimator",
    "text": "Periodogram, correlogram, and LS estimator\nFrom \\({\\bf C}_{\\tilde{\\bf x}}:= \\mathbb{E}\\left[\\tilde{\\bf x}\\tilde{\\bf x}^H \\right]=\\mathbb{E}\\left[({\\bf V}^H{\\bf x})({\\bf V}^H{\\bf x})^H \\right]=\\text{diag}({\\bf p})\\) it follows that one may express the PSD as \\({\\bf p}=\\mathbb{E}\\left[|{\\bf V}^H{\\bf x}|^2\\right]\\). That is, the PSD is given by the expected value of the squared frequency components of the random process. This leads to a natural approach for the estimation of \\({\\bf p}\\) from a finite set of \\(R\\) realizations of the process \\({\\bf x}\\). Indeed, we compute the \\({\\bf GFT} \\tilde{\\bf x}_r = {\\bf V}^H{\\bf x}_r\\) of each observed signal \\({\\bf x}_r\\) and estimate \\({\\bf p}\\) as\n\\[\n\\hat{\\bf p}_{pg}:= \\frac{1}{R}\\sum_{r=1}^R|\\tilde{\\bf x}_r|^2=\\frac{1}{R}\\sum_{r=1}^{R}|{\\bf V}^H{\\bf x}_{r}|^2.\n\\]\nThe estimator \\(\\hat{\\bf p}_{pg}\\) is termed periodogram due to its evident similarity with its homonym5 in classical estimation. It is simple to show that \\({\\bf p}_{pg}\\) is an unbiased estimator, that is, \\(\\mathbb{E}[\\hat{\\bf p}_{pg}]= {\\bf p}\\). A more detailed analysis of the performance of \\(\\hat{\\bf p}_{pg}\\), for the case where the observations are Gaussian, is given in Proposition 12.1.6\n5 동음이의어6 Proposition 12.1은 뒤에 다루는데 \\(\\hat{\\bf p}_{pg}\\)의 분산에 대한 서술이 있음. 분산은 \\(\\mathbb{V}[\\hat{\\bf p}_{pg}]=\\frac{2}{R}\\text{diag}^2({\\bf p})\\)와 같음An alternative nonparametric estimation scheme, denominated correlogram, can be devised by starting from the definition of \\({\\bf p}\\) in\n\\[{\\bf p}:=\\text{diag}\\big({\\bf V}^H {\\bf C}_{\\bf x}{\\bf V} \\big).\\]\nNamely, one may substitute \\({\\bf C}_{\\bf x}\\) in above equation by the sample covariance \\(\\hat{\\bf C}_{\\bf x} = \\frac{1}{R}\\sum_{r=1}^R{\\bf x}_r{\\bf x}_r^H\\) computed based on the available observations to obtain\n\\[\\hat{\\bf p}_{cg}:= \\text{diag}\\left({\\bf V}^H \\hat{\\bf C}_{\\bf x}{\\bf V} \\right):=\\text{diag}\\left[{\\bf V}^H\\big[ \\frac{1}{R}\\sum_{r=1}^R{\\bf x}_r{\\bf x}_r^H\\big]{\\bf V} \\right].\\]\nNotice that the matrix \\({\\bf V}^H\\hat{\\bf C}_{\\bf x}{\\bf V}\\) is in general, not diagonal because the eigenbasis of \\(\\hat{\\bf C}_{\\bf x}\\) differs from \\({\\bf V}\\), the eigenbasis of \\({\\bf C}_{\\bf x}\\). Nonetheless, we keep only the diagonal elements \\({\\bf v}_i^H \\hat{\\bf C}_{\\bf x}{\\bf v}_i\\) for \\(i = 1, \\dots , N\\) as our PSD estimator. It can be shown that the correlogram \\({\\bf p}_{cg}\\) and the periodogram \\({\\bf p}_{pg}\\) lead to identical estimators, as is the case in classical signal processing.\nThe correlogram can also be interpreted as an LS estimator. The decomposition in \\({\\bf C}_{\\bf x}={\\bf V}\\text{diag}({\\bf p}){\\bf V}^H\\) allows a linear parameterization of the covariance matrix \\({\\bf C}_{\\bf x}\\) as\n\\[\n{\\bf C}_{\\bf x}({\\bf p})=\\sum_{i=1}^N p_i{\\bf v}_i{\\bf v}_i^H.\n\\]\nThis linear parametrization will also be useful for the sampling schemes developed in Section 12.4. Vectorizing \\({\\bf C}_{\\bf x}\\) in \\({\\bf C}_{\\bf x}({\\bf p})=\\sum_{i=1}^N p_i{\\bf v}_i{\\bf v}_i^H\\) results in a set of \\(N^2\\) equations in \\({\\bf p}\\)\n\\[\n{\\bf c}_{\\bf x} = \\text{vec}({\\bf C}_{\\bf x})=\\sum_{i=1}^{N}p_i \\text{vec}({\\bf v}_i{\\bf v}_i^H)={\\bf G}_{np}{\\bf p},\n\\]\nwhere \\(\\text{vec}({\\bf v}_i{\\bf v}_i^H)={\\bf v}_i^\\ast \\otimes {\\bf v}_i\\). Relying on the Khatri-Rao product, we then form the \\(N^2 \\times N\\) matrix \\({\\bf G}_{np}\\) as\n\\[\n{\\bf G}_{np}:= \\left[{\\bf v}_1^\\ast \\otimes {\\bf v}_1, \\dots, {\\bf v}_N^\\ast \\otimes {\\bf v}_N \\right] = {\\bf V}^\\ast \\odot {\\bf V}.\n\\]\n\nHere \\(\\otimes\\) denote the Kronecker matrix product and \\(\\odot\\) denote the Khatri-Rao matrix product.\n\nUsing the sample covariance matrix \\(\\hat{\\bf C}_{\\bf x}\\) as an estimate of \\({\\bf C}_{\\bf x}\\), we can match the estimated covariance vector \\(\\hat{\\bf c}_{\\bf x}=\\text{vec}(\\hat{\\bf C}_{\\bf x})\\) to the true covariance vector \\({\\bf c}_{\\bf x}\\) in the LS sense as\n\\[\n\\hat{\\bf p}_{ls} = \\underset{\\bf p}{\\operatorname{argmin}} \\|\\hat{\\bf c}_{\\bf x}-{\\bf G}_{np}{\\bf p}\\|_2^2=({\\bf G}_{np}^H{\\bf G}_{np})^{-1}{\\bf G}_{np}^H\\hat{\\bf c}_{\\bf x}.\n\\]\nIn other words, the LS estimator minimizes the squared error \\(\\text{tr}\\left[\\big(\\hat{\\bf C}_{\\bf x} − \\hat{\\bf C}_{\\bf x}({\\bf p})\\big)^T \\big(\\hat{\\bf C}_{\\bf x} − \\hat{\\bf C}_{\\bf x}({\\bf p})\\big)\\right]\\). From expression \\(\\hat{\\bf p}_{ls} = \\underset{\\bf p}{\\operatorname{argmin}} \\|\\hat{\\bf c}_{\\bf x}-{\\bf G}_{np}{\\bf p}\\|_2^2=({\\bf G}_{np}^H{\\bf G}_{np})^{-1}{\\bf G}_{np}^H\\hat{\\bf c}_{\\bf x}\\) it can be shown that the \\(i\\)th element of \\(\\hat{\\bf p}_{ls}\\) is \\({\\bf v}_i^H \\hat{\\bf C}_{\\bf x} {\\bf v}_i\\). Combining this with Eq.\n\\[\\hat{\\bf p}_{cg}:= \\text{diag}\\left({\\bf V}^H \\hat{\\bf C}_{\\bf x}{\\bf V} \\right):=\\text{diag}\\left[{\\bf V}^H\\big[ \\frac{1}{R}\\sum_{r=1}^R{\\bf x}_r{\\bf x}_r^H\\big]{\\bf V} \\right]\\]\nwe get that the LS estimator \\(\\hat{\\bf p}_{ls}\\) and the correlogram \\(\\hat{\\bf p}_{cg}\\) —and hence the periodogram as well— are all identical estimators. The estimators derived in this subsection do not assume any data distribution and are well suited for cases where the data probability density function is not available. In what follows, we provide performance bounds for these estimators under the condition that the observed signals are Gaussian."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#정상시계열을-분석하는-두-가지-흐름-acf와-psd",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#정상시계열을-분석하는-두-가지-흐름-acf와-psd",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "정상시계열을 분석하는 두 가지 흐름, ACF와 PSD",
    "text": "정상시계열을 분석하는 두 가지 흐름, ACF와 PSD\n\n전통적인 분석방법\n클래식한 정상시계열은 유한차수의 ARMA로 근사할 수 있음이 알려져 있다7. 유한차수의 ARMA의 계수 \\(p\\),\\(q\\)를 적절하게 추정하기 위해서는 시계열 \\({\\bf x}\\)를 SACF plot 혹은 SPACF plot 을 이용하면 된다. 이때 SACF 혹은 SPACF 의 그림을 살펴보고 적절한 모형을 선택하기 위해서는 유한차수 ARMA의 이론적 ACF의 모양을 알면 되는데,8 이를 바꾸어서 말하면 결국 정상시계열 \\({\\bf x}\\)의 모든 정보는 ACF에 들어있다는 의미가 된다. 즉 정상시계열은 ACF만 잘 추정하면 모든 것이 해결된다.\n7 Wold’s theorem8 예를들어 “coef가 0.9인 AR(1)의 경우 lag=1 에 대한 이론적 ACF값이 0.9, lag=2에 대한 ACF값이 0.81, … 와 같이 되더라~” 하는식의그런데 ACF의 모든 정보는 다시 아래의 행렬에 들어있다.\n\\[{\\bf C}_{\\bf x}=\\mathbb{E}[{\\bf x}{\\bf x}^T]\\]\n여기에서 \\({\\bf x}\\)는 realization이 아니라 확률벡터를 의미함을 유의하자.9 따라서 정상시계열의 경우 \\({\\bf C}_{\\bf x}\\)를 잘 추정하면 모든것이 해결된다고 생각하면 된다.\n9 보통 수리통계에서는 확률변수를 \\(X\\) realization을 \\(x\\)로 표현하지만 여기에서는 매트릭스를 대문자로 쓰고 있어서 그런식으로 표현하기 어렵다, 그래서 그때 그때 이것이 확률변수인지 realization인지 따져봐야 한다\n참고: 정상시계열의 경우 ACF 만 정확하게 알아도 (반대로 PACF만 정확하게 알아도) 이론상 모든 모형을 특정할 수 있다. 즉 정상시계열의 모형을 특정하기 위해서는 ACF plot, PACF plot 하나만 있어도 충분하다. (Wold’s Thm은 떠올리면 모든 정상시계열은 무한MA로 유니크하게 표현할 수 있는데, 이는 PACF plot을 가지고 모든 정상시계열을 유니크하게 특정할 수 있다는 것을 의미한다) 다만 좀 더 모형을 특정하는 과정을 용이하게 하기 위해서 실전에서는 SACF plot 과 SPACF plot 을 함께 보는 것이 유리하다.\n\n(예제) AR(1) 모형\n왜 ACF의 모든정보를 \\({\\bf C}_{\\bf x}\\)로 부터 알수 있는지 코드를 통하여 실습하여 보자. (바로 이해된다면 사실 이 예제는 스킵해도 무방함) 아래와 같은 모형을 가정하자.\n\\[x_{t} = 0.5 x_{t-1} +\\epsilon_t\\]\n여기에서 \\(\\epsilon_t\\)는 서로 독립인 표준정규분포를 따른다. 이 모형에서 길이가 100인 시계열을 임의로 발생시키자.\n\nx = zeros(100*1000)\nx[1] = randn()\nfor t in 2:100\n    x[t] = 0.5*x[t-1] + randn()\nend\n\n모형에서 생성된 하나의 시계열을 시각화 하면 아래와 같다.\n\nplot(x) # 그냥 그려본것임. 별 의미는 없음\n\n\n\n\n\n\n\n\nlag=1일 경우 이 시계열의 SACF를 계산하면 아래와 같다.\n\nx[1:99] .* x[2:100]\n\n99-element Vector{Float64}:\n  1.587897526021493\n  1.130306190921068\n  0.5698214432110668\n  0.4648189302568683\n  0.3099446153360606\n  0.36362604534744775\n  0.8191871414624922\n -0.1720390842292145\n -0.06301214708310766\n  0.026414715508855904\n -0.007988283356933327\n -0.04178812545299474\n  0.22453267567940685\n  ⋮\n  3.931333581073927\n  1.315564948810858\n  0.9096080102581454\n  0.5410986320348997\n  0.29627801400693676\n  1.0673283524686212\n -1.0394649044573636\n  2.80195248208142\n  4.152973765526384\n  2.316315764368524\n  0.978758337765867\n -0.5840281943972468\n\n\n\n이 계산결과는 각 \\(t\\)에 대하여 \\(x_{t-1}x_t\\) 를 계산한 것과 같다.\n\n이 수열들의 평균은 아래와 같다.\n\nx[1:99] .* x[2:100] |&gt; mean\n\n0.5835563885014224\n\n\n\n이 계산결과는 \\(\\frac{1}{99}\\sum_{t=2}^{100} x_{t-1}x_t\\)를 계산한 것과 같다.\n\n이론적인 값인 0.5 근처의 값이 잘 나옴을 알 수 있다.\nlag=2일 경우도 마찬가지로 구할 수 있다.\n\nx[1:98] .* x[3:100] |&gt; mean\n\n0.38420263596668275\n\n\n이러한 숫자들은 그런데 \\({\\bf x}{\\bf x}^T\\)를 이용하여서도 구할 수 있다.10\n10 참고로 여기에서 \\({\\bf x}\\)는 확률벡터가 아니라 realization을 의미함\nx*x'\n\n100×100 Matrix{Float64}:\n  0.760108    1.5879      0.541064   …  -1.57394    -0.472676    0.939172\n  1.5879      3.31719     1.13031       -3.28802    -0.987441    1.96197\n  0.541064    1.13031     0.385143      -1.12037    -0.336463    0.668527\n  0.800507    1.67229     0.569821      -1.65759    -0.497799    0.989089\n  0.441361    0.922022    0.314172      -0.913915   -0.274462    0.545336\n  0.533784    1.1151      0.379961   …  -1.10529    -0.331936    0.659531\n  0.517803    1.08171     0.368586      -1.0722     -0.321998    0.639786\n  1.20252     2.51212     0.855987      -2.49003    -0.747794    1.48581\n -0.108745   -0.227173   -0.0774074      0.225175    0.0676234  -0.134363\n  0.440444    0.920106    0.313519      -0.912016   -0.273892    0.544203\n  0.0455859   0.0952309   0.0324492  …  -0.0943935  -0.0283478   0.0563249\n -0.133198   -0.278257   -0.0948139      0.27581     0.0828298  -0.164577\n  0.238468    0.498169    0.169748      -0.493789   -0.148292    0.294646\n  ⋮                                  ⋱                          \n  2.04697     4.2762      1.45708       -4.2386     -1.27291     2.52919\n  0.488514    1.02053     0.347736      -1.01155    -0.303784    0.603596\n  1.41531     2.95665     1.00746    …  -2.93065    -0.880119    1.74873\n  0.290602    0.60708     0.206858      -0.601742   -0.180712    0.359062\n  0.774954    1.61891     0.551632      -1.60468    -0.481908    0.957516\n  1.04688     2.18698     0.745197      -2.16775    -0.651007    1.2935\n -0.754723   -1.57665    -0.537231       1.56279     0.469328   -0.932519\n -2.82194    -5.89516    -2.00873    …   5.84333     1.75484    -3.48673\n -1.11863    -2.33686    -0.796269       2.31632     0.695624   -1.38215\n -1.57394    -3.28802    -1.12037        3.25911     0.978758   -1.94472\n -0.472676   -0.987441   -0.336463       0.978758    0.293936   -0.584028\n  0.939172    1.96197     0.668527      -1.94472    -0.584028    1.16042\n\n\n여기에서 각 원소들이 의미하는 바는 아래와 같다.\n\n대각선의 원소: \\(x_t^2,~ t=1,2,\\dots,100\\) 을 의미\n대각선 한칸 위, 혹은 한칸 아래: \\(x_{t-1} x_t~ t=2,3,\\dots,100\\) 을 의미\n대각선 두칸 위, 혹은 두칸 아래: \\(x_{t-2} x_t~ t=3,4,\\dots,100\\) 을 의미\n\n\n\n\nx*x'의 계산결과를 캡쳐한 그림, 이것은 \\(\\hat{\\bf C}_{\\bf x}\\)를 의미함\n\n\n확인해보자.\nlag=1, 스크린샷의 노란색\n\n(x[1:99] .* x[2:100])[1:5]\n\n5-element Vector{Float64}:\n 1.587897526021493\n 1.130306190921068\n 0.5698214432110668\n 0.4648189302568683\n 0.3099446153360606\n\n\n\nlag1에 해당하는 숫자들임. 이는 스크린샷에서 노란색으로 표현된 1.589, 1.13031, 0.569821 … 등과 일치한다.\n\nlag=2, 스크린샷의 빨간색\n\n(x[1:98] .* x[3:100])[1:5]\n\n5-element Vector{Float64}:\n 0.5410642277088621\n 1.6722932576420804\n 0.3141719983177106\n 0.5621541352252872\n 0.30066534927151267\n\n\n\nlag2에 해당하는 숫자들임. 이는 스크린샷에서 빨간색으로 표현된 숫자들인 0.54164, 1.67229, 0.31417 … 등과 일치한다.\n\n\n\n스펙트럼 방법\n지금까지는 정상시계열일 경우 ACF를 이용한 간단한 분석방법을 다시 복습했다. 그리고 \\({\\bf C}_{\\bf x}\\)가 ACF를 구함에 필요한 모든정보를 가지고 있음을 이해했다. 한편 \\({\\bf C}_{\\bf x}\\)은 positive definite matrix 이므로 아래와 같이 분해가능하다.\n\\[{\\bf C}_{\\bf x} = {\\bf V} \\text{diag}({\\bf p}) {\\bf V}^H\\]\n이 수식표현을 잘 해석하면 \\({\\bf C}_{\\bf x}\\)의 모든 정보는 \\({\\bf V}\\)와 \\({\\bf p}\\)에 담겨있다는 사실을 이해할 수 있다. 그런데 정상시계열일 경우 한정하여 \\({\\bf C}_{x}\\)의 고유벡터행렬은 \\({\\bf B}\\)의 고유벡터행렬과 일치한다는 사실을 알고 있다. 따라서 \\({\\bf V}\\)는 \\({\\bf B}\\)로 부터 그냥 알 수 있는 정보이다. 따라서 \\({\\bf C}_{\\bf x}\\)의 모든 정보는 \\({\\bf p}\\)에 담겨있다는 사실을 알 수 있다. 이는 적절한 \\({\\bf p}\\)를 추정하는 일은 적절한 \\({\\bf C}_{\\bf x}\\)를 추정하는 것과 같다는 사실을 알려준다.\n요약하면 아래와 같다.\n\n임의의 정상시계열은 이론적인 ACF (혹은 PACF)를 잘 추정하면 유니크하게 특정할 수 있다. (Wold’s Thm)\nACF를 잘 추정한다는 말은 \\({\\bf C}_{\\bf x}\\)를 잘 추정한다는 의미이다.\n그런데 \\({\\bf p}\\)를 잘 추정하면 \\({\\bf C}_{\\bf x}\\)를 잘 추정하는 일이 된다.\n따라서 임의의 정상시계열은 \\({\\bf p}\\)를 잘 추정하면 유니크하게 특정할 수 있다는 결론을 얻는다.\n\n여기에서 \\({\\bf p}\\)를 power spectral density 라고 부른다. 일반적으로 정상시계열을 분석하기 위해서는 \\({\\bf C}_{\\bf x}\\)를 특정하거나, \\({\\bf p}\\)를 특정하면 되는데 여기에서 \\({\\bf p}\\)를 특정한뒤 \\({\\bf p}\\)로 부터 \\({\\bf C}\\)를 역으로 해석하는 방법론을 spectral analysis라고 부른다. 경우에 따라서 \\({\\bf C}_{\\bf x}\\)를 특정하는 것이 용이할 수도 있지만 \\({\\bf p}\\)를 특정하고 해석하는 것이 용이할 때도 있다.\n그렇다면 주어진 시계열 \\({\\bf x}\\)에 대하여 \\({\\bf p}\\)를 어떻게 구할까? 직관적으로 생각하면 단순히 아래의 알고리즘으로 구하면 된다는 것을 알 수 있다.\n\n\\({\\bf C}_{\\bf x}\\)를 알아낸다.\n\\({\\bf C}_{\\bf x}\\)를 고유분해하여 \\({\\bf p}\\)를 구한다.\n\n또 다른 방법으로는 교재에 소개된 바 있는 아래의 수식을 이용하는 것이다.11\n11 이 수식이 성립하는 이유는 조금 손으로 써보면 금방 알 수 있음\\[{\\bf p}=\\mathbb{E}\\left[|{\\bf V}^H{\\bf x}|^2\\right]\\]\n이것을 이용하면 아래와 같은 알고리즘을 떠올릴 수 있다.\n\n\\({\\bf B}\\)의 고유벡터행렬 \\({\\bf V}\\)를 구하고 \\({\\bf V}^H{\\bf x}\\)를 계산한다.\n계산된 결과를 원소별로 제곱하여 \\({\\bf p}\\)를 얻는다.\n\n그런데 \\({\\bf V}^H{\\bf x}= {\\bf DFT} \\cdot {\\bf x}\\) 이므로 1의 과정을 아래와 같이 바꾸어 서술할 수 있다.\n\n\\({\\bf x}\\)를 퓨리에변환하여 \\(\\tilde{\\bf x} = {\\bf DFT} \\cdot {\\bf x}\\) 를 계산한다.\n\\(\\tilde{\\bf x}\\)를 원소별로 제곱하여 \\({\\bf p}\\)를 얻는다.\n\n즉 임의의 시계열을 퓨리에변환한 뒤 제곱하면 \\({\\bf p}\\)를 얻을 수 있다.\n(예제2) – 하나의 realization에서 \\(\\hat{\\bf p}\\)를 구해보자.\n(예제1에 이어서) 아래의 모형에서 생성된 \\({\\bf x}\\)를 다시 고려하자.\n\\[x_{t} = 0.5 x_{t-1} +\\epsilon_t\\]\n\nplot(x)\n\n\n\n\n\n\n\n\n이 자료의 PSD \\({\\bf p}\\)는 아래와 같이 구할 수 있다.\n단계1: \\({\\bf x}\\)의 DFT를 계산\n\nx̃ = fft(x) \n\n100-element Vector{ComplexF64}:\n  -5.756917285643583 + 0.0im\n   -19.0826720904921 - 1.0178306444775302im\n  14.230506824768984 - 11.867854578089997im\n  3.8980118254428726 + 1.2603018602424614im\n -16.157973053188194 + 27.488246322270918im\n   12.32574209329046 - 1.5134316695905219im\n    3.95421224972561 + 15.369129638224624im\n   9.516938110507798 + 19.371467179753544im\n  -19.38292930624831 + 9.49506288623419im\n  -7.853934851478428 + 4.134711886071571im\n -14.072349901900408 - 5.945064076174294im\n -14.596266922162355 + 3.447776409279256im\n   5.857720447482927 + 5.738895112838594im\n                     ⋮\n   5.857720447482924 - 5.738895112838594im\n -14.596266922162352 - 3.4477764092792564im\n -14.072349901900408 + 5.945064076174294im\n   -7.85393485147843 - 4.134711886071569im\n -19.382929306248315 - 9.49506288623419im\n   9.516938110507798 - 19.37146717975354im\n  3.9542122497256105 - 15.36912963822462im\n  12.325742093290458 + 1.5134316695905206im\n -16.157973053188194 - 27.488246322270925im\n  3.8980118254428717 - 1.260301860242461im\n  14.230506824768984 + 11.867854578089993im\n -19.082672090492103 + 1.0178306444775296im\n\n\n\n\\({\\bf B}\\)를 설정하고 고유값분해 하기 귀찮아서 그냥 DFT해주는 패키지 사용함\n\n단계2: \\(\\hat{\\bf p}\\)를 계산\n\np̂ = abs.(x̃).^2\n\n100-element Vector{Float64}:\n   33.14209663374188\n  365.18435333408365\n  343.3532967764883\n   16.782856970223087\n 1016.6837790613963\n  154.21439356883184\n  251.84594035243464\n  465.8258516955045\n  465.85416770456163\n   78.78013503208902\n  233.37481863133453\n  224.93817023139349\n   67.24780595702228\n    ⋮\n   67.24780595702225\n  224.93817023139337\n  233.37481863133453\n   78.78013503208902\n  465.8541677045618\n  465.8258516955044\n  251.84594035243452\n  154.2143935688318\n 1016.6837790613968\n   16.782856970223072\n  343.3532967764882\n  365.1843533340838\n\n\n참고\nfft(x) 대신에 아래의 코드를 이용해도 된다.\n\nN = 100 \nV = [i*j for i in 0:(N-1) for j in 0:(N-1)] |&gt; \n    x -&gt; reshape(x,(N,N)) .|&gt; \n    x -&gt; exp(im * (2π/N) * x)\nV'x\n\n100-element Vector{ComplexF64}:\n  -5.756917285643587 + 0.0im\n -19.082672090492103 - 1.0178306444775291im\n   14.23050682476898 - 11.867854578090007im\n  3.8980118254428824 + 1.2603018602424476im\n  -16.15797305318818 + 27.48824632227092im\n   12.32574209329044 - 1.5134316695905325im\n  3.9542122497256385 + 15.369129638224617im\n    9.51693811050782 + 19.371467179753516im\n  -19.38292930624826 + 9.495062886234233im\n -7.8539348514784155 + 4.134711886071595im\n -14.072349901900417 - 5.945064076174276im\n -14.596266922162371 + 3.447776409279244im\n   5.857720447482956 + 5.7388951128385735im\n                     ⋮\n   5.857720447482839 - 5.738895112838781im\n -14.596266922162307 - 3.4477764092792627im\n  -14.07234990190023 + 5.945064076174198im\n  -7.853934851478599 - 4.134711886071242im\n -19.382929306248577 - 9.49506288623372im\n   9.516938110507212 - 19.371467179753736im\n  3.9542122497250025 - 15.369129638224603im\n  12.325742093290597 + 1.5134316695903638im\n  -16.15797305318867 - 27.488246322270854im\n  3.8980118254424903 - 1.2603018602428118im\n  14.230506824769146 + 11.867854578089572im\n   -19.0826720904922 + 1.0178306444775123im\n\n\n진짜 똑같은지 확인\n\nfft(x)\n\n100-element Vector{ComplexF64}:\n  -5.756917285643583 + 0.0im\n   -19.0826720904921 - 1.0178306444775302im\n  14.230506824768984 - 11.867854578089997im\n  3.8980118254428726 + 1.2603018602424614im\n -16.157973053188194 + 27.488246322270918im\n   12.32574209329046 - 1.5134316695905219im\n    3.95421224972561 + 15.369129638224624im\n   9.516938110507798 + 19.371467179753544im\n  -19.38292930624831 + 9.49506288623419im\n  -7.853934851478428 + 4.134711886071571im\n -14.072349901900408 - 5.945064076174294im\n -14.596266922162355 + 3.447776409279256im\n   5.857720447482927 + 5.738895112838594im\n                     ⋮\n   5.857720447482924 - 5.738895112838594im\n -14.596266922162352 - 3.4477764092792564im\n -14.072349901900408 + 5.945064076174294im\n   -7.85393485147843 - 4.134711886071569im\n -19.382929306248315 - 9.49506288623419im\n   9.516938110507798 - 19.37146717975354im\n  3.9542122497256105 - 15.36912963822462im\n  12.325742093290458 + 1.5134316695905206im\n -16.157973053188194 - 27.488246322270925im\n  3.8980118254428717 - 1.260301860242461im\n  14.230506824768984 + 11.867854578089993im\n -19.082672090492103 + 1.0178306444775296im\n\n\n\n\n전통적인 방법과 스펙트럼 방법의 비교\n시계열자료의 전통적인 분석과 spectral analysis는 대충 아래의 과정으로 비교 설명할 수 있다.\n\n\n\n\n\n\n\n\n단계\n전통적인 방법\n스펙트럴 분석\n\n\n\n\n1\n\\({\\bf x}\\)의 plot을 그려봄\n\\({\\bf x}\\)의 plot을 그려봄\n\n\n2\nSACF plot, SPACF plot 을 그려봄\nPSD plot을 그려봄\n\n\n3\nACF를 추정 (=ARMA(\\(p\\),\\(q\\))에 대응하는 파라메터를 추정)\n\\({\\bf p}\\)를 추정\n\n\n4\n추정된 파라메터를 바탕으로 여러가지 분석 수행\n추정된 파라메터를 바탕으로 여러가지 분석 수행\n\n\n\n눈여겨 볼 점은 PSD plot의 존재이다. 전통적인 시계열에서 SACF plot 과 비슷하게 스펙트럼 방법에서 시계열을 분석하기 위해 필요한 매우 중요한 시각화 이다. 간단하게 비교를 하면 아래와 같다.\nSACF plot\n\nx축: lag=0, lag=1, ….\ny축: lag에 대응하는 상관계수값\n\nPSD plot\n\nx축: \\(\\Omega=\\big\\{\\frac{k}{N}:~ \\text{for}~ k=0,\\dots, N-1\\big\\}\\), 정규화된 freq를 의미함\ny축: 주파수에 대응하는 power값\n\n전통적인 방법에 비하여 스펙트럴 분석이 가지는 장점은 위의 표에서 소개한 일반적인 분석루틴이 시계열이 아닌 그래프신호로 쉽게 확장가능 하다는 점이다12. 따라서 앞으로는 전통적인 시계열 분석방법 대신 스펙트럴 분석만을 다룰 것이다. 스펙트럴 분석의 핵심적인 부분은 \\({\\bf p}\\)를 추정하는 방법과 추정량의 점근적 성질들을 파악하는 것이다. 이 포스트에서는 \\({\\bf p}\\)를 추정하는 방법만을 다룬다.\n12 퓨리에 변환대신에 그래프 퓨리에 변환을 이용하기만 하면된다"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#그래프신호에서의-psd의-추정",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#그래프신호에서의-psd의-추정",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "그래프신호에서의 PSD의 추정",
    "text": "그래프신호에서의 PSD의 추정\n이제 그래프 신호에서 \\({\\bf p}\\)를 추정하는 방법에 대하여 살펴보자. 그래프이동변환 (Graph Shift Operator, GSO)13 \\({\\bf S}={\\bf V}{\\bf \\Lambda}{\\bf V}^H\\)에 대하여 정상인 시계열 \\({\\bf x}\\)를 고려한다. 이 신호의 그래프퓨리에 변환14은 아래와 같이 구할 수 있다.\n13 Back shift operator의 일반화 버전14 좀 더 정확하게는 \\({\\bf V}^H\\) 에 대한 그래프 변환이라고 한다\\[\\tilde{\\bf x}={\\bf GFT} {\\bf x} = {\\bf V}^H{\\bf x}\\]\n여기에서 \\(\\tilde{\\bf x}\\)를 \\({\\bf x}\\)의 주파수응답(frequency representation)이라고 부른다.15 우리는 아래의 수식에서 \\({\\bf p}\\)의 값에 관심이 있다.\n15 이 \\(\\tilde{\\bf x}\\)를 그냥 graph Fourier transform이라고 부르는 사람도 많다. 즉 그래프퓨리에변환이 (1) 변환매트릭스 \\({\\bf GFT}\\)자체를 지칭할때도 있고 (2) 트랜스폼된 결과 \\(\\tilde{\\bf x}\\)를 지칭할때도 있음. 교재에서는 변환은 graph Fourier transform, 그리고 변환된 결과는 \\({\\bf x}\\)의 주파수응답이라고 한다.\\[{\\bf C}_{\\bf x}={\\bf V} \\text{diag}({\\bf p}){\\bf V}^H\\]\n여기에서 \\({\\bf p}\\)를 PSD (power spectrum density) 라고 한다. \\({\\bf p}\\)가 포함된 표현식은 위의 수식 이외에도 2개가 더 있다. 이를 모두 요약하면 아래와 같다16\n16 약간의 계산을 통하면 1,2,3이 쉽게 같은 수식임을 알 수 있음\n\\({\\bf C}_{\\bf x}={\\bf V} \\text{diag}({\\bf p}){\\bf V}^H\\)17\n\\({\\bf p}=\\mathbb{E}\\left[|{\\bf V}^H{\\bf x}|^2\\right]\\)\n\\({\\bf c}_{\\bf x} = \\sum_{i=1}^{N}p_i \\text{vec}({\\bf v}_i{\\bf v}_i^H) = {\\bf G}_{np} {\\bf p}\\)\n\n17 이 수식을 살짝 정리하면 \\({\\bf p}=\\text{diag}\\big({\\bf V}^H {\\bf C}_{\\bf x}{\\bf V} \\big)\\) 와 같이 보다 예쁜 수식을 얻을 수 있음위의 표현중 3.에서 \\({\\bf c}_{\\bf x}\\)은 \\({\\bf C}_x\\)를 벡터화한 것이며 \\({\\bf G}_{np}\\)는 \\({\\bf V}^\\ast\\) 와 \\({\\bf V}\\)를 열별-크로네커곱 (column-wise Kronecker product) 이다. 이때 \\({\\bf G}_{np}\\)의 정의가 조금 생소하니 한번 계산하여 보자.\n(예제) 아래와 같은 GSO \\({\\bf B}\\)를 고려하자.\n\nB= [0 1 0 0 \n    0 0 1 0 \n    0 0 0 1 \n    1 0 0 0]\n\n4×4 Matrix{Int64}:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n 1  0  0  0\n\n\n이러한 GSO에 대하여 \\({\\bf G}_{np}\\)는 아래와 같이 구할 수 있다.\n(1) \\({\\bf V}\\)를 정의\n\nV = [i*j for i in 0:3 for j in 0:3] |&gt; \n    x -&gt; reshape(x,(4,4)) .|&gt; \n    x -&gt; exp(im * (2π/4) * x) \n\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im           1.0+0.0im          …           1.0+0.0im\n 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im\n 1.0+0.0im          -1.0+1.22465e-16im             -1.0+3.67394e-16im\n 1.0+0.0im  -1.83697e-16-1.0im              5.51091e-16+1.0im\n\n\n(2) \\({\\bf G}_{np}={\\bf V}^{\\ast} \\odot {\\bf V}\\), 여기에서 \\(\\odot\\)은 열별-크로네커곱을 의미한다.\n\n# columnwise_kron은 위에서 정의한적 있음~\nGₙₚ = columnwise_kron(conj(V),V)\n\n16×4 Matrix{ComplexF64}:\n 1.0+0.0im           1.0+0.0im          …           1.0+0.0im\n 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im\n 1.0+0.0im          -1.0+1.22465e-16im             -1.0+3.67394e-16im\n 1.0+0.0im  -1.83697e-16-1.0im              5.51091e-16+1.0im\n 1.0+0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im\n 1.0+0.0im           1.0+0.0im          …           1.0+0.0im\n 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im\n 1.0+0.0im          -1.0+1.22465e-16im             -1.0+3.67394e-16im\n 1.0+0.0im          -1.0-1.22465e-16im             -1.0-3.67394e-16im\n 1.0+0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im\n 1.0+0.0im           1.0+0.0im          …           1.0+0.0im\n 1.0+0.0im   6.12323e-17+1.0im             -1.83697e-16-1.0im\n 1.0+0.0im  -1.83697e-16+1.0im              5.51091e-16-1.0im\n 1.0+0.0im          -1.0-1.22465e-16im             -1.0-3.67394e-16im\n 1.0+0.0im   6.12323e-17-1.0im             -1.83697e-16+1.0im\n 1.0+0.0im           1.0+0.0im          …           1.0+0.0im\n\n\n위에서 언급한 표현식 1,2,3 을 이용하면 \\({\\bf p}\\)를 추정하는 세 가지 방법을 각각 정의할 수 있다. 하나씩 살펴보자.\n\n1. \\({\\bf C}_{\\bf x}={\\bf V} \\text{diag}({\\bf p}){\\bf V}^H\\)\n확률과정 \\({\\bf x}\\)에서 \\(R\\)개의 realization \\(\\{{\\bf x}_1 \\dots {\\bf x}_R\\}\\) 을 관측하였다고 하자. 수식 \\({\\bf C}_{\\bf x}={\\bf V} \\text{diag}({\\bf p}){\\bf V}^H\\)를 적당히 변형하면 아래를 얻을 수 있다.\n\\[{\\bf p}=\\text{diag}\\big({\\bf V}^H {\\bf C}_{\\bf x}{\\bf V} \\big)\\]\n여기에서\n\\[{\\bf C}_{\\bf x}=\\mathbb{E}[{\\bf x}{\\bf x}^H]\\approx \\frac{1}{R}\\sum_{r=1}^R{\\bf x}_t{\\bf x}_r^H\\]\n이므로 이 수식에 근거하여 \\({\\bf p}\\)을 추정한다면 아래와 같이 할 수 있다.\n\\[\\hat{\\bf p}_{cg}:= \\text{diag}\\left({\\bf V}^H \\hat{\\bf C}_{\\bf x}{\\bf V} \\right):=\\text{diag}\\left[{\\bf V}^H\\big[ \\frac{1}{R}\\sum_{r=1}^R{\\bf x}_r{\\bf x}_r^H\\big]{\\bf V} \\right].\\]\n만약에 확률과정 \\({\\bf x}\\)에서 관측한 시계열이 \\({\\bf x}_r\\) 하나라면18, 즉 \\(R=1\\) 이라면 단순히 아래와 같이 쓸 수 있다.\n18 대부분은 관측한 시계열이 하나겠지..\\[\\hat{\\bf p}_{cg}:= \\text{diag}\\left({\\bf V}^H \\hat{\\bf C}_{\\bf x}{\\bf V} \\right):=\\text{diag}\\left[{\\bf V}^H{\\bf x}_r{\\bf x}_r^H{\\bf V} \\right].\\]\n\n주의: 여기에서 \\({\\bf V}^H {\\bf C}_{\\bf x}{\\bf V}\\) 는 항상 대각행렬이지만 \\({\\bf V}^H \\hat{\\bf C}_{\\bf x}{\\bf V}\\) 은 대각행렬이 아닐수도 있음을 유의하자. 즉 이론적인 모수는 대각행렬이지만 sample version은 대각행렬이 아닐 수 있다. 대각선이 아닌 원소는 버리면 된다.)\n\n\n아이디어: 혹시 대각선이 아닌 원소들을 이용하여 오차항 \\(\\epsilon_t\\)의 분산을 추정할 수도 있지 않을까? 이미 연구가 있겠지?\n\n(예제)\n\nN = 100 \nV = [i*j for i in 0:(N-1) for j in 0:(N-1)] |&gt; \n    x -&gt; reshape(x,(N,N)) .|&gt; \n    x -&gt; exp(im * (2π/N) * x)\n\n100×100 Matrix{ComplexF64}:\n 1.0+0.0im       1.0+0.0im        …       1.0+0.0im\n 1.0+0.0im  0.998027+0.0627905im     0.998027-0.0627905im\n 1.0+0.0im  0.992115+0.125333im      0.992115-0.125333im\n 1.0+0.0im  0.982287+0.187381im      0.982287-0.187381im\n 1.0+0.0im  0.968583+0.24869im       0.968583-0.24869im\n 1.0+0.0im  0.951057+0.309017im   …  0.951057-0.309017im\n 1.0+0.0im  0.929776+0.368125im      0.929776-0.368125im\n 1.0+0.0im  0.904827+0.425779im      0.904827-0.425779im\n 1.0+0.0im  0.876307+0.481754im      0.876307-0.481754im\n 1.0+0.0im  0.844328+0.535827im      0.844328-0.535827im\n 1.0+0.0im  0.809017+0.587785im   …  0.809017-0.587785im\n 1.0+0.0im  0.770513+0.637424im      0.770513-0.637424im\n 1.0+0.0im  0.728969+0.684547im      0.728969-0.684547im\n    ⋮                             ⋱  \n 1.0+0.0im  0.728969-0.684547im      0.728969+0.684547im\n 1.0+0.0im  0.770513-0.637424im      0.770513+0.637424im\n 1.0+0.0im  0.809017-0.587785im   …  0.809017+0.587785im\n 1.0+0.0im  0.844328-0.535827im      0.844328+0.535827im\n 1.0+0.0im  0.876307-0.481754im      0.876307+0.481754im\n 1.0+0.0im  0.904827-0.425779im      0.904827+0.425779im\n 1.0+0.0im  0.929776-0.368125im      0.929776+0.368125im\n 1.0+0.0im  0.951057-0.309017im   …  0.951057+0.309017im\n 1.0+0.0im  0.968583-0.24869im       0.968583+0.24869im\n 1.0+0.0im  0.982287-0.187381im      0.982287+0.187381im\n 1.0+0.0im  0.992115-0.125333im      0.992115+0.125333im\n 1.0+0.0im  0.998027-0.0627905im     0.998027+0.0627905im\n\n\n\np̂ = diag(V' * (x*x') * V)\n\n100-element Vector{ComplexF64}:\n 33.142096633741986 + 0.0im\n 365.18435333408354 + 1.5376069362644531e-13im\n  343.3532967764883 + 6.904176529646917e-14im\n 16.782856970223083 - 3.5538396658301444e-14im\n 1016.6837790613963 + 5.475049904926759e-15im\n 154.21439356883144 + 6.4512443306088e-14im\n  251.8459403524346 + 2.1316282072803006e-14im\n 465.82585169550384 + 1.816929057526117e-13im\n 465.85416770456044 + 4.1584439183295984e-14im\n    78.780135032089 + 1.3472456770553478e-14im\n 233.37481863133462 + 6.315728724701355e-14im\n 224.93817023139385 - 3.472109560086835e-14im\n  67.24780595702241 + 7.105427357601002e-14im\n                    ⋮\n   67.2478059570233 + 6.384723798533952e-14im\n 224.93817023139195 + 1.9727655769954595e-14im\n 233.37481863132837 - 2.1872689567834747e-14im\n    78.780135032089 + 1.917599080404094e-14im\n 465.85416770456294 + 4.808950231511622e-14im\n 465.82585169550094 - 4.890486289860305e-14im\n  251.8459403524291 + 2.0146681724568905e-14im\n  154.2143935688347 - 1.0948596967617507e-13im\n 1016.6837790614081 + 1.2114814701286432e-13im\n  16.78285697022108 + 2.376159104534641e-14im\n 343.35329677648286 + 1.1310381241837407e-14im\n 365.18435333408746 + 4.574214786667376e-14im\n\n\n\n\n2. \\({\\bf p}=\\mathbb{E}\\left[|{\\bf V}^H{\\bf x}|^2\\right]\\)\n확률과정 \\({\\bf x}\\)에서 \\(R\\)개의 realization \\(\\{{\\bf x}_1 \\dots {\\bf x}_R\\}\\) 을 관측하였다고 하자. 아래의 수식을 관찰하자.\n\\[{\\bf p}=\\mathbb{E}\\left[|{\\bf V}^H{\\bf x}|^2\\right]\\approx \\frac{1}{R}\\sum_{r=1}^{R} |{\\bf V}^H {\\bf x}_r|^2 \\]\n따라서 \\(\\frac{1}{R}\\sum_{r=1}^{R} |{\\bf V}^H {\\bf x}_r|^2\\) 를 PSD \\({\\bf p}\\)에 대한 추정량이라고 생각할 수 있다. 이러한 추정량을 기호로 \\(\\hat{\\bf p}_{pg}\\)라고 정의하고 periodogram이라고 부른다. 즉\n\\[\\hat{\\bf p}_{pg}=\\frac{1}{R}\\sum_{r=1}^{R} |{\\bf V}^H {\\bf x}_r|^2 \\]\n만약에 확률과정 \\({\\bf x}\\)에서 관측한 시계열이 \\({\\bf x}_r\\) 하나라면, 즉 \\(R=1\\) 이라면 단순히 아래와 같이 쓸 수 있다.\n\\[\\hat{\\bf p}_{pg}=|{\\bf V}^H {\\bf x}_r|^2 \\]\n즉 이 경우 \\(\\hat{\\bf p}_{pg}\\)는 단순히 관측시계열 \\({\\bf x}_r\\)의 그래프 퓨리에 변환 \\(\\tilde{\\bf x}={\\bf V}^H{\\bf x}_r\\) 결과에 절대값을 취하고 제곱한 것과 같다.\n(예제)\n스펙트럼방법챕터 예제2에서 이미 보여준 적 있다. 주어진 시계열 \\({\\bf x}\\)에 대하여 \\(\\hat{\\bf p}_{pg}\\)를 구하는 방법을 요약하면 아래와 같다.\n\nx̃ = fft(x) # 단계1: GFT, 이 신호는 시계열이라서 GFT대신에 DFT를 써도 된다.\np̂ = abs.(x̃).^2 # 단계2: hat p\n\n100-element Vector{Float64}:\n   33.14209663374188\n  365.18435333408365\n  343.3532967764883\n   16.782856970223087\n 1016.6837790613963\n  154.21439356883184\n  251.84594035243464\n  465.8258516955045\n  465.85416770456163\n   78.78013503208902\n  233.37481863133453\n  224.93817023139349\n   67.24780595702228\n    ⋮\n   67.24780595702225\n  224.93817023139337\n  233.37481863133453\n   78.78013503208902\n  465.8541677045618\n  465.8258516955044\n  251.84594035243452\n  154.2143935688318\n 1016.6837790613968\n   16.782856970223072\n  343.3532967764882\n  365.1843533340838\n\n\n\n\n3. \\({\\bf c}_{\\bf x} = {\\bf G}_{np} {\\bf p}\\)\n확률과정 \\({\\bf x}\\)에서 \\(R\\)개의 realization \\(\\{{\\bf x}_1 \\dots {\\bf x}_R\\}\\) 을 관측하였다고 하자. 아래의 수식을 관찰하자.\n\\[{\\bf C}_{\\bf x} = {\\bf V} \\text{diag}({\\bf p}) {\\bf V}^H\\]\n이 수식으로부터 아래를 얻을 수 있다.\n\\[{\\bf c}_{\\bf x} = \\sum_{i=1}^{N}p_i \\text{vec}({\\bf v}_i{\\bf v}_i^H) = {\\bf G}_{np} {\\bf p}\\]\n여기에서 \\({\\bf c}_{\\bf x}\\) 대신에 \\(\\hat{\\bf c}_{\\bf x}\\) 를 대입하면 아래와 같이 생각할 수 있다.\n\\[\\hat{\\bf c}_{\\bf x} \\approx  {\\bf G}_{np} {\\bf p}\\]\n이 문제는 아래와 같은 회귀모형으로 생각할 수 있다.\n\n\n\n\n\n\n\n\n\n회귀모형\n우리의 문제\n\n\n\n\n모형\n\\({\\bf y} \\approx {\\bf X}{\\boldsymbol \\beta}\\)\n\\(\\hat{\\bf c}_{\\bf x} \\approx {\\bf G}_{np}{\\bf p}\\)\n\n\n설명변수\n\\({\\bf X}\\)19\n\\({\\bf G}_{np}\\)20\n\n\n반응변수\n\\({\\bf y}\\)21\n\\(\\hat{\\bf c}_{\\bf x}\\)22\n\n\n추정하고 싶은 파라메터\n\\({\\boldsymbol \\beta}\\)23\n\\(\\hat{\\bf p}\\)24\n\n\n오차항\n대부분 정규분포를 가정\n??? 모르겠는데??\n\n\n\n19 (n,p) matrix20 (N²,N) matrix21 (n,1) col-vector22 (N²,1) col-vector23 (p,1) col-vector24 (N,1) col-vector회귀분석에서 아래의 수식이 익숙하다면\n\\[\n\\hat{\\boldsymbol \\beta}_{ls} = \\underset{\\boldsymbol \\beta}{\\operatorname{argmin}} \\|{\\bf y}-{\\bf X}{\\boldsymbol \\beta}\\|_2^2=({\\bf X}^T{\\bf X})^{-1}{\\bf X}^T{\\bf y}.\n\\]\n\\({\\bf p}\\)를 추정하기 위한 아래의 수식도 쉽게 이해할 수 있다. (의문: 그런데 왜 MSE를 손실함수로 쓰고 있는 거야? 오차항이 설마 정규분포?)\n\\[\n\\hat{\\bf p}_{ls} = \\underset{\\bf p}{\\operatorname{argmin}} \\|\\hat{\\bf c}_{\\bf x}-{\\bf G}_{np}{\\bf p}\\|_2^2=({\\bf G}_{np}^H{\\bf G}_{np})^{-1}{\\bf G}_{np}^H\\hat{\\bf c}_{\\bf x}.\n\\]\n(예제)\n(1) \\({\\bf V}\\)를 정의\n\nN = 100 \nV = [i*j for i in 0:(N-1) for j in 0:(N-1)] |&gt; \n    x -&gt; reshape(x,(N,N)) .|&gt; \n    x -&gt; exp(im * (2π/N) * x)\n\n100×100 Matrix{ComplexF64}:\n 1.0+0.0im       1.0+0.0im        …       1.0+0.0im\n 1.0+0.0im  0.998027+0.0627905im     0.998027-0.0627905im\n 1.0+0.0im  0.992115+0.125333im      0.992115-0.125333im\n 1.0+0.0im  0.982287+0.187381im      0.982287-0.187381im\n 1.0+0.0im  0.968583+0.24869im       0.968583-0.24869im\n 1.0+0.0im  0.951057+0.309017im   …  0.951057-0.309017im\n 1.0+0.0im  0.929776+0.368125im      0.929776-0.368125im\n 1.0+0.0im  0.904827+0.425779im      0.904827-0.425779im\n 1.0+0.0im  0.876307+0.481754im      0.876307-0.481754im\n 1.0+0.0im  0.844328+0.535827im      0.844328-0.535827im\n 1.0+0.0im  0.809017+0.587785im   …  0.809017-0.587785im\n 1.0+0.0im  0.770513+0.637424im      0.770513-0.637424im\n 1.0+0.0im  0.728969+0.684547im      0.728969-0.684547im\n    ⋮                             ⋱  \n 1.0+0.0im  0.728969-0.684547im      0.728969+0.684547im\n 1.0+0.0im  0.770513-0.637424im      0.770513+0.637424im\n 1.0+0.0im  0.809017-0.587785im   …  0.809017+0.587785im\n 1.0+0.0im  0.844328-0.535827im      0.844328+0.535827im\n 1.0+0.0im  0.876307-0.481754im      0.876307+0.481754im\n 1.0+0.0im  0.904827-0.425779im      0.904827+0.425779im\n 1.0+0.0im  0.929776-0.368125im      0.929776+0.368125im\n 1.0+0.0im  0.951057-0.309017im   …  0.951057+0.309017im\n 1.0+0.0im  0.968583-0.24869im       0.968583+0.24869im\n 1.0+0.0im  0.982287-0.187381im      0.982287+0.187381im\n 1.0+0.0im  0.992115-0.125333im      0.992115+0.125333im\n 1.0+0.0im  0.998027-0.0627905im     0.998027+0.0627905im\n\n\n(2) \\({\\bf G}_{np}={\\bf V}^{\\ast} \\odot {\\bf V}\\), 여기에서 \\(\\odot\\)은 열별-크로네커곱을 의미한다.\n\n# columnwise_kron은 위에서 정의한적 있음~\nGₙₚ = columnwise_kron(conj(V),V)\n\n10000×100 Matrix{ComplexF64}:\n 1.0+0.0im       1.0+0.0im        …       1.0+0.0im\n 1.0+0.0im  0.998027+0.0627905im     0.998027-0.0627905im\n 1.0+0.0im  0.992115+0.125333im      0.992115-0.125333im\n 1.0+0.0im  0.982287+0.187381im      0.982287-0.187381im\n 1.0+0.0im  0.968583+0.24869im       0.968583-0.24869im\n 1.0+0.0im  0.951057+0.309017im   …  0.951057-0.309017im\n 1.0+0.0im  0.929776+0.368125im      0.929776-0.368125im\n 1.0+0.0im  0.904827+0.425779im      0.904827-0.425779im\n 1.0+0.0im  0.876307+0.481754im      0.876307-0.481754im\n 1.0+0.0im  0.844328+0.535827im      0.844328-0.535827im\n 1.0+0.0im  0.809017+0.587785im   …  0.809017-0.587785im\n 1.0+0.0im  0.770513+0.637424im      0.770513-0.637424im\n 1.0+0.0im  0.728969+0.684547im      0.728969-0.684547im\n    ⋮                             ⋱  \n 1.0+0.0im  0.770513-0.637424im      0.770513+0.637424im\n 1.0+0.0im  0.809017-0.587785im      0.809017+0.587785im\n 1.0+0.0im  0.844328-0.535827im   …  0.844328+0.535827im\n 1.0+0.0im  0.876307-0.481754im      0.876307+0.481754im\n 1.0+0.0im  0.904827-0.425779im      0.904827+0.425779im\n 1.0+0.0im  0.929776-0.368125im      0.929776+0.368125im\n 1.0+0.0im  0.951057-0.309017im      0.951057+0.309017im\n 1.0+0.0im  0.968583-0.24869im    …  0.968583+0.24869im\n 1.0+0.0im  0.982287-0.187381im      0.982287+0.187381im\n 1.0+0.0im  0.992115-0.125333im      0.992115+0.125333im\n 1.0+0.0im  0.998027-0.0627905im     0.998027+0.0627905im\n 1.0+0.0im       1.0+0.0im                1.0+0.0im\n\n\n(3) \\(\\hat{\\bf p}_{ls}=({\\bf G}_{np}^H{\\bf G}_{np})^{-1}{\\bf G}_{np}^H\\hat{\\bf c}_{\\bf x}\\)\n\nĉₓ = vec(x*x')\np̂ = inv(Gₙₚ' * Gₙₚ) * Gₙₚ' * ĉₓ \n\n100-element Vector{ComplexF64}:\n  0.003314209663374193 - 2.7356277964988863e-19im\n   0.03651843533340838 - 4.01518191768058e-18im\n   0.03433532967764885 + 2.515448157755484e-17im\n 0.0016782856970223292 - 1.0070028487673847e-17im\n   0.10166837790613971 + 3.1129277935880596e-18im\n  0.015421439356883134 + 9.403422807142065e-18im\n  0.025184594035243472 - 3.993782799800785e-18im\n   0.04658258516955039 - 1.850761436988587e-18im\n   0.04658541677045607 + 1.1559103895961936e-17im\n  0.007878013503208905 + 3.559698092088507e-18im\n  0.023337481863133468 + 2.6204945155857973e-18im\n   0.02249381702313939 + 5.304406111488559e-18im\n  0.006724780595702225 - 1.655564138463681e-17im\n                       ⋮\n  0.006724780595702329 + 1.8121162053534517e-18im\n  0.022493817023139205 - 1.0461976779111972e-17im\n   0.02333748186313285 - 6.792203007975684e-18im\n  0.007878013503208907 - 2.3575339315335667e-18im\n  0.046585416770456294 + 1.5392042695643853e-17im\n  0.046582585169550106 - 1.123245521985718e-17im\n  0.025184594035242928 + 1.1628578774983873e-18im\n  0.015421439356883466 + 5.864828990948797e-18im\n   0.10166837790614085 + 2.2712943512935246e-17im\n 0.0016782856970221013 + 4.829637376114682e-18im\n   0.03433532967764831 + 3.3208196889839756e-19im\n  0.036518435333408754 + 1.3795822112205515e-17im\n\n\n\n?? 뭔가 스케일이 안맞음\n\n\nN^2 * p̂\n\n100-element Vector{ComplexF64}:\n  33.14209663374193 - 2.7356277964988864e-15im\n 365.18435333408377 - 4.0151819176805797e-14im\n  343.3532967764885 + 2.515448157755484e-13im\n 16.782856970223293 - 1.0070028487673847e-13im\n 1016.6837790613971 + 3.1129277935880596e-14im\n 154.21439356883135 + 9.403422807142065e-14im\n 251.84594035243472 - 3.9937827998007846e-14im\n  465.8258516955039 - 1.850761436988587e-14im\n  465.8541677045607 + 1.1559103895961937e-13im\n  78.78013503208905 + 3.559698092088507e-14im\n 233.37481863133468 + 2.6204945155857973e-14im\n 224.93817023139388 + 5.304406111488559e-14im\n  67.24780595702225 - 1.655564138463681e-13im\n                    ⋮\n  67.24780595702329 + 1.8121162053534517e-14im\n 224.93817023139206 - 1.0461976779111972e-13im\n  233.3748186313285 - 6.792203007975684e-14im\n  78.78013503208906 - 2.3575339315335666e-14im\n 465.85416770456294 + 1.5392042695643854e-13im\n 465.82585169550106 - 1.123245521985718e-13im\n 251.84594035242927 + 1.1628578774983874e-14im\n 154.21439356883465 + 5.864828990948797e-14im\n 1016.6837790614085 + 2.2712943512935246e-13im\n  16.78285697022101 + 4.8296373761146824e-14im\n  343.3532967764831 + 3.3208196889839758e-15im\n  365.1843533340875 + 1.3795822112205514e-13im\n\n\n\n\\(N^2\\)를 곱해주니까 아까부터 구하던 값이 그대로 잘 나옴. (\\({\\bf DFT}\\) 혹은 \\({\\bf GFT}\\)를 정의할때 \\(\\frac{1}{\\sqrt N}\\)으로 스케일링 하느냐 마느냐 차이때문에 생기는 현상임)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#의문점",
    "href": "posts/2_Studies/GRAPH/2022-12-27-Chap-12.2.1~12.3.1.html#의문점",
    "title": "[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators",
    "section": "의문점",
    "text": "의문점\n아래의 그림을 살펴보자.\n\n\n\n그림12.3(교재에서 긁어온 그림): Power spectral density estimation. All estimators are based on the same random process defined on the Karate club network (Zachary 1977). (A) Periodogram estimation with different numbers of observations. (B) Windowed average periodogram from a single realization and a different number of windows. (C) Windowed average periodogram for four windows and a varying number of realizations. (D) Parametric MA estimation for 1 and 10 realizations.\n\n\n이 그림은 다양한 방법으로 true PSD \\({\\bf p}\\)를 추정한 결과를 나타내는 PSD plot 이다25. 우리가 적용한 방법은 (A)에서 \\(R=1\\)일 경우이다. 보는것 처럼 true PSD 를 놀라울 정도로 제대로 추정하지 못한다26. 만약에 우리가 모형에서 하나의 시계열이 아니라 1000개의 정도의 시계열을 관측하였다면 좀 더 합리적으로 추정할 수 있다. 그런데 사실 하나의 모형에서 1000개씩이나 되는 시계열을 관측하는 일은 현실적으로 불가능하다27 따라서 우리는 비교적 적은 \\(R\\)에서 합리적인 PSD의 추정치를 이끌어내야 한다. 그림 (B),(C)는 상대적으로 적은 \\(R\\)에 대해 \\({\\bf p}\\)를 추정하는 windowed periodogram 을 이용하여 PSD를 추정한 결과이다. (C)를 살펴보면 \\(R=1\\) 일경우 \\({\\bf p}\\)를 추정한 값들이 나와있는데 (A)와 비교하면 꽤 합리적으로 보인다.\n25 x축이 freq, y축이 PSD26 맞추는게 없는 것 같은데?27 그리고 대부분 \\(R=1\\)이지..28 약간 바이어스가 있어보이긴 하는데, 우연히 생긴건지 이론적으로 항상 생기는 건지는 잘 모르겠네?29 이런걸 세미파라메트릭 모형이라고 해요30 그래서 플랏을 보면서 적당한 ARMA를 찾을 필요도 없고, AIC 니 BIC 를 따져가면서 모형선택을 할 필요도 없고31 적합이후에 잔차분석 같은거 안해도 된다는 의미문제는 (A)-(C)에서 제안된 방법 모두가 (D)에 제시된 전통적인 방법에 비하여 퍼포먼스가 떨어진다는 것이다. (D)는 parametric 모형을 사용한 결과이다. 파라메트릭 방법이므로 특정 모델을 한정하고 거기에 대응하는 한두개의 모수만 추정하면 되므로 추정이 잘 된다.28 반면 (A)-(C)의 경우 한 두개의 파라메터가 아니라 \\({\\bf p}\\)의 모든 원소를 추정해야하므로 추정할 파라메터가 데이터의 수 \\(N\\)과 같다29. 따라서 추정치의 분산이 크다. 사실 이것은 파라메트릭 방법과 세미파라메트릭 방법이라는 구조적인 차이때문에 어쩔 수 없는 것 같다. 그래도 세미파라메트릭 방법은 머리아프게 모델링을 할 필요가 없고30 내가 적합한 모델이 맞는지 확인할 필요도 없다31는 장점이 있다.\n아래는 나름 PSD를 추정하는 신기술인 것 같다.\n\n\n\n그림12.4(교재에서 긁어온 그림): PSD estimation from a subset of nodes. Estimators are based on a random process defined on the Karate club network (Zachary 1977). (A) Graph sampling for nonparametric PSD estimation. Here, 20 out of 34 nodes are observed. The sampled nodes are highlighted by the circles around the nodes. (B) Nonparametric PSD estimation based on observations from 20 nodes and 100 data snapshots. (C) Graph sampling for parametric MA PSD estimation. Here, 4 out of 34 nodes are observed. (D) Parametric MA PSD estimation based on observations from 4 nodes and 100 data snapshots.\n\nZachary, Wayne W. 1977. “An Information Flow Model for Conflict and Fission in Small Groups.” Journal of Anthropological Research 33 (4): 452–73.\n\n\n그래프신호의 sub-sampling을 이용하는 것 같은데 교재의 뒤쪽에 서술되어있다. \\(R=100\\)임을 고려하여도 퍼포먼스가 좋은 편인듯 하다32.\n\n\n32 내 생각엔 이게 핵심 기술인 것 같음"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-06-30-Graph Signal.html",
    "href": "posts/2_Studies/GRAPH/2023-06-30-Graph Signal.html",
    "title": "Graph Signal",
    "section": "",
    "text": "Summary\n\nthe given signal is observed on a graph \\({\\cal G}:=({\\cal V},{\\cal E})\\)\n\n\\({\\cal V}\\) represents the set of nodes\n\\({\\cal E}\\) represents the set of edges (links)\nwe have observed a real-valued signal, denoted as \\(y: V \\to \\mathbb{R}\\)\n\n\nImport\n\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n\n\nGraph Signal\n\n\n\nFigure: A random positive graph signal on the vertices of the Petersen graph. The height of each blue bar represents the signal value at the vertex where the bar originates (Shuman et al. 2013)\n\nShuman, David I, Sunil K Narang, Pascal Frossard, Antonio Ortega, and Pierre Vandergheynst. 2013. “The Emerging Field of Signal Processing on Graphs: Extending High-Dimensional Data Analysis to Networks and Other Irregular Domains.” IEEE Signal Processing Magazine 30 (3): 83–98.\n\n\nSuppose we have observed a real-valued signal, denoted as \\(y: V \\to \\mathbb{R}\\), from a graph \\({\\cal G} = (V, E)\\), where \\(V\\) represents the set of nodes and \\(E\\) represents the set of edges."
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-07-01-Euclidean_nonEuclidean.html",
    "href": "posts/2_Studies/GRAPH/2023-07-01-Euclidean_nonEuclidean.html",
    "title": "Non-Euclidean vs Euclidean",
    "section": "",
    "text": "Regular Graph?\n\nSummary\n\n\nEuclidean data\n\nunderlying function이 regular graph로 정의가 가능한 data\nunderline(domain)이 euclidean domain에 위치한 데이터(x축, 1d-grid, 2d-grid 등)\neuclidean distance로 계산할 수 있는 data\n\nNon-Euclidean data\n\nunderlying function이 regular graph로 정의가 가능하지 않은 data\nunderline(domain)이 non-euclidean domain에 위치한 데이터(곡선, 곡면 등)\neuclidean distance calculation이 not reasonable한 data\n\n\n\n\n\n\n\n\nGraph vs Manifold\n\n\n\n\n굳이 포함관계를 따지자면, Non-Euclidean &gt; Graph &gt; Manifold\nNon-Euclidean\n\nGraph\n\n거리는 Edge 나 weight 로 정의함.\n\nManifold(ex. swiss roll, 아래 예시 있음!)\n\nunderline = domain(swiss roll에서 말린 곡면)\nunderlying function = color(swiss roll에서 무지개 색)\n유한한 그래프 시그널로 표현 가능\n\n무한한 노드에서 realization sample 뽑고,\n그래프로 가져오려면 distance 정의 수정이 필요하다.\n\n수정하는 방법\n\n\\(W_{i,j} = \\begin{cases} \\exp\\left(-\\frac{\\|{\\boldsymbol v}_i -{\\boldsymbol v}_j\\|^2}{2\\theta^2}\\right) & \\|{\\boldsymbol v}_i -{\\boldsymbol v}_j\\|^2 \\le \\kappa \\\\ 0 & o.w\\end{cases}\\)를 사용하여 가까운 것만 거리 계산하도록 하기, 곡선은 유클리디안 거리를 semi 사용하고(이 식에서 \\(\\kappa\\)로 먼 거리는 자르니까), 곡면은 하버사인 거리를 사용.\nsimilarity(유사도) 따지기(ex. 몇 번 건너서 다음 노드로 가는지 등)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-07-01-Euclidean_nonEuclidean.html#euclidean",
    "href": "posts/2_Studies/GRAPH/2023-07-01-Euclidean_nonEuclidean.html#euclidean",
    "title": "Non-Euclidean vs Euclidean",
    "section": "Euclidean",
    "text": "Euclidean\n\nEx1) 1D grid\n\nText, etc.\n\n\n\n\nFigure: Sentence, word, sound: 1D Euclidean domains. This image is sourced from the PAM Workshop “New Deep Learning Techniques” Feb 7th 2017\n\n\n\nw=np.zeros((5,5))\nfor i in range(5):\n    for j in range(5):\n        if i==j :\n            w[i,j] = 0\n        elif i-j == 1 : \n            w[i,j] = 1\n\n\nlst = []\nfor i in range(5):\n    for j in range(5):\n        if w[i,j] == 1:\n            lst.append([i,j])\n\n\nd= w.sum(axis=1)\nD= np.diag(d)\n\n\n\n\n\n\n\nNote\n\n\n\n모든 Degree가 동일한, 특히 단위행렬로 나오는(Regular graph인) 유클리디안 데이터\n\n\n\nD\n\narray([[0., 0., 0., 0., 0.],\n       [0., 1., 0., 0., 0.],\n       [0., 0., 1., 0., 0.],\n       [0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 1.]])\n\n\n\nG = nx.Graph()\n\n\nG.add_edges_from(np.array(lst))\n\n\nplt.figure(figsize=(20, 5)) \nnx.draw_networkx(G, with_labels=True, font_weight='bold', node_color='orange', node_size=1500, font_color='white', font_size=30,width=5)\n\n\n\n\n\n\n\n\n\n\nEx2) 2d grids\n\nImage, etc.\n\n\n\n\nFigure: Image, volume, video: 2D, 3D, 2D+1 Euclidean domains. This image is sourced from the PAM Workshop “New Deep Learning Techniques” Feb 7th 2017\n\n\n\nw = np.ones((4, 4))\nfor i in range(4):\n    for j in range(4):\n        if i==j :\n            w[i,j] = 0\n\n\nlst = []\nfor i in range(4):\n    for j in range(4):\n        if w[i,j] == 1:\n            lst.append([i,j])\n\n\nd= w.sum(axis=1)\nD= np.diag(d)\n\n\n\n\n\n\n\nNote\n\n\n\n모든 Degree가 동일하여 \\(D = 3I\\)로 표현되는(Regular graph인) 유클리디안 데이터\n\n\n\nD\n\narray([[3., 0., 0., 0.],\n       [0., 3., 0., 0.],\n       [0., 0., 3., 0.],\n       [0., 0., 0., 3.]])\n\n\n\nG = nx.Graph()\n\n\nG.add_edges_from(np.array(lst))\n\n\nplt.figure(figsize=(10, 10)) \nnx.draw_networkx(G, with_labels=True, font_weight='bold', node_color='orange', node_size=1500, font_color='white', font_size=30,width=5)"
  },
  {
    "objectID": "posts/2_Studies/GRAPH/2023-07-01-Euclidean_nonEuclidean.html#non-euclidean",
    "href": "posts/2_Studies/GRAPH/2023-07-01-Euclidean_nonEuclidean.html#non-euclidean",
    "title": "Non-Euclidean vs Euclidean",
    "section": "Non-Euclidean",
    "text": "Non-Euclidean\n\nEx3) Different Weights\n\nWeight 같다고 가정하고 그래프 시각화\n\n\nw=np.zeros((5,5))\nfor i in range(5):\n    for j in range(5):\n        if i==j :\n            w[i,j] = 0\n        elif i!=j: \n            w[i,j] = 1\n\n\nlst = []\nfor i in range(5):\n    for j in range(5):\n        if w[i,j] == 1:\n            lst.append([i,j])\n\n\nG = nx.Graph()\n\n\nG.add_edges_from(np.array(lst))\n\n\nplt.figure(figsize=(10, 10)) \nnx.draw_networkx(G, with_labels=True, font_weight='bold', node_color='orange', node_size=1500, font_color='white', font_size=30,width=5)\n\n\n\n\n\n\n\n\n\npi=np.pi\nang=np.linspace(-pi,pi-2*pi/5,5)\nr=5+np.cos(np.linspace(0,12*pi,5))\nvx=r*np.cos(ang)\nvy=r*np.sin(ang)\nf1=10*np.sin(np.linspace(0,6*pi,5))\nf = f1 + np.random.normal(5)\n\n\nD = np.zeros([5,5])\nlocations = np.stack([vx, vy],axis=1)\nfor i in range(5):\n    for j in range(i,5):\n        D[i,j]=np.linalg.norm(locations[i]-locations[j])\nD = D + D.T\n\n\nD\n\narray([[ 0.        ,  6.0964895 , 11.4126782 ,  9.53062515,  7.05342303],\n       [ 6.0964895 ,  0.        ,  6.0964895 ,  7.60845213,  9.53062515],\n       [11.4126782 ,  6.0964895 ,  0.        ,  6.0964895 , 11.4126782 ],\n       [ 9.53062515,  7.60845213,  6.0964895 ,  0.        ,  6.0964895 ],\n       [ 7.05342303,  9.53062515, 11.4126782 ,  6.0964895 ,  0.        ]])\n\n\n\n\n\n\n\n\nNote\n\n\n\n가중치 값이 다 다르게 형성되어 있다. 따라서 \\(D=kI\\)형태로도 표현할 수 없어 레귤러 메트릭스의 정의를 충족하지 못하며, 이는 비유클리디안 데이터이다.\n\n\n\n\nEx3) Non-Euclidean data with Non-Euclidean domain\n\ndegree matrix가 단위행렬이 아니어서 레귤러 그래프가 아닌 그래프\n\n\n1. 3D shape, Manifold\n\n도메인이 표면(컵)이며, underlying function 이 regular graph로 정의되지 않는다.\n\nreference\n\n\n\nFigure: Surface (non-Euclid data). This image is sourced from the (Fall 2020 course website for Non-Euclidean Methods in Machine Learning (CS468), Stanford University)\n\n\n\n\n2. 3D shape, Manifold\n\n도메인이 구로 형성되어 있고, graph로 인지 시, underlying function 이 색(파란색)으로 볼 수 있고, 다른 색으로 구성된 것은 \\(\\eta\\)로 볼 수 있고, regular graph로 정의되지 않는다.\n\n간단 \\(\\eta\\) 정의 review = noise 이지만, 특정 i에서 값이 큰 nois를 갖음\n\n\n\nFigure: Distributions on 3D shapes (non-Euclid data). This image is sourced from the Fall 2020 course website for Non-Euclidean Methods in Machine Learning (CS468), Stanford University\n\n\n\n\n3. 3D shape, Manifold\n\n도메인이 표면(고양이)이며, underlying function 이 색이라고 할 수 있다.\n\n\n\n\nFigure: Functions on manifolds (non-Euclid data). This image is sourced from the Fall 2020 course website for Non-Euclidean Methods in Machine Learning (CS468), Stanford University\n\n\n\n\n4. 3D shape, Manifold\n\n도메인이 표면이며, underlying function 이 색이다. graph로 볼 때 regular graph로 정의되지 않는다.\n\nreference\n\n\n\nFigure: General manifolds (non-Euclid data). This image is sourced from the (Fall 2020 course website for Non-Euclidean Methods in Machine Learning (CS468), Stanford University)\n\n\n\n\n5. Graph\n\n도메인이 노드인 graph. underlying function 은 정의할 수 없지만 굳이 따지자면 Classification work. 신경망 모양..\n\nreference\n\n\n\nFigure: Graphs networks (non-Euclid data). This image is sourced from the [Fall 2020 course website for Non-Euclidean Methods in Machine Learning (CS468), Stanford University]\n\n\n\n\n6. Graph(Manifold?)\n\n위의 정의 참고, 노드가 도메인인 graph. 색이 underlying function.\n\nSwiss roll (non-euclid data) from (Das and Pal 2021)\n\n\n\nFigure: Swiss roll (non-euclid data) from Das and Pal (2021)\n\nDas, Suchismita, and Nikhil R Pal. 2021. “Nonlinear Dimensionality Reduction for Data Visualization: An Unsupervised Fuzzy Rule-Based Approach.” IEEE Transactions on Fuzzy Systems 30 (7): 2157–69.\n\n\n\n\n7. Graph\n\n도메인이 노드이며, classification work\n\n\n\n\nFigure: Brain network (non-Euclid data) from Ginestet, Fournel, and Simmons (2014)\n\nGinestet, Cedric E, Arnaud P Fournel, and Andrew Simmons. 2014. “Statistical Network Analysis for Functional MRI: Summary Networks and Group Comparisons.” Frontiers in Computational Neuroscience 8: 51.\n\n\n\n\n8. Graph Signal\n\n도메인이 노드(택시 탄 장소)이며, underlying function 이 색(택시 픽업 얼마나 하는지를 나타냄, 많이 할 수록 레드쪽으로) regular graph로 정의되지 않는다.\n\n\n\n\nFigure: Taxi-pickup distribution in Manhattan (non-euclid data) from Ortega et al. (2018)\n\n\n\n\n9. Graph signal, spatiotemporal data\n\n도메인이 노드(sequence)이며, underlying function 이 regular graph로 정의되지 않는다.(파란색인 양의 signal, 검정색인 음의 signal로 mapping되어 있는 graph signal의 형태)\n\n\n\n\nFigure: Minnesota road graph (non-euclid data) from Shuman et al.(2013)\n\n\n\n\n10. Graph(Sequence), dynamic spatiotemporal data\n\n도메인이 표면(사람,motion을 sequence로 전달)이며, dynamic spatiotemporal data\n\n\n\n\nFigure: 3D point cloud sequence (non-euclid data) from (Ortega et al. 2018)\n\nOrtega, Antonio, Pascal Frossard, Jelena Kovačević, José MF Moura, and Pierre Vandergheynst. 2018. “Graph Signal Processing: Overview, Challenges, and Applications.” Proceedings of the IEEE 106 (5): 808–28."
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "dir, mkdir, cd..\n\n\n\n\n\n질문1: 파이썬코드가 실행되는 속도는 어떤 컴퓨터의 spec에 결정될까?\n\n\n\n\n\n!dir, !mkdir,\n\n\n\n\n\ncd Desktop\nmkdir asdf # 폴더생성\nmv asdf asdf2 # 폴더이름 변경\nrm -rf asdf # 폴더삭제\n질문2: 여기서 파이썬을 키면? 어떤 컴퓨터 spec으로 계산될까?\n\n\n\n\n\n깃 다운로드: https://git-scm.com/downloads\n토큰생성 및 복사: https://github.com/settings/tokens\n원격과 로칼의 연결\n\n\n\n\n\n원격제어 + 깃을 동시에 이해해야함.\n터미널에서 “컨트롤(커맨드) C + 컨트롤(커맨드) V” 가능하도록 허용\n“컨트롤(커맨드) + 쉬프트 + P” -&gt; jupyter 입력 -&gt; 새로운 노트북파일 만들기\n\n반 영구적으로 패키지 설치 후 사용 가능, 서버는 연결 끊기면 끝나지만 이건 유지되고 있음\nbin - binary\ngithub이랑 연결된 main..\nrm은 파일이나 빈 폴더 삭제 가능\nrm: remove의 약자로, 파일이나 디렉터리를 삭제하는 명령어입니다.\n-r: recursive의 약자로, 디렉터리를 삭제할 때 해당 디렉터리의 모든 하위 디렉터리와 파일도 함께 삭제합니다.\n-f: force의 약자로, 삭제 작업을 확인하지 않고 강제로 진행합니다.\n\n\n\n\ni, esc\n파일만들기, 파일수정하기\n복사 & 붙여넣기\n저장후 종료, 그냥 종료, 강제종료\n/asdf + 엔터 + n + (쉬프트+n)\n단어끝으로 이동=e, 단어처음으로 이동=b\n\nvi 는 메모장 개념\n맥에서는 e가 home 개념, b거 end 개념\n검색기능 /\n검색하고 /ppal 이런 식으로 하고 e눌러서 마지막으로 가보쟈\n\n\n\n\n\n\nNote\n\n\n\nvi는 리눅스 및 유닉스 기반의 운영 체제에서 사용되는 텍스트 편집기입니다. vi는 화면 기반의 텍스트 편집 도구로, 명령 모드와 입력 모드로 구분되어 있습니다.\n명령 모드(Command Mode): vi를 시작하면 기본적으로 명령 모드에 있습니다. 이 모드에서는 텍스트를 편집하는 명령들을 실행할 수 있습니다. 예를 들어, 텍스트를 복사하거나 붙여넣기, 삭제, 저장 등의 작업을 수행합니다.\n입력 모드(Insert Mode): 명령 모드에서 “i”를 누르면 입력 모드로 전환됩니다. 이 모드에서는 키보드로 직접 텍스트를 입력할 수 있습니다.\n-&gt; dd 한 라인 삭제\nvi를 사용하는 기본적인 흐름은 다음과 같습니다:\nvi 시작: 터미널에서 vi 명령어를 입력하고 파일 이름을 지정하여 vi 편집기를 시작합니다.\nbash Copy code vi filename.txt 명령 모드(Command Mode): 편집기가 시작되면 기본적으로 명령 모드에 있습니다.\n입력 모드(Insert Mode): i를 눌러 입력 모드로 전환하고, 텍스트를 입력할 수 있습니다.\n저장 및 종료: 입력이 끝나면 Esc 키를 눌러 명령 모드로 전환하고, :wq를 입력하여 저장하고 종료합니다.\nvi는 초기에는 사용자에게 다소 어려울 수 있지만, 강력한 텍스트 편집 기능을 제공하므로 익숙해지면 효율적으로 사용할 수 있습니다. 또한, vim이라는 향상된 버전도 있어서 더 많은 기능을 지원합니다.\n\n\n\n\n\n\n\n\nNote\n\n\n\nwq는 vi 편집기에서 파일을 저장하고 나가기 위한 명령어입니다. 이 명령어는 명령 모드에서 입력하며, 파일을 저장하고 나가기 위해 사용됩니다.\n여기서 w는 “write”를 나타내고, 파일에 변경 사항을 저장하는 데 사용됩니다. q는 “quit”를 나타내며, 편집기를 종료하는 데 사용됩니다.\n따라서 :wq를 사용하면 현재 편집 중인 파일을 저장하고 vi 편집기를 종료합니다. 만약 저장하지 않은 변경 사항이 있다면 경고 메시지 없이 종료되지 않습니다.\n다른 유용한 vi 명령어들은 다음과 같습니다:\n:w: 현재 파일을 저장합니다.\n:q: 편집기를 종료합니다. (저장되지 않은 변경 사항이 있다면 종료되지 않습니다.)\n:q!: 강제로 편집기를 종료하고 저장하지 않은 변경 사항을 무시합니다.\n:x 또는 :wq: 변경 사항을 저장하고 편집기를 종료합니다.\n따라서 :wq는 “저장하고 종료”를 의미하며, 자주 사용되는 명령 중 하나입니다.\n\n\n\n\n\n\n~ssh toolbox@210.117.173.182~\n비밀번호는 jbnu\n\n\n\n\n\n휴대폰 테더링으로 잡고 본인 노트북으로 해보세요.\n실패함.\n\n\n\n\n\nquarto 설치: https://quarto.org/docs/download/\nquarto create-project –type website:blog\ngit add .\ngit commit -m .\ngit push\nquarto publish gh-pages\n\n\n\n\n\ngit clone ??\n몇 가지 변경 (index.qmd 에서 자기소개 추가하기, _quarto.yml 에서 블로그 타이틀 설정하기)\ngit add .\ngit commit -m .\ngit push\nquarto publish –no-browser –no-prompt\n\n맥에서는 cmd + shift + p하면 vscode에서 새 주피터 생성\n\n\n\n\nhttps://guebin.github.io/IP2022/2022/03/28/(4주차)-3월28일.html\nhttps://guebin.github.io/IR2021/2021/10/14/(6주차)-10월14일-특강.html\n최상단에 raw 셀로 아래의 내용입력\n\n---\ntitle: \"my title\"\nauthor: \"최규빈\"\ndate: \"01/02/2024\"\n---\n\n\n\n\ngit switch gh-pages\ngit add .\ngit commit -m .\ngit switch main\ngit add .\ngit commit -m .\ngit push\n\n\n\n\n\n질문1: git add . -&gt; git commit -m . -&gt; git push -&gt; quarto publish –no-browser –no-prompt 순서로 꼭 업로드 해야하는가? 그냥 단순히 “quarto publish –no-browser –no-prompt” 만 하면 안되는가?"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습1-터미널의-이해-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습1-터미널의-이해-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "dir, mkdir, cd.."
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습2-터미널에서-실행하는-파이썬-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습2-터미널에서-실행하는-파이썬-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "질문1: 파이썬코드가 실행되는 속도는 어떤 컴퓨터의 spec에 결정될까?"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습3-주피터에서-터미널-명령-활용하기-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습3-주피터에서-터미널-명령-활용하기-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "!dir, !mkdir,"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습4-원격제어-맥북",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습4-원격제어-맥북",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "cd Desktop\nmkdir asdf # 폴더생성\nmv asdf asdf2 # 폴더이름 변경\nrm -rf asdf # 폴더삭제\n질문2: 여기서 파이썬을 키면? 어떤 컴퓨터 spec으로 계산될까?"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습5-깃의-설치-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습5-깃의-설치-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "깃 다운로드: https://git-scm.com/downloads\n토큰생성 및 복사: https://github.com/settings/tokens\n원격과 로칼의 연결"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습6-코드스페이스-코드스페이스",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습6-코드스페이스-코드스페이스",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "원격제어 + 깃을 동시에 이해해야함.\n터미널에서 “컨트롤(커맨드) C + 컨트롤(커맨드) V” 가능하도록 허용\n“컨트롤(커맨드) + 쉬프트 + P” -&gt; jupyter 입력 -&gt; 새로운 노트북파일 만들기\n\n반 영구적으로 패키지 설치 후 사용 가능, 서버는 연결 끊기면 끝나지만 이건 유지되고 있음\nbin - binary\ngithub이랑 연결된 main..\nrm은 파일이나 빈 폴더 삭제 가능\nrm: remove의 약자로, 파일이나 디렉터리를 삭제하는 명령어입니다.\n-r: recursive의 약자로, 디렉터리를 삭제할 때 해당 디렉터리의 모든 하위 디렉터리와 파일도 함께 삭제합니다.\n-f: force의 약자로, 삭제 작업을 확인하지 않고 강제로 진행합니다."
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습7-vi-벼락치기-코드스페이스",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습7-vi-벼락치기-코드스페이스",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "i, esc\n파일만들기, 파일수정하기\n복사 & 붙여넣기\n저장후 종료, 그냥 종료, 강제종료\n/asdf + 엔터 + n + (쉬프트+n)\n단어끝으로 이동=e, 단어처음으로 이동=b\n\nvi 는 메모장 개념\n맥에서는 e가 home 개념, b거 end 개념\n검색기능 /\n검색하고 /ppal 이런 식으로 하고 e눌러서 마지막으로 가보쟈\n\n\n\n\n\n\nNote\n\n\n\nvi는 리눅스 및 유닉스 기반의 운영 체제에서 사용되는 텍스트 편집기입니다. vi는 화면 기반의 텍스트 편집 도구로, 명령 모드와 입력 모드로 구분되어 있습니다.\n명령 모드(Command Mode): vi를 시작하면 기본적으로 명령 모드에 있습니다. 이 모드에서는 텍스트를 편집하는 명령들을 실행할 수 있습니다. 예를 들어, 텍스트를 복사하거나 붙여넣기, 삭제, 저장 등의 작업을 수행합니다.\n입력 모드(Insert Mode): 명령 모드에서 “i”를 누르면 입력 모드로 전환됩니다. 이 모드에서는 키보드로 직접 텍스트를 입력할 수 있습니다.\n-&gt; dd 한 라인 삭제\nvi를 사용하는 기본적인 흐름은 다음과 같습니다:\nvi 시작: 터미널에서 vi 명령어를 입력하고 파일 이름을 지정하여 vi 편집기를 시작합니다.\nbash Copy code vi filename.txt 명령 모드(Command Mode): 편집기가 시작되면 기본적으로 명령 모드에 있습니다.\n입력 모드(Insert Mode): i를 눌러 입력 모드로 전환하고, 텍스트를 입력할 수 있습니다.\n저장 및 종료: 입력이 끝나면 Esc 키를 눌러 명령 모드로 전환하고, :wq를 입력하여 저장하고 종료합니다.\nvi는 초기에는 사용자에게 다소 어려울 수 있지만, 강력한 텍스트 편집 기능을 제공하므로 익숙해지면 효율적으로 사용할 수 있습니다. 또한, vim이라는 향상된 버전도 있어서 더 많은 기능을 지원합니다.\n\n\n\n\n\n\n\n\nNote\n\n\n\nwq는 vi 편집기에서 파일을 저장하고 나가기 위한 명령어입니다. 이 명령어는 명령 모드에서 입력하며, 파일을 저장하고 나가기 위해 사용됩니다.\n여기서 w는 “write”를 나타내고, 파일에 변경 사항을 저장하는 데 사용됩니다. q는 “quit”를 나타내며, 편집기를 종료하는 데 사용됩니다.\n따라서 :wq를 사용하면 현재 편집 중인 파일을 저장하고 vi 편집기를 종료합니다. 만약 저장하지 않은 변경 사항이 있다면 경고 메시지 없이 종료되지 않습니다.\n다른 유용한 vi 명령어들은 다음과 같습니다:\n:w: 현재 파일을 저장합니다.\n:q: 편집기를 종료합니다. (저장되지 않은 변경 사항이 있다면 종료되지 않습니다.)\n:q!: 강제로 편집기를 종료하고 저장하지 않은 변경 사항을 무시합니다.\n:x 또는 :wq: 변경 사항을 저장하고 편집기를 종료합니다.\n따라서 :wq는 “저장하고 종료”를 의미하며, 자주 사용되는 명령 중 하나입니다."
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습8-서버접속-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습8-서버접속-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "~ssh toolbox@210.117.173.182~\n비밀번호는 jbnu"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습9-서버접속2-개인-노트북",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습9-서버접속2-개인-노트북",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "휴대폰 테더링으로 잡고 본인 노트북으로 해보세요.\n실패함."
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습10-윈도우에서-블로그-생성-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습10-윈도우에서-블로그-생성-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "quarto 설치: https://quarto.org/docs/download/\nquarto create-project –type website:blog\ngit add .\ngit commit -m .\ngit push\nquarto publish gh-pages"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습11-코드스페이스에서-블로그-생성-코드스페이스",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습11-코드스페이스에서-블로그-생성-코드스페이스",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "git clone ??\n몇 가지 변경 (index.qmd 에서 자기소개 추가하기, _quarto.yml 에서 블로그 타이틀 설정하기)\ngit add .\ngit commit -m .\ngit push\nquarto publish –no-browser –no-prompt\n\n맥에서는 cmd + shift + p하면 vscode에서 새 주피터 생성"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습12-블로그-포스트-업로드-코드스페이스",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습12-블로그-포스트-업로드-코드스페이스",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "https://guebin.github.io/IP2022/2022/03/28/(4주차)-3월28일.html\nhttps://guebin.github.io/IR2021/2021/10/14/(6주차)-10월14일-특강.html\n최상단에 raw 셀로 아래의 내용입력\n\n---\ntitle: \"my title\"\nauthor: \"최규빈\"\ndate: \"01/02/2024\"\n---"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습13-코드스페이스에-작업한-블로그를-윈도우로-pull-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습13-코드스페이스에-작업한-블로그를-윈도우로-pull-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "git switch gh-pages\ngit add .\ngit commit -m .\ngit switch main\ngit add .\ngit commit -m .\ngit push"
  },
  {
    "objectID": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습14-quarto-publish-의-동작이해-강의용-윈도우-컴퓨터",
    "href": "posts/1_Note/2024-01-02-DSTBX2023(1).html#실습14-quarto-publish-의-동작이해-강의용-윈도우-컴퓨터",
    "title": "DSTBX2023(1)",
    "section": "",
    "text": "질문1: git add . -&gt; git commit -m . -&gt; git push -&gt; quarto publish –no-browser –no-prompt 순서로 꼭 업로드 해야하는가? 그냥 단순히 “quarto publish –no-browser –no-prompt” 만 하면 안되는가?"
  },
  {
    "objectID": "posts/1_Note/2019-04-26-퓨리에 변환.html",
    "href": "posts/1_Note/2019-04-26-퓨리에 변환.html",
    "title": "[Essays] 퓨리에 변환",
    "section": "",
    "text": "About this doc\n- 이번에는 퓨리에 표현들을 정리하도록 하겠다. 내생각엔 퓨리에 표현들도 벡터의 미분만큼 복잡한 것 같다. 정의가 너무 많고 그게 그거 같아서 그렇다. 이번기회에 깔끔하게 정리하도록 하자. 참고한 문헌은 아래와 같다.\n\nHaykin, S., & Van Veen, B. (2007). Signals and systems. John Wiley & Sons.\n\n\n\n들어가며\n- 우선 신호와 하나의 신호값을 구분하는 notation을 생각하자. 우리가 다루는 신호 즉 데이터는 값들의 집합이다. 우리가 시계열자료를 다룬다면 데이터는 아래와 같이 표현한다.\n\n\\(\\{x_i: i \\in \\mathbb{Z}\\}\\)\n\n이와 유시하게 우리가 다루는 자료가 \\(t \\in \\mathbb{R}\\)인 연속신호라면 아래와 같이 표현한다.\n\n\\(\\{x(t): t \\in \\mathbb{R}\\}\\)\n\n우리가 모든 \\(i \\in \\mathbb{Z}\\) 혹은 모든 \\(t \\in \\mathbb{R}\\)에서 신호를 다룰 생각이 없다면 아래와 같은 표현도 얼마든지 가능하다.\n\n\\(\\{x_i: i=0,1,\\dots, \\xi-1 \\}\\)\n\\(\\{x(t):t \\in (0,\\zeta) \\}\\)\n\n- 위와 같이 집합의 표현 없이 단독으로 \\(x_i\\), \\(x(t)\\)와 같이 쓰면 하나의 고정된 값 \\(i,t\\)에 대한 \\(x_i\\), \\(x(t)\\)로 이해하자. 솔직히 이렇게 꼭 신호를 엄밀하게 집합으로 정의하는게 유별나 보일수도 있다. 일반적으로 사람들은 \\(\\{x(t): ~t \\in \\mathbb{R} \\}\\) 대신에 보통 \\(x(t)\\)로 간단하게 줄여서 쓰곤한다.1 하지만 이 포스팅에 한정하여 위와 같이 집합의 형태로 엄밀하게 구분해 쓰도록 하자. 처음에는 익숙하지 않지만 나중에는 편리하다.\n1 나도 그렇다.\n\n퓨리에표현들\n- 지금부터 우리가 고려하는 모든 신호들은 기본적으로 (1) infinity range에서 정의된 신호라고 가정한다. 즉 연속신호이면 \\(\\mathbb{R}\\)에서 정의된다고 가정하고 이산신호면 \\(\\mathbb{Z}\\)에서 정의된다고 가정한다. 또한 우리가 분석하고자 하는 신호는 (2) integrable 하다고 가정한다. 이건 퓨리에표현들이 적분 혹은 무한합의 형태로 표현된다는 것을 상기하면 타당하여 보인다.\n- 즉 우리가 고려하는 신호는 인피니티-레인지에서 정의되며 인피니티-레인지에서 적분값이 유한한 연속신호 혹은 이산신호 임을 알 수 있다. 이러한 신호는 구체적으로는 아래와 같이 쓸 수 있다.\n\n\\(\\left\\{x(t): \\int_{-\\infty}^{\\infty} |x(t)| dt &lt;\\infty,~ t \\in \\mathbb{R} \\right\\}\\)\n\\(\\left\\{x_i: \\sum_{i=-\\infty}^{\\infty} |x_i| &lt;\\infty,~ i \\in \\mathbb{Z} \\right\\}\\)\n\n- 그런데 integrable 한 함수들만을 고려하다 보면 우리가 다룰 수 있는 신호의 범위가 확 줄어들게 된다. 가령 예를 들어서 아래와 같은 신호는 적분을 하면 무한대가 나오기 때문에 intergrable 하지 않다.\n\n\\(\\left\\{x(t): x(t)=\\sin(t)+1 ,~ t \\in \\mathbb{R} \\right\\}\\)\n\n이것은 좀 불합리해 보이는데 위의 신호는 주기신호라서 한 주기의 패턴만 분석하면 될것 같이 보이기 때문이다. 위의 신호는 intergrable 하지않지만 아래의 신호는 intergrable 하다.\n\n\\(\\left\\{x(t): x(t)=\\sin(t)+1 ,~ t \\in (0,2\\pi) \\right\\}\\)\n\n우리는 이런신호까지 분석하기로 한다. 이런신호를 분석할 수 있는 이유는 해석학 교재를 참고하면 된다.2\n2 사실 나도 잘 모름 (뭐 quotient group이런거 알아야 하는데 공부하려면 꽤 걸릴듯)- 아무튼 우리는 (1) 인피니티-레인지에서 정의되는 가지는 신호 (2) 인피니티-레인지에서 적분값이 잘 정의되는 신호, 혹은 한 주기만 적분해 보았을때 그 값이 잘 정의되는 주기신호 를 타겟팅해 분석한다. 즉 분석하는 신호는 구체적으로 아래의 4가지이다.\ncase 1: 연속-비주기\n\n\\(\\left\\{x(t): \\int_{-\\infty}^{\\infty} |x(t)| dt &lt;\\infty,~ t \\in \\mathbb{R} \\right\\}.\\)\n\ncase 2: 연속-주기\n\n\\(\\left\\{x(t): \\int_{0}^{\\zeta} |x(t)| dt &lt;\\infty, ~ , x(t)=x(t+\\zeta), ~ t \\in \\mathbb{R}, \\right\\}.\\)\n\ncase 3: 이산-비주기\n\n\\(\\left\\{x_i: \\sum_{i=-\\infty}^{\\infty} |x_i| &lt;\\infty,~ i \\in \\mathbb{Z} \\right\\}.\\)\n\ncase 4: 이산-주기\n\n\\(\\left\\{x_i: \\sum_{i=0}^{\\xi-1} |x_i| &lt;\\infty,~ i, x_i=x_{i+\\xi},~ i \\in \\mathbb{Z} \\right\\}.\\)\n\n- 표현들을 정리하기에 앞서서 몇 가지 알아두어야 할 사항이 있다. (1) 시간축에서 연속인 신호는 주파수측에서는 비주기신호가 나온다. (2) 시간축에서 디스크릿한 신호는 주파수측에서는 주기신호이다. (3) 시간축에서 주기인 신호는 주파수에서는 디스크릿하다. (4) 시간축에서 비주기신호는 주파수에서 연속이다. 이 사실들을 종합하면 각각의 경우에 해당하는 퓨리에 표현들은 아래와 같은 특징을 가지고 있음을 알 수 있다.\ncase 1: 연속-비주기\n\n\\(\\left\\{x(t): \\int_{-\\infty}^{\\infty} |x(t)| dt &lt;\\infty,~ t \\in \\mathbb{R} \\right\\} \\\\ \\overset{FT}{\\Longleftrightarrow} \\left\\{\\hat x(\\omega): \\int_{-\\infty}^{\\infty} |\\hat x(\\omega)| d\\omega &lt;\\infty,~ \\omega \\in \\mathbb{R} \\right\\}\\)\n\ncase 2: 연속-주기\n\n\\(\\left\\{x(t): \\int_{0}^{\\zeta} |x(t)| dt &lt;\\infty,~ x(t)=x(t+\\zeta),~ t \\in \\mathbb{R} \\right\\} \\\\ \\overset{FS}{\\Longleftrightarrow} \\left\\{\\hat x_k: \\sum_{k=-\\infty}^{\\infty} |\\hat x_k| &lt;\\infty,~ k \\in \\mathbb{Z} \\right\\}\\)\n\ncase 3: 이산-비주기\n\n\\(\\left\\{x_i: \\sum_{i=-\\infty}^{\\infty} |x_i| &lt;\\infty,~ i \\in \\mathbb{Z} \\right\\} \\\\ \\overset{DTFT}{\\Longleftrightarrow} \\left\\{\\hat x(\\omega): \\int_{0}^{2\\pi} |\\hat x(\\omega)| d\\omega &lt;\\infty,~ \\hat x(\\omega)=\\hat x(\\omega+2\\pi),~ \\omega \\in \\mathbb{R} \\right\\}.\\)\n\ncase 4: 이산-주기\n\n\\(\\left\\{x_i: \\sum_{i=0}^{\\xi-1} |x_i| &lt;\\infty,~ x_i=x_{i+\\xi},~ i \\in \\mathbb{R} \\right\\} \\\\ \\overset{DTFS}{\\Longleftrightarrow} \\left\\{\\hat x_k: \\sum_{k=0}^{\\xi-1} |\\hat x_k| &lt;\\infty,~\\hat x_k = \\hat x_{k+\\xi} ,~ k \\in \\mathbb{Z} \\right\\}.\\)\n\n- 여기에서 \\(\\zeta\\)는 (시간축에서) 연속신호의 주기라고 정의하고 \\(\\xi\\)는 (시간축에서) 이산신호의 주기라고 약속하자. 주파수영역이 디스크릿하게 나오면 FS라고 부르고 주파수영역이 컨티뉴어스하게 나오면 FT라고 부른다. 특이한점은 비주기-이산신호에 대한 FS \\(\\hat x(\\omega)\\)는 주파수 영역에서 주기가 \\(2\\pi\\)임을 파악할 수 있다. 이유는 궁금해하지말자. (내생각에 그냥 \\(\\omega\\)를 적당히 스케일링하여 주기를 \\(2\\pi\\)로 맞췄을 거다.)\n- 이제 짜증나는 적분가능조건따위는 버리도록 하자. 대신에 각 경우에 퓨리에변환(혹은series)과 그 역이 어떻게 정의되는지 알아보자. 그리고 외우자. 각 신호가 어떠한 도메인에서 정의되는지만 잘 파악하면 의외로 외우기 쉽다.\ncase 1. 연속-비주기\n\n\\(\\left\\{x(t): x(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} \\hat x(\\omega)e^{j\\omega t} d\\omega,~ t \\in \\mathbb{R} \\right\\} \\\\ \\overset{FT}{\\Longleftrightarrow} \\left\\{\\hat x(\\omega): \\hat x(\\omega)=\\int_{-\\infty}^{\\infty} x(t)e^{-j\\omega t} dt,~ \\omega \\in \\mathbb{R} \\right\\}.\\)\n\ncase 2. 연속-주기\n\n\\(\\left\\{x(t): x(t)= \\sum_{k=-\\infty}^{\\infty} \\hat x_k e^{j \\frac{2\\pi}{\\zeta} t} ,~ t \\in \\mathbb{R} \\right\\} \\\\ \\overset{FS}{\\Longleftrightarrow} \\left\\{\\hat x_k: \\hat x_k= \\frac{1}{\\zeta}\\int_{0}^{\\zeta}x(t)e^{-j \\frac{2\\pi k}{\\zeta}t}dt,~ k \\in \\mathbb{Z} \\right\\}.\\)\n\ncase 3. 이산-비주기\n\n\\(\\left\\{x_i: x_i=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}\\hat x(\\omega)e^{j \\omega i}d\\omega, ~ i \\in \\mathbb{Z} \\right\\} \\\\ \\overset{DTFT}{\\Longleftrightarrow} \\left\\{\\hat x(\\omega): \\hat x(\\omega)=\\sum_{i=-\\infty}^{\\infty}x_ie^{-j\\omega i}, ~\\omega \\in \\mathbb{R} \\right\\}.\\)\n\ncase 4. 이산-주기\n\n\\(\\left\\{x_i: x_i=\\sum_{k=0}^{\\xi-1} \\hat x_k e^{-j\\frac{2\\pi k}{\\xi}i},~ i \\in \\mathbb{Z} \\right\\} \\\\ \\overset{DTFS}{\\Longleftrightarrow} \\left\\{\\hat x_k: \\hat x_k= \\frac{1}{\\xi}\\sum_{i=0}^{\\xi-1} x_i e^{-j\\frac{2\\pi k}{\\xi}i},~ k \\in \\mathbb{Z} \\right\\}.\\)\n\n- 주기함수는 (그것이 이산이든 연속이든) 주파수영역에서의 값이 디스크릿하다. 즉 위에서 case2와 case4인 경우는 주파수영역에서 값이 디스크릿하다. 이것을 연속함수인것처럼 바꿔보면 아래와 같이 쓸 수 있다.\ncase 2. 연속-주기\n\n\\(\\left\\{x(t): x(t)= \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} \\hat x(\\omega)e^{j\\omega t} d\\omega,~ t \\in \\mathbb{R} \\right\\} \\\\ \\overset{FT}{\\Longleftrightarrow} \\left\\{\\hat x(\\omega): 2\\pi\\sum_{k=-\\infty}^{\\infty}\\left[\\frac{1}{\\zeta}\\int_{0}^{\\zeta}x(t)e^{-j \\frac{2\\pi k}{\\zeta}t}dt\\right]\\delta\\left(\\omega-\\frac{2\\pi k}{\\zeta}\\right), ~ k \\in \\mathbb{Z} \\right\\}.\\)\n\ncase 4. 이산-주기\n\n\\(\\left\\{x_i: x_i=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}\\hat x(\\omega)e^{j \\omega i}d\\omega,,~ i \\in \\mathbb{Z} \\right\\} \\\\ \\overset{DTFT}{\\Longleftrightarrow} \\left\\{\\hat x(\\omega): 2\\pi\\sum_{k=-\\infty}^{\\infty}\\left[\\frac{1}{\\xi}\\sum_{i=0}^{\\xi-1} x_i e^{-j\\frac{2\\pi k}{\\xi}i}\\right]\\delta\\left(\\omega-\\frac{2\\pi k}{\\xi}\\right),~ k \\in \\mathbb{Z} \\right\\}.\\)\n\n- 주목할것은 주기가 \\(\\zeta\\) 혹은 \\(\\xi\\) 인 함수의 주파수 응답은 오로지\n\n\\(\\omega \\in \\left\\{\\frac{2 \\pi k}{\\zeta}, k \\in \\mathbb{Z}\\right\\}\\)\n\n혹은\n\n\\(\\omega \\in \\left\\{\\frac{2 \\pi k}{\\xi}, k \\in \\mathbb{Z}\\right\\}\\)\n\n에서만 존재한다는 점이다. 또한 이산신호의 경우 \\(x_i\\)의 주기가 \\(\\xi\\) 이면 \\(\\hat{x}(\\omega)\\)의 주기역시 \\(\\xi\\) 라는점 역시 주목할만한 부분이다.\n- 주파수영역에서 디스크릿한 함수를 연속인것처럼 표현했듯이 시간영역에서 디스크릿한 함수 역시 연속인것처럼 표현할 수 있다. 예를들면 \\(\\{x_i: x_i=x(iT),~i \\in \\mathbb{Z}\\}\\) 와 같은 관계가 있는 경우 아래와 같이 표현 가능하다.\n\\[x_{\\delta}(t)=\\sum_{i=-\\infty}^{\\infty}x_i\\delta(t-iT).\\]\n이거 엄청 중요하다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "",
    "text": "- ls vs mc\n“ls”는 현재 디렉터리의 파일 및 폴더 목록을 표시하는 명령어이고, “mc”는 Midnight Commander라는 파일 관리자 프로그램\nmacOS (Homebrew를 통한 설치):\nbrew install mc\n- 파일 출력\ncat 파일이름\ncat example.txt"
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#large-file-관리",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#large-file-관리",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "large file 관리",
    "text": "large file 관리\n- Large file git push 가능하도록 하는 방법(100mb인가 넘으면 git push 오류남)\ngit lfs install\n\nGit Large File Storage (LFS)를 사용하도록 Git을 구성하는 명령어입니다.\nGit LFS는 대용량 파일을 효과적으로 관리할 수 있도록 도와주는 확장 기능\n\n- 사용법\ngit lfs track “*.npy\" \n\nnpy로 끝나는 파일 찾아서 large file 업로드 가능하도록 만들어서 push\n즉, 원하는 파일 확장자 다 large file git push 가능하도록 설정할 수 있다.\n원하는 파일만 큰 따옴표 안에 지정해서 large file git push 가능하도록 성정할 수 있다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#git-switch-maingh-pagesbranch-name",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#git-switch-maingh-pagesbranch-name",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "git switch main/gh-pages(branch name)",
    "text": "git switch main/gh-pages(branch name)\nquarto page 오류뜰때 사용할 수 있는 방법, 파일 지우는 과정 있어서 조심해서 코드 작성해야 함\n- main 브랜치\ngit switch main\n- gh-pages 브랜치\ngit switch gh-pages \n- step\n\ngit switch main으로 main으로 가서\n\ngit add .\ngit commit -m .\ngit push\n\ngit switch gh-pages 으로 gh-pages로 가서\n\n모든 파일 삭제.\n여기는 페이지의 파일이라 삭제해도 무방\nmain이 기본, gh-pages는 페이지를 만들기 위한 임시 공간으로서 여기 있는 파일 다 지워도 main에는 남아 있음\ngit add .\ngit commit -m .\ngit push 하고\n\ngit switch mainmain 다시 가서\n\ngit add .\ngit commit -m .\ngit push"
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#파일-삭제할때-사용",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#파일-삭제할때-사용",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "파일 삭제할때 사용!",
    "text": "파일 삭제할때 사용!\nrm -rf * \nrm -rf 파일명"
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#update",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#update",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "Update",
    "text": "Update\n1 다운로드 주소를 복사한다.\n2 코드를 입력한다.(wget 주소를 직접 얻어서 sudo 관리자권한으로 실행 순서), 아래는 예시임!\nwget https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.315/quarto-1.4.315-linux-amd64.deb\nsudo dpkg -i quarto-1.4.315-linux-amd64.deb \n\nsudo: 명령어를 관리자 권한으로 실행하기 위한 명령어입니다.\ndpkg: Debian 패키지 관리자입니다.\n-i: 패키지를 설치하기 위한 옵션입니다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#presentation",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#presentation",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "Presentation",
    "text": "Presentation\n- 렌더링, latex의 build랑 같은 개념(문서화한다는 뜻으로 보면 될 듯)\nquarto render 파일이름.파일형식\n\nqmd, ipynb,…\n\n- 미리보기\nquarto preview 파일이름.파일형식 --no-browser --host 0.0.0.0\n\n--no-browser 안 쓰면 자동으로 브라우저 오픈된다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#nano",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#nano",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "nano",
    "text": "nano\n- 설치\nsudo apt-get install nano   # Debian/Ubuntu\nsudo yum install nano       # Red Hat/Fedora\n- 여는 법\nnano 파일이름.파일형식(nano ref.bib)\n- 사용법\n\n저장: Ctrl + O\n종료: Ctrl + X\n특수 문자: ^는 Ctrl을 나타냅니다. 예를 들어, ^G는 Ctrl + G를 의미합니다\n\n\nnano로 매크로같은 명령어 파일 만들기\n1 sh확장자 가진 push 파일을 만들기\nnano push.sh\n터미널에서 보면 파일명이 흰색임\n2 실행하고 싶은 명령어 입력\n\ngit add . / git commit -m . / git push 등 하고 싶은 명령어 넣고\n\n3 실행 권한 추가하기\nchmod +x push.sh\n터미널에서 보면 파일명이 녹색으로 바뀜\n\nchange mode, 실행권한을 추가하라(+x) push라는 sh 확장자를 가진 파일에\n\n4 시행\n\n이제 ~/push.sh 를 해당 quarto 블로그 들어가서 입력하여 시행만 하면 된다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#vim",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#vim",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "Vim",
    "text": "Vim\n- 설치\nsudo apt-get install vim   # Debian/Ubuntu\nsudo yum install vim       # Red Hat/Fedora\n- 여는 법\nvim 파일이름.파일형식\n- 사용법\n\n편집 모드로 전환: i 키를 누르기\n편집 완료 후 저장 및 종료: Esc 키를 누르고 :wq 입력 후 엔터\n\n수정하고 q만 누르면 에러 뜬다. 저장 할 게 있기 때문이다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#가상환경-관련",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#가상환경-관련",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "가상환경 관련",
    "text": "가상환경 관련\n- 가상환경 생성\nconda create -n my_python_env python==3.8\n\nconda create: Conda를 사용하여 가상 환경을 생성하는 명령어입니다.\n-n my_python_env: 가상 환경의 이름을 설정하는 옵션으로, 여기서는 “my_python_env”로 지정되었습니다.\npython==3.8: 생성할 가상 환경에 설치할 Python 버전을 지정하는 옵션으로, 여기서는 Python 3.8로 지정되었습니다.\n\n버전 지정 안 하면 최신 버전으로 지정된다.\n\n\n- 버전 확인\nconda –version\n\nconda --version: 현재 설치된 Conda의 버전을 확인하는 명령어입니다.\n\n- 가상환경 업데이트\nconda update\n\nConda 자체를 업데이트하는 명령어입니다. Conda를 최신 버전으로 업데이트합니다.\n\n- 가상환경 활성화\nconda activate YOUR_ENV_NAME\n\n생성한 가상 환경을 활성화하는 명령어입니다. YOUR_ENV_NAME 부분에는 실제 가상 환경의 이름이 들어갑니다.\n\n- 가상환경 비활성화\nconda deactivate\n\n현재 활성화된 가상 환경을 비활성화하는 명령어입니다.\n\n- 가상환경 목록 확인\nconda env list\nconda info --envs\n\n현재 시스템에 설치된 가상 환경 목록을 확인하는 명령어입니다.\n\n- 가상환경 삭제\nconda env remove --name YOUR_ENV_NAME --all\n\n지정된 가상 환경을 삭제하는 명령어입니다.\n--name YOUR_ENV_NAME: 삭제할 가상 환경의 이름을 지정하는 옵션입니다.\n--all: 가상 환경에 포함된 모든 패키지를 함께 제거하는 옵션입니다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#r-관련",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#r-관련",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "R 관련",
    "text": "R 관련\n- r 실행\nconda install -c conda-forge r-essentials \n\nconda install: Conda를 사용하여 패키지를 설치하는 명령어입니다.\n-c conda-forge: 패키지를 검색하고 가져올 채널을 지정하는 옵션입니다. 여기서는 conda-forge 채널에서 패키지를 찾아 가져오라는 의미입니다. conda-forge는 커뮤니티가 관리하는 Conda 패키지 저장소입니다.\nr-essentials: R 언어와 관련된 필수 패키지들을 묶어놓은 메타 패키지입니다. R 언어의 중요한 패키지들을 포함하고 있어, R을 사용하는데 필수적인 패키지들을 편리하게 설치할 수 있게 도와줍니다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#바로-설치되도록-환경-저장하는법",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#바로-설치되도록-환경-저장하는법",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "바로 설치되도록 환경 저장하는법",
    "text": "바로 설치되도록 환경 저장하는법\n1\npip freeze &gt; requirements.txt\n2\nconda list -e &gt; requirements_conda.txt\n\n이 명령어는 현재 Conda 환경에 설치된 패키지들과 그 버전을 나열하여 “requirements_conda.txt” 파일에 저장합니다.\n-e 옵션은 Conda 환경의 정확한 사양(specification)을 나열하도록 합니다. 이 또한 프로젝트의 의존성을 추적하고, 다른 환경에서 동일한 패키지를 설치하는 데 사용됩니다.\n결과 파일은 일반적으로 Conda 환경을 재현하는 데 사용됩니다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#파일-복사해서-이동하기",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#파일-복사해서-이동하기",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "파일 복사해서 이동하기",
    "text": "파일 복사해서 이동하기\nsummary.txt파일을 copy(cp)해서 ~/Dropbox 폴더로 옮기기\ncp summery.txt ~/Dropbox\n\ncp: “copy”의 약자로, 파일을 복사하는 명령어입니다.\nsummery.txt: 복사할 대상 파일의 이름입니다. 여기서는 “summery.txt” 파일을 대상으로 선택했습니다.\n~/Dropbox: ~는 홈 디렉토리를 나타내며, ~/Dropbox는 현재 사용자의 홈 디렉토리 내에 있는 “Dropbox” 디렉토리를 가리킵니다. 따라서 복사된 파일은 사용자의 Dropbox 디렉토리로 이동됩니다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#nvidia-smi",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#nvidia-smi",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "nvidia-smi",
    "text": "nvidia-smi\n일반적인 출력 결과 아래\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 460.39       Driver Version: 460.39       CUDA Version: 11.2     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  Tesla K80           Off  | 00000000:00:1E.0 Off |                    0 |\n| N/A   52C    P0    58W / 149W |    299MiB / 11441MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n\nDriver Version: 현재 설치된 NVIDIA GPU 드라이버의 버전입니다.\nCUDA Version: 현재 설치된 CUDA (Compute Unified Device Architecture) 버전입니다.\nGPU Name: GPU의 모델명입니다.\nFan, Temp, Perf, Pwr: GPU의 팬 상태, 온도, 성능, 전력 사용량 등을 보여줍니다.\nMemory Usage: GPU 메모리 사용량 및 총 메모리 크기를 보여줍니다.\nGPU-Util: GPU의 사용률을 나타냅니다.\nCompute M.: 현재 GPU에서 사용 중인 컴퓨트 모드를 나타냅니다."
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#apt-get",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#apt-get",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "apt-get",
    "text": "apt-get\n사용되는 곳: 주로 Debian 및 Ubuntu 리눅스 기반 시스템에서 사용\n패키지 형식: 시스템 수준의 패키지를 설치하는 데 사용\nUbuntu level의 패키지 설치\n예시:\n\nsudo apt-get update\nsudo apt-get install 패키지이름\nwget\ncurl"
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#pip",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#pip",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "pip",
    "text": "pip\n사용되는 곳: Python 패키지를 설치 및 관리하는 데 사용\n패키지 형식: Python 패키지를 설치하는 데 사용\nPython Package만 가능 numpy, pandas 등\n예시:\n\npip install 패키지이름"
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#conda",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#conda",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "conda",
    "text": "conda\n사용되는 곳: 데이터 과학 및 머신러닝 패키지를 관리하는 데 주로 사용\n패키지 형식: Python 및 다른 언어의 패키지를 설치할 수 있으며, 가상 환경과 종속성 관리에 강한 포커스가 있음.\n패키지를 필요한 다른 패키지와 함께 연동으로 설치해줌\n예시:\n\nconda install 패키지이름"
  },
  {
    "objectID": "posts/1_Note/2023-12-31-note_git_blog.html#install.packages",
    "href": "posts/1_Note/2023-12-31-note_git_blog.html#install.packages",
    "title": "[Note] Tips of Linux, Git and Blog",
    "section": "install.packages(““)",
    "text": "install.packages(““)\n사용되는 곳: R 언어에서 사용\n패키지 형식: R 패키지를 설치하는 데 사용\n예시:\n\ninstall.packages(\"패키지이름\")"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html",
    "title": "DSTBX2023(4)",
    "section": "",
    "text": "- lsof 프로그램 설치\napt-get install lsof\napt install lsof \n- 23052 포트를 사용하는 프로그램이 있는지 파악\nlsof -i :23052\n결과는 아래와 같은 예시로 나옴\nCOMMAND      PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME\njupyter-l 862165 root    6u  IPv4 383551982      0t0  TCP *:23052 (LISTEN)\njupyter-l 862165 root   12u  IPv4 383671448      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59663 (ESTABLISHED)\njupyter-l 862165 root   16u  IPv4 383628690      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59664 (ESTABLISHED)\njupyter-l 862165 root   29u  IPv4 383612831      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59720 (ESTABLISHED)\njupyter-l 862165 root   34u  IPv4 383671463      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59667 (ESTABLISHED)\n- 각자해볼것: ssh 접속시 사용하는 포트 제외하고 나머지 포트를 쓰고 있는 프로그램은 삭제\nkill {PID}\n위의 예시의 경우\nkill 862165\n- 주피터랩 평생켜놓기 + 끄기 (이거 자유자재로 할 수 있어야함)\n- PID를 조회하는 다른방법\nps aux | grep jupyter"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습41-포트정리-lsof",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습41-포트정리-lsof",
    "title": "DSTBX2023(4)",
    "section": "",
    "text": "- lsof 프로그램 설치\napt-get install lsof\napt install lsof \n- 23052 포트를 사용하는 프로그램이 있는지 파악\nlsof -i :23052\n결과는 아래와 같은 예시로 나옴\nCOMMAND      PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME\njupyter-l 862165 root    6u  IPv4 383551982      0t0  TCP *:23052 (LISTEN)\njupyter-l 862165 root   12u  IPv4 383671448      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59663 (ESTABLISHED)\njupyter-l 862165 root   16u  IPv4 383628690      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59664 (ESTABLISHED)\njupyter-l 862165 root   29u  IPv4 383612831      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59720 (ESTABLISHED)\njupyter-l 862165 root   34u  IPv4 383671463      0t0  TCP 8c8831330c68:23052-&gt;210.117.173.181:59667 (ESTABLISHED)\n- 각자해볼것: ssh 접속시 사용하는 포트 제외하고 나머지 포트를 쓰고 있는 프로그램은 삭제\nkill {PID}\n위의 예시의 경우\nkill 862165\n- 주피터랩 평생켜놓기 + 끄기 (이거 자유자재로 할 수 있어야함)\n- PID를 조회하는 다른방법\nps aux | grep jupyter"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습42-py310-co-환경에-주피터를-설치",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습42-py310-co-환경에-주피터를-설치",
    "title": "DSTBX2023(4)",
    "section": "실습42: py310, co 환경에 주피터를 설치",
    "text": "실습42: py310, co 환경에 주피터를 설치\n- 아래를 설치\n(py310) conda install -c conda-forge jupyterlab \n(py310) conda install -c conda-forge notebook \n(co) conda install -c conda-forge jupyterlab \n(co) conda install -c conda-forge notebook \n- 이래야 해당환경에서 주피터를 연결할 수 있음."
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습43-py310-co-환경에-주피터랩을-각각-띄우기",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습43-py310-co-환경에-주피터랩을-각각-띄우기",
    "title": "DSTBX2023(4)",
    "section": "실습43: py310, co 환경에 주피터랩을 각각 띄우기",
    "text": "실습43: py310, co 환경에 주피터랩을 각각 띄우기\n- 아래를 이용\n(py310) jupyter lab --port 23052 \n(co) jupyter lab --port 33052 \n\n터미널 여러개 쓰는게 편할걸요?\n\n- 참고로 위의 명령은 vi jupyter_notebook_config.py 에 대한 설정이 올바르게 끝난 상태에서 가능한 명령어임.\n- 이제 23052 와 33052 는 각각 다른 파이썬 커널과 연결됨. 아래를 각각 실행해보자.\nimport pandas as pd\ndf = pd.DataFrame({'A':[2143,2143],'B':['-',3456]})\ndf.map(lambda x: 0 if x == '-' else x)\n결과가 어떠한가? 왜 이런 결과가 나왔다고 생각하는가?"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습44-quarto-preview",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습44-quarto-preview",
    "title": "DSTBX2023(4)",
    "section": "실습44: quarto preview",
    "text": "실습44: quarto preview\n- 블로그를 미리보면서 편집하고 싶음.\n- 1개의 포트에는 (py310)에 설치된 jupyterlab을 할당 + 1개의 포트에는 quarto preview를 할당\nquarto preview --host \"0.0.0.0\" --port 43052\n- 개인적소감: 반응이 살짝 느려서 별로임. (좋을때: 처음에는 좋음)"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습45-quarto-preview-test.qmd",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습45-quarto-preview-test.qmd",
    "title": "DSTBX2023(4)",
    "section": "실습45: quarto preview test.qmd",
    "text": "실습45: quarto preview test.qmd\n- 파일하나만 찍어서 preview\nquarto preview day4.qmd --host \"0.0.0.0\" --port 43052\n- QMD파일은 RMD의 진화. (구 Rmarkdown)\n\nMD –&gt; RMD, QMD\n\n- 마크다운 문법이 가능함. (MD의 기능)\n\n수식\n목록화\n\n- 또한 R, Python, Julia 등의 코드를 삽입하여 실행할 수 있음. (RMD, QMD의 기능??)\n```{python}\nimport matplotlib.pyplot as plt\na = [1,2,4]\na = a+[3] \nplt.plot(a)\n```\n- quarto는 .ipynb의 렌더링과 .qmd의 렌더링 모두 지원한다.\n- 그런데 좀 이상하지 않아요??\n\n\n\n\n\n\nNote\n\n\n\n.qmd를 사용한 파일이 있는 quarto 블로그나 대쉬보드를\n가상환경에서 render하면 그 환경의 패키지 버전을 사용하고\nbase 에서 render하면 base의 패키지 버전들을 사용함"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습46-py310.qmd-co.qmd-hw",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습46-py310.qmd-co.qmd-hw",
    "title": "DSTBX2023(4)",
    "section": "실습46: py310.qmd / co.qmd (hw)",
    "text": "실습46: py310.qmd / co.qmd (hw)\n- 해보기1: 아래와 같이 py310.qmd 파일을 만들고 (py310)에서 preview 해보기\n\n\npy310.qmd\n\n```{python}\nimport pandas as pd\ndf = pd.DataFrame({'A':[2143,2143],'B':['-',3456]})\ndf.map(lambda x: 0 if x == '-' else x)\n```\n\n- 해보기2: 아래와 같이 co.qmd 파일을 만들고 (co)에서 preview 해보기\n\n\nco.qmd\n\n```{python}\nimport pandas as pd\ndf = pd.DataFrame({'A':[2143,2143],'B':['-',3456]})\ndf.map(lambda x: 0 if x == '-' else x)\n```"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습47-rpython-사용가능한-개발환경-만들기",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습47-rpython-사용가능한-개발환경-만들기",
    "title": "DSTBX2023(4)",
    "section": "실습47: R+Python 사용가능한 개발환경 만들기",
    "text": "실습47: R+Python 사용가능한 개발환경 만들기\n- 아래를 실행\nconda create -n rpy \nconda activate rpy\nconda install -c conda-forge r-essentials\nconda install -c conda-forge plotly\nconda install -c conda-forge rpy2\n- 여기에서 conda install -c conda-forge r-essentials로 인하여 R, Python, Jupyter 가 모두 최신버전으로 설치된다.\n- 또한 R에는 이미 tidyverse, IRkernel 등의 패키지가 기본으로 깔려있다.\n- R이 설치된 경로를 찾아보자.\n- 수틀리면 이 R을 지우면 된다.\n- R이 설치될 수 있는 3가지 시나리오\nsudo apt-get install r-base # r 공식홈페이지, 수틀리면 리눅스 포맷  \n(base) conda install -c conda-forge ... # 수틀리면 아나콘다 삭제해야함. \n(rpy) conda install -c conda-forge ... # 수틀리면 가상환경 삭제"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습48-포스트-업로드",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습48-포스트-업로드",
    "title": "DSTBX2023(4)",
    "section": "실습48: 포스트 업로드",
    "text": "실습48: 포스트 업로드\n- 해보기1: 적당한 ?.qmd 파일을 만들고 아래와 같은 포스트를 올려보자.\n- 해보기2: 적당한 ?.ipynb 파일을 만들고 아래와 같은 포스트를 올려보자.\n- 해보기3: 적당한 ?.qmd 파일을 만들고 아래와 같은 포스트를 올려보자."
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습49-포스트-업로드-쉽게-하는-방법",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습49-포스트-업로드-쉽게-하는-방법",
    "title": "DSTBX2023(4)",
    "section": "실습49: 포스트 업로드 쉽게 하는 방법",
    "text": "실습49: 포스트 업로드 쉽게 하는 방법\n- 스크립트 파일 만들어요..\n\n\nupload\n\nquarto render \ngit add .\ngit commit -m .\ngit push \n\n\n\n\n\n\n\nTip\n\n\n\nupload.sh를 vi로 위를 입력 후 만들어\n여기에 저장해서\n./upload.sh\n이렇개 실행해"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습50-스크립트-파일의-위치",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습50-스크립트-파일의-위치",
    "title": "DSTBX2023(4)",
    "section": "실습50: 스크립트 파일의 위치?",
    "text": "실습50: 스크립트 파일의 위치?\n- 아래파일을 어디에 두면 좋을까?\n\n\nupload.sh\n\nquarto render \ngit add .\ngit commit -m .\ngit push \n\n- 저는 뭐 그냥.. 홈에두긴해요\n`cp` copy\n`root` 가기 `cd/`\n\n\n\n\n\n\nCaution\n\n\n\n\n\nroot의 bin으로 가면 리눅스 코드들 존재\n여기에서 우리가 자주 쓰는 ls도 mv ls ls2이런 식으로 이름 바꿀 수 있음."
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습51-실행파일들의-위치",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습51-실행파일들의-위치",
    "title": "DSTBX2023(4)",
    "section": "실습51: 실행파일들의 위치",
    "text": "실습51: 실행파일들의 위치"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습52-ls의-이름바꾸기-실습추천x",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습52-ls의-이름바꾸기-실습추천x",
    "title": "DSTBX2023(4)",
    "section": "실습52: ls의 이름바꾸기 (실습추천X)",
    "text": "실습52: ls의 이름바꾸기 (실습추천X)"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습53-bash커널의-이해",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습53-bash커널의-이해",
    "title": "DSTBX2023(4)",
    "section": "실습53: bash커널의 이해",
    "text": "실습53: bash커널의 이해\n- 예비학습: 파이썬 커널\n- 예시1\na='askdfj;alskdjf;klajsdf'\na\n$a\necho $a\n- 예시2\na=('개' '고양이' '토끼')\necho $a \necho ${a}\necho ${a[0]}\necho ${a[1]}\necho ${a[@]}\n- 예시3\ncmd_list=(ls \"ls -a\") \n${cmd_list}\n${cmd_list[0]}\n${cmd_list[1]}\n- 걱정: 근데 그러면 내 리눅스에는 평생 a, cmd_list 라는 변수가 있는거야?"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습54-path-우분투에-저장된-영구변수",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습54-path-우분투에-저장된-영구변수",
    "title": "DSTBX2023(4)",
    "section": "실습54: PATH – 우분투에 저장된 영구변수",
    "text": "실습54: PATH – 우분투에 저장된 영구변수\n- 깨끗한 우분투에서\n$PATH # 쳐보세요\n- 아나콘다가 설치된 우분투에서\n$PATH # 쳐보세요\n\n\n\n\n\n\nNote\n\n\n\nconda 는 path를 바꿔주는 역할로 단순히 이해할 수 있다."
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습54-용어의-정리",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습54-용어의-정리",
    "title": "DSTBX2023(4)",
    "section": "실습54: 용어의 정리",
    "text": "실습54: 용어의 정리\n- 폴더와 파일\n\n폴더: 끝에 /로 끝남. (근데 생략가능함)\n파일: 끝에 /로 끝나지 않음.\n\n- 개념: 모든것은 파일과 폴더의 집합이다.\n- 183번 컴퓨터로 가보자.\n- 우분투컴퓨터에 guebin이라는 유저를 새롭게 추가했다 = /home/guebin/ 를 만듦\n- 우분투에서 깃을 설치했다 = 우분투에서 sudo apt-get install git을 실행했다. = /usr/bin/에 git이라는 파일이 생겼다. = /usr/bin/git 생성\n- ls는 우분투에 이미 내장되어있는 기능이다. = ls는 우분투에 이미 내장되어있는 명령파일이다. = 우분투를 설치하면 /usr/bin/에 ls라는 파일이 이미 있다.\n- 우분투에 guebin이라는 유저를 등록했다. 이후에 guebin이라는 유저가 아나콘다를 설치했다. = 우분투에 guebin이라는 유저를 등록했다. 이후에 guebin이라는 유저는 아나콘다를 이용하여 가상의 (base)환경을 만들었다. = /home/guebin/anaconda3/폴더가 만들어졌다는 의미.\n- 우분투에 guebin이라는 (슈퍼)유저를 등록했다. 이후에 guebin이라는 (슈퍼)유저가 루트권한을 이용하여 git을 설치했다. = /home/guebin/ 이 만들어짐 + /usr/bin/git 생성"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습55-폴더의-레벨",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습55-폴더의-레벨",
    "title": "DSTBX2023(4)",
    "section": "실습55: 폴더의 레벨",
    "text": "실습55: 폴더의 레벨\n- 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n- 186번 컴퓨터에는 3개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nroot우분투-(base)\nroot우분투-(py310)\n\n- guebin이라는 윈도우유저가 anaconda (base)를 이용하는 경우 2개의 컴퓨터가 존재한다.\n\nguebin윈도우\nguebin윈도우-(base)"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습56-난-어디에서-깃을-설치했어",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습56-난-어디에서-깃을-설치했어",
    "title": "DSTBX2023(4)",
    "section": "실습56: 난 어디에서 깃을 설치했어?",
    "text": "실습56: 난 어디에서 깃을 설치했어?\n- 문제1: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래의 명령을 통하여 깃을 설치했다.\n(base) sudo apt-get install git \n깃은 어디에 설치되어있는가?\n답: 1에\n- 문제2: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래와 같이 깃을 설치했다.\n(py310) sudo apt-get install git \n깃은 어디에 설치되어있는가?\n답: 1에\n- 문제3: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래의 명령을 통하여 깃을 설치했다.\n(py310) conda install -c conda-forge git \n깃은 어디에 설치되어있는가?\n답: 4에\n- 문제4: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래와 같이 깃을 설치했다.\n(base) conda install -c conda-forge git\n깃은 어디에 설치되어있는가? (이때는 base에 설치된 git이 다른환경에 영향을 주지 않음)\n답: 3에"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습57-난-어디에서-quarto를-설치했어",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습57-난-어디에서-quarto를-설치했어",
    "title": "DSTBX2023(4)",
    "section": "실습57: 난 어디에서 quarto를 설치했어?",
    "text": "실습57: 난 어디에서 quarto를 설치했어?\n- 문제1: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래의 명령을 통하여 quarto를 설치했다.\n(base) wget https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.533/quarto-1.4.533-linux-amd64.deb\n(base) sudo dpkg -i quarto-1.4.533-linux-amd64.deb \nquarto는 어디에 설치되어있는가?\n답: 1에\n- 문제2: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래의 명령을 통하여 quarto를 설치했다.\n(base) wget https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.533/quarto-1.4.533-linux-amd64.deb\n(base) conda activate py310 \n(py310) sudo dpkg -i quarto-1.4.533-linux-amd64.deb \nquarto는 어디에 설치되어있는가?\n답: 1에\n- 문제3: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래의 명령을 통하여 quarto를 설치했다.\n(py310) wget https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.533/quarto-1.4.533-linux-amd64.deb\n(py310) sudo dpkg -i quarto-1.4.533-linux-amd64.deb \nquarto는 어디에 설치되어있는가?\n답: 1에\n- 문제4: 183번 컴퓨터에는 4개의 중첩된 컴퓨터(=폴더)가 존재한다.\n\nroot우분투\nguebin우분투\nguebin우분투-(base)\nguebin우분투-(py310)\n\n아래의 명령을 통하여 quarto를 설치했다.\n(py310) wget https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.533/quarto-1.4.533-linux-amd64.deb\n(py310) conda activate base \n(base) sudo dpkg -i quarto-1.4.533-linux-amd64.deb \nquarto는 어디에 설치되어있는가?\n답: 1에"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습58-난-어디에서-upload.sh를-설치했어",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습58-난-어디에서-upload.sh를-설치했어",
    "title": "DSTBX2023(4)",
    "section": "실습58: 난 어디에서 upload.sh를 설치했어?",
    "text": "실습58: 난 어디에서 upload.sh를 설치했어?"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습59-여러가지-프로그램-여러가지-설치방법",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습59-여러가지-프로그램-여러가지-설치방법",
    "title": "DSTBX2023(4)",
    "section": "실습59: 여러가지 프로그램, 여러가지 설치방법",
    "text": "실습59: 여러가지 프로그램, 여러가지 설치방법\n- 우분투자체의 프로그램\n\n우분투 자체의 프로그램 예시: git, quarto, python, R, anaconda, vi, ssh, wget, vscode\n우분투 자체의 프로그램은 다시 모든 유저가 영향을 받는 받는 프로그램과 그렇지 않은 프로그램이 있음\n우분투 자체의 프로그램을 설치하는 방법들\n\nsudo apt install git \nsudo apt-get install git \nsudo dpkg -i quarto-1.4.533-linux-amd64.deb \nbash Anaconda3-2019.03-Linux-x86_64.sh\nsudo gdebi rstudio-server-1.2.5033-amd64.deb\n# 기타 파일을 넣을 수 있는 모든 방법 (예를들면 압축파일 다운로드후 풀기) \n\n\n\n\n\n\nNote\n\n\n\nsudo apt install git\nsudo apt-get install git\n둘이 같음\n\n\n\n\n\n\n\n\nNote\n\n\n\nsh확장자는 bash로 설치\n\n\n- 아나콘다(=base)에 종속된 프로그램\n\n아나콘다내에 종속된 프로그램의 예시: conda, python, R, jupyter\n아나콘다에 종속된 프로그램은 anaconda3 폴더안에 있음.\n\n- 아나콘다환경(=py310)에 종속시킬 수 “있는” 프로그램\n\n아나콘다내에 종속된 프로그램의 예시: python, R, jupyter\n아나콘다환경에 종속된 프로그램은 anaconda3/envs/py310 와 같은 형식의 폴더안에 있음.\n\n- 파이썬에 종속된 프로그램 (=파이썬패키지=파이썬라이브러리=파이썬모듈)\n\n파이썬에 종속된 프로그램 예시: numpy, pandas\n얘네들이 어디에 깔리는지는 그때그때 다름\n지우는 방법도 그때그때 다르겠지? (젤 편하고 깔끔하게 지우려면?)\n\n- R에 종속된 프로그램 (=R패키지=R라이브러리)\n\nR에 종속된 프로그램의 예시: tidyverse\n얘들이 어디 깔리는지도 그때그때 다름\n지우는 방법도 그때그때 다르겠지? (젤 편하고 깔끔하게 지우려면?)\n\n- 질문1: pip install vs conda install\n\n설치되는 레벨의 차이\n설치에서 느껴지는 편안함의 차이\n삭제할때 느껴지는 불편함의 차이\npip install pandas는 사실 install.packages(\"tidyverse\")에 대응되는 것임\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\npip 으로 가상환경 내에서 깔고 지워버리기..\nconda는 설치할 수 있는 패키지의 영역이 많다보니 나중에 삭제하고 싶은 패키지가 있을 떄 찾기 힘듦 -&gt; 가상환경 새로 만들어버리자~\n\n\n\n- 질문2: 언제 pip install을 쓰고 언제 conda install을 써야할까? 답은없어요. 저는 대충 아래와 같이 합니다. (해보고 수틀리면 그냥 환경날리세여)\n\n만만한 패키지는 pip install 로 설치: numpy, pandas\n까다로운 패키지는 conda install 로 설치: torch, autogluon"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습60-base에서-rpy에-있는-r-실행",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습60-base에서-rpy에-있는-r-실행",
    "title": "DSTBX2023(4)",
    "section": "실습60: (base)에서 (rpy)에 있는 R 실행",
    "text": "실습60: (base)에서 (rpy)에 있는 R 실행\n- 원래는 불가능한 일이겠죠?\n- 억지로 가능하게 하려면?\n해당 환경가서 ./R 실행\n보통 anaconda/envs/가상환경이름/bin 에 있음"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습61-rpy에서-ept라는-r패키지-설치하고-위치파악하기",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습61-rpy에서-ept라는-r패키지-설치하고-위치파악하기",
    "title": "DSTBX2023(4)",
    "section": "실습61: (rpy)에서 EPT라는 R패키지 설치하고 위치파악하기",
    "text": "실습61: (rpy)에서 EPT라는 R패키지 설치하고 위치파악하기\n- R을 실행\nconda activate rpy\nR\n- 또다른 터미널을 열고 아래의 폴더로 이동 + 패키지확인\ncd ~/anaconda3/envs/rpy/lib/R/library\nls\n- EPT패키지 설치\ninstall.packages(\"EPT\")\n- ~/anaconda3/envs/rpy/lib/R/library에서 확인"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습62-rpy에-설치된-r과-주피터-연결하기",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습62-rpy에-설치된-r과-주피터-연결하기",
    "title": "DSTBX2023(4)",
    "section": "실습62: (rpy)에 설치된 R과 주피터 연결하기",
    "text": "실습62: (rpy)에 설치된 R과 주피터 연결하기\n- R을 실행\nIRkernel::installspec()\n- 주피터 실행"
  },
  {
    "objectID": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습63-대시보드-프리젠테이션-베끼기",
    "href": "posts/1_Note/2024-01-05-DSTBX2023(4).html#실습63-대시보드-프리젠테이션-베끼기",
    "title": "DSTBX2023(4)",
    "section": "실습63: 대시보드, 프리젠테이션 베끼기",
    "text": "실습63: 대시보드, 프리젠테이션 베끼기\n- ref: https://guebin.github.io/DV2023/posts/14wk-1.html\n- 대시보드\n\nhttps://guebin.github.io/DASH\nhttps://quarto.org/docs/dashboards/\n\n- 프리젠테이션\n\nhttps://quarto.org/docs/presentations/revealjs/demo/#/interactive-slides-1\nhttps://quarto.org/docs/presentations/revealjs/"
  },
  {
    "objectID": "posts/1_Note/2022-12-31-Space-study.html",
    "href": "posts/1_Note/2022-12-31-Space-study.html",
    "title": "Study for Spaces",
    "section": "",
    "text": "Spaces"
  },
  {
    "objectID": "posts/1_Note/2022-12-31-Space-study.html#내적공간",
    "href": "posts/1_Note/2022-12-31-Space-study.html#내적공간",
    "title": "Study for Spaces",
    "section": "내적공간",
    "text": "내적공간\n\\[|a||b| \\cos \\theta\\]\n\n길이 + 각의 개념\n\nProjection"
  },
  {
    "objectID": "posts/1_Note/2022-12-31-Space-study.html#바나흐공간",
    "href": "posts/1_Note/2022-12-31-Space-study.html#바나흐공간",
    "title": "Study for Spaces",
    "section": "바나흐공간",
    "text": "바나흐공간\n\\[|---|\\]\n\n길이 + 극한의 개념"
  },
  {
    "objectID": "posts/1_Note/2022-12-31-Space-study.html#노름공간",
    "href": "posts/1_Note/2022-12-31-Space-study.html#노름공간",
    "title": "Study for Spaces",
    "section": "노름공간",
    "text": "노름공간\n\\[|   |\\]\n\n길이의 개념"
  },
  {
    "objectID": "posts/1_Note/2022-12-31-Space-study.html#힐베르트공간유클리드-비유클리드-모두-존재",
    "href": "posts/1_Note/2022-12-31-Space-study.html#힐베르트공간유클리드-비유클리드-모두-존재",
    "title": "Study for Spaces",
    "section": "힐베르트공간(유클리드 + 비유클리드 모두 존재)",
    "text": "힐베르트공간(유클리드 + 비유클리드 모두 존재)\n퓨리에 해석 - 길이 + 각 + 극한의 개념"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "",
    "text": "MIG = Multi Instance GPU\ngi = GPU Instance \\(\\rightarrow\\) 가상의 GPU\nnvidia-smi mig \\(\\rightarrow\\) 도움말 보기"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#a.-mig-모드-enable",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#a.-mig-모드-enable",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "A. MIG 모드 enable",
    "text": "A. MIG 모드 enable\n- root 획득\nsudo -i \n\\(\\rightarrow\\) 관리자 권한 획득\n- 모든 GPU enable\nnvidia-smi -mig 1 \nsudo systemctl stop nvidia-mig-manager.service\nsudo systemctl disable nvidia-mig-manager.service\nreboot\nnvidia-smi -mig 1 \n\\(\\rightarrow\\) 여기서 1은 모든 GPU를 의미하는 듯? 즉, 모든 GPU를 mig 모드로 하겠다는 뜻\n\\(\\rightarrow\\) mig 모드 해서 GPU를 나누지 않아도 사용하기 때문에, mig 모드 다 해놔도 괜찮~\n- 모든 특정 GPU만 enable\n#nvidia-smi -i {GPUdev-ID} -mig 1\nnvidia-smi -i 0 -mig 1 \nsudo systemctl stop nvidia-mig-manager.service\nsudo systemctl disable nvidia-mig-manager.service\nreboot \n\\(\\rightarrow\\) 왜인진 모르지만.. 위 sudo~ 를 실행해주어야 함..\n- GPU가 MIG 모드로 되면 아래와 같이 GPU-Util 에 N/A로 표시된다. 아래는 0,1,2,4 에 대응하는 GPU가 MIG모드로 설정된 상태임\n\n\n\nScreenshot 2023-11-22 at 23.55.06.png\n\n\n\\(\\rightarrow\\) 여기에 0,1,2,4의 GPU가 있고, 3은 아님. GPU를 gi로 나누면 MIG deviced에 나타남.\n\\(\\rightarrow\\) 단, 나중에 이 4의 GPU는 3으로 보고 gi 만들어야 함."
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#b.-gpu-gi-ci-확인",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#b.-gpu-gi-ci-확인",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "B. GPU, GI, CI 확인",
    "text": "B. GPU, GI, CI 확인\n- 용어정리\n\nGPU: 말 그대로 GPU\nGI: GPU INSTANCE, 하나의 GPU에 여러개의 GPU INSTANCE가 존재할 수 있음.\nCI: COMPUTE INSTANCE, 하나의 GPU INSTANCE에 여러개의 COMPUTE INSTANCE를 만들 수 있음.\n\n- 상황확인\nnvidia-smi \n\n\n\nScreenshot 2023-11-22 at 23.53.41.png\n\n\n- GPU의 해석\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 470.141.03   Driver Version: 470.141.03   CUDA Version: 11.4     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  NVIDIA A100-SXM...  On   | 00000000:01:00.0 Off |                   On |\n| N/A   37C    P0    53W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   1  NVIDIA A100-SXM...  On   | 00000000:47:00.0 Off |                   On |\n| N/A   38C    P0    52W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   2  NVIDIA A100-SXM...  On   | 00000000:81:00.0 Off |                   On |\n| N/A   37C    P0    54W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   3  NVIDIA DGX Display  On   | 00000000:C1:00.0 Off |                  N/A |\n| 36%   39C    P8    N/A /  50W |      1MiB /  3911MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n|   4  NVIDIA A100-SXM...  On   | 00000000:C2:00.0 Off |                   On |\n| N/A   37C    P0    55W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n총 4개의 GPU가 있으며 아이디는 0,1,2,4 임을 알 수 있다.\n- GPUdev-ID, GI-ID, CI-ID, MIGdev-ID 확인\n+-----------------------------------------------------------------------------+\n| MIG devices:                                                                |\n+------------------+----------------------+-----------+-----------------------+\n| GPU  GI  CI  MIG |         Memory-Usage |        Vol|         Shared        |\n|      ID  ID  Dev |           BAR1-Usage | SM     Unc| CE  ENC  DEC  OFA  JPG|\n|                  |                      |        ECC|                       |\n|==================+======================+===========+=======================|\n|  1    0   0   0  |      0MiB / 81251MiB | 98      0 |  7   0    5    1    1 |\n|                  |      1MiB / 13107... |           |                       |\n+------------------+----------------------+-----------+-----------------------+\n|  2    0   0   0  |      0MiB / 81251MiB | 98      0 |  7   0    5    1    1 |\n|                  |      1MiB / 13107... |           |                       |\n+------------------+----------------------+-----------+-----------------------+\n아래와 같은 상황을 유추할 수 있다.\n\n\n\nGPUdev ID\nGI ID\nCI ID\nMIGdev ID\n\n\n\n\n1\n0 (80G)\n0 (98SM)\n0\n\n\n2\n0 (80G)\n0 (98SM)\n0\n\n\n\n- 생성가능한 gi 확인\n\n\n\nScreenshot 2023-11-22 at 23.56.00.png\n\n\n- 생성가능한 ci 확인\n\n\n\nScreenshot 2023-11-22 at 23.56.31.png\n\n\n\\(\\rightarrow\\) cgi = create GPU Instance\n\\(\\rightarrow\\) lgip = list of GPU Instance Profiles"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#c.-gi-생성",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#c.-gi-생성",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "C. GI 생성",
    "text": "C. GI 생성\n- GPUdev = 4 에서 생성가능한 GI 조회\n#nvidia-smi mig -i {GPUdev-ID} -lgip\nnvidia-smi mig -i 4 -lgip\n\n\n\nScreenshot 2023-11-22 at 23.57.01.png\n\n\n- 아래에 해당하는 GI를 2개 생성하고 싶다고 하자. (GPU-INSTANCE-PROFILE-ID=9 임을 유의)\n+-----------------------------------------------------------------------------+\n| GPU instance profiles:                                                      |\n| GPU   Name             ID    Instances   Memory     P2P    SM    DEC   ENC  |\n|                              Free/Total   GiB              CE    JPEG  OFA  |\n|=============================================================================|\n|   4  MIG 3g.40gb        9     0/2        39.50      No     42     2     0   |\n|                                                             3     0     0   |\n+-----------------------------------------------------------------------------+\n#nvidia-smi mig -i {GPUdev-ID} -cgi {GPU-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -cgi 9 \nnvidia-smi mig -i 4 -cgi 9 \n\n\n\nScreenshot 2023-11-22 at 23.57.29.png\n\n\n\n2개까지는 잘 만들어지고 그 이후에는 리소스부족으로 에러발생\n\n- 만들어진 GI 확인\n\n\n\nScreenshot 2023-11-22 at 23.57.49.png\n\n\n- 생성가능한 CI 확인\nnvidia-smi mig -lcip\n\nNote: {GPU ID: GPU INSTANCE ID} 의 조합에서 {1:0}, {2:0}, {4:1}, {4:2}에 해당하는 GI에서 생성가능한 CI들이 각각 출력된다. 4번 GPU의 GI들은 40기가가 한계이므로 생성가능 CI목록이 상대적으로 제한적임을 캐치하라\n\n\n\n\nScreenshot 2023-11-22 at 23.58.10.png"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#d.-ci-생성",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#d.-ci-생성",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "D. CI 생성",
    "text": "D. CI 생성\n- GPUdev=4 에서 생성가능한 CI 조회\n#nvidia-smi mig -i {GPU ID} -lcip\nnvidia-smi mig -i 4 -lcip\n\nNote: 각 GPU-인스턴스(GI)에서는 3개 계산-인스턴스(CI)를 만들수 있음. 만약에 Profile ID = 0 으로 만든다면 14의 계산능력을 가진 CI를 3개까지 만들수 있음, 만약 Profile ID = 2* 로 만든다면 42개의 계산능력을 가진 CI를 1개만 만들 수 있음\n\n\n\n\nScreenshot 2023-11-22 at 23.59.01.png\n\n\n- {GPUdev-ID:GI-ID} = {4:1} 에서 COMPUTE-INSTANCE-PROFILE-ID=0 에 해당하는 CI를 3개 생성\n#nvidia-smi mig -i {GPUdev-ID} -gi {GI-ID} -cci {COMPUTE-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -gi 1 -cci 0\n\nNote: 자원부족으로 3개까지 밖에 못만든다..\n\n\n\n\nScreenshot 2023-11-22 at 23.59.39.png\n\n\n- {GPUdev-ID:GI-ID}={4:2} 에서 COMPUTE-INSTANCE-PROFILE-ID=2 에 해당하는 CI를 1개 생성\n#nvidia-smi mig -i {GPUdev-ID} -gi {GI-ID} -cci {COMPUTE-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -gi 2 -cci 2 \n\nNote: 자원이 부족해서 1개밖에 못 만든다.\n\n\n\n\nScreenshot 2023-11-23 at 00.00.18.png\n\n\n- 현재 상황\n\n\n\nScreenshot 2023-11-23 at 00.01.04.png\n\n\n\n\n\nGPUdev ID\nGI ID\nCI ID\nMIGdev ID\n\n\n\n\n1\n0 (80G)\n0 (98SM)\n0\n\n\n2\n0 (80G)\n0 (98SM)\n0\n\n\n4\n1 (80G)\n0 (14SM)\n0\n\n\n4\n1 (80G)\n1 (14SM)\n1\n\n\n4\n1 (80G)\n2 (14SM)\n2\n\n\n4\n2 (80G)\n0 (42SM)\n3"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#a.-컨테이너-생성",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#a.-컨테이너-생성",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "A. 컨테이너 생성",
    "text": "A. 컨테이너 생성\n- 아래와 같은 방식으로 컨테이너 생성\n# nvidia-docker run --gpus '\"device={GPUdev-ID}:{MIGdev-ID}\"' -ti --rm -d -t -p {HOST-PORT}:{CONTAINER-PORT} {DOCKER-IMAGE-NAME} /bin/bash\nnvidia-docker run --gpus '\"device=1:0\"' -ti --rm -d -t -p 7749:7749  -p 1307:1307 ubuntu /bin/bash\nnvidia-docker run --gpus '\"device=2:0\"' -ti -d -t -p 4653:4653  -p 1212:1212 -p 1213:1213 -p 1214:1214 ubuntu /bin/bash\n\n-ti: 컨테이너를 대화형(interactive) 모드로 실행. 이 모드에서 컨테이너와 상호작용할 수 있음.\n--rm: 컨테이너가 종료되면 자동으로 컨테이너를 삭제. 이 옵션을 사용하면 컨테이너를 실행한 후 자동으로 정리.\n-d: 컨테이너를 백그라운드(background) 모드로 실행. 이 옵션을 사용하면 컨테이너가 백그라운드에서 실행되며 터미널이 차지되지 않음.\n-t: 컨테이너에 tty (터미널)를 할당. 이것은 대화형 모드와 함께 사용.\n/bin/bash: 컨테이너가 시작될 때 실행할 명령어. 이 경우, Bash 셸을 실행.\n\ndocker start\\(\\rightarrow\\) DOCKER 시작\ndocker ps\\(\\rightarrow\\) 실행중인 DOCKER container list, ps = process status\ndocker ps -a\\(\\rightarrow\\) 실행중인 DOCKER container list + stop된 container까지 모두\ndocker image ls\\(\\rightarrow\\) 다운로드한 이미지 목록\nnvidia-docker run --gpus '\"device=2:0\"' -ti -d -t -p 4653:4653  -p 1212:1212 ubuntu /bin/bash\n\\(\\rightarrow\\) gpus 플래그라고 하는데 잘 모르겠음..\n\\(\\rightarrow\\) device에서 2번 ID의 0번 gi를 의미함"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#b.-컨테이너-실행",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#b.-컨테이너-실행",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "B. 컨테이너 실행",
    "text": "B. 컨테이너 실행\ndocker exec -ti {CONTAINER-ID} bash\n\n여기에서 {CONTAINER-ID}는 docker ps 혹은 docker ps -a로 확인한다."
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#a.-passwd",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#a.-passwd",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "A. passwd",
    "text": "A. passwd\n- 아래를 실행하여 비밀번호를 바꿀것\npasswd root"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#b.-update",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#b.-update",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "B. update",
    "text": "B. update\n- 아래를 실행\napt update \napt install gcc\napt install build-essential\n업데이트 해야 vim 설치 되더라구"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#c.-쓸만한-패키지-설치",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#c.-쓸만한-패키지-설치",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "C. 쓸만한 패키지 설치",
    "text": "C. 쓸만한 패키지 설치\n- 아래를 설치하면 좋음..\napt install vim \napt install openssh-server\napt install git"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#d.-ssh",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#d.-ssh",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "D. ssh",
    "text": "D. ssh\n# apt install openssh-server\nvi /etc/ssh/sshd_config \nPort {My-SSH-Port}\nPermitRootLogin yes\nPasswordAuthentication yes\nservice ssh restart\nvi는 에디터임, i누르면 수정하는 거고 esc누르면 나옴.\nshift + ;로 : 만들면 text 작성 칸 나오는데, q하면 나오기 wq하면 저장하고 나오기 q!하면 강제 종료하기 임\n수정하고 그냥 q하려하면 안 나와진다."
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#e.-anaconda",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#e.-anaconda",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "E. anaconda",
    "text": "E. anaconda\n- 여기참고.."
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#f.-vscode",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#f.-vscode",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "F. vscode",
    "text": "F. vscode\n- 아래를 이용하여 설치\ncurl -Lk 'https://code.visualstudio.com/sha/download?build=stable&os=cli-alpine-x64' --output vscode_cli.tar.gz\ntar -xf vscode_cli.tar.gz\n- 아래를 이용하여 초기 설정 (깃헙아이디로 인증)\n./code tunnel \n- 초기설정 이후 아래를 이용하여 백그라운드에서 실행\nnohup ./code tunnel &"
  },
  {
    "objectID": "posts/1_Note/2023-11-22-DGX staion.out.html#g.-jupyter",
    "href": "posts/1_Note/2023-11-22-DGX staion.out.html#g.-jupyter",
    "title": "[Note] DGX station 설정_메모 추가",
    "section": "G. Jupyter",
    "text": "G. Jupyter\n- 암호설정: 여기로..\n- 주피터 실행할때 아래로 실행\njupyter lab --ip=\"0.0.0.0\" --port={MY-PORT} --no-browser --allow-root"
  },
  {
    "objectID": "2_ept.html",
    "href": "2_ept.html",
    "title": "EPT",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nJan 7, 2024\n\n\n[EPT]Review(EPT: An R package for ensemble patch transform)\n\n\nSEOYEON CHOI\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Lectures_ing",
      "**Studies**",
      "EPT"
    ]
  },
  {
    "objectID": "2_graph.html",
    "href": "2_graph.html",
    "title": "Graph",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nJul 2, 2023\n\n\nGraph Shift Operator\n\n\nSEOYEON CHOI\n\n\n\n\nJul 1, 2023\n\n\nNon-Euclidean vs Euclidean\n\n\nSEOYEON CHOI\n\n\n\n\nJun 30, 2023\n\n\nGraph Signal\n\n\nSEOYEON CHOI\n\n\n\n\nJun 30, 2023\n\n\nRegular Graph\n\n\nSEOYEON CHOI\n\n\n\n\nJan 15, 2023\n\n\n[CGSP] Chap 12.4: Node Subsampling for PSD Estimation\n\n\n신록예찬 \n\n\n\n\nDec 27, 2022\n\n\n[CGSP] Chap 12.2 ~ 3: Power Spectral Density and its Estimators\n\n\n신록예찬 \n\n\n\n\nDec 26, 2022\n\n\n[CGSP] Chap 12.2: Weakly Stationary Graph Processes\n\n\n신록예찬 \n\n\n\n\nDec 24, 2022\n\n\n[CGSP] Chap 8.3: Discrete Fourier Transform\n\n\n신록예찬 \n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Lectures_ing",
      "**Studies**",
      "Graph"
    ]
  }
]