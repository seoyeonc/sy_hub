<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.527">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="SEOYEON CHOI">
<meta name="dcterms.date" content="2023-09-20">

<title>Seoyeon’s Blog - [IT-STGCN]논문리비전_수정</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Seoyeon’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/md/"> 
<span class="menu-text">Lectures_ing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/chch/"> 
<span class="menu-text">Lectures_fastai</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/Research_area/"> 
<span class="menu-text">Research_ing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/ms/"> 
<span class="menu-text">Research_fastai</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/GODE_blog/"> 
<span class="menu-text">GODE</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/HCAM_blog/"> 
<span class="menu-text">HCAM</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://seoyeonc.github.io/ITTGNN_blog/"> 
<span class="menu-text">ITTGNN</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/seoyeonc"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><strong>[IT-STGCN]</strong>논문리비전_수정</li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title"><strong>[IT-STGCN]</strong>논문리비전_수정</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>SEOYEON CHOI </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 20, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../1_note.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><strong>Note</strong></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text"><strong>Studies</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../2_graph.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Graph</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#intro" id="toc-intro" class="nav-link active" data-scroll-target="#intro">1. intro</a></li>
  <li><a href="#related-works" id="toc-related-works" class="nav-link" data-scroll-target="#related-works">2. Related works</a></li>
  <li><a href="#backgrounds" id="toc-backgrounds" class="nav-link" data-scroll-target="#backgrounds">3. Backgrounds</a></li>
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section">4.</a></li>
  <li><a href="#experiments" id="toc-experiments" class="nav-link" data-scroll-target="#experiments">5. Experiments</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="2023-09-20-논문리비전_수정.out.out.ipynb" download="2023-09-20-논문리비전_수정.out.out.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="intro" class="level1">
<h1>1. intro</h1>
<p><code>-</code> 초록색은 나쁘지 않음. 하지만 아래의 내용을 보완하는게 좋음.</p>
<ul>
<li>분야의 예시로 신경과학, 환경데이터, 교통자료가 있는데 우리가 실제로 분석한 자료들이 사용된 논문을 찾아보며 예시를 들것 (Chickenpox, …) 사용하지 않더라도 예시를 들것.</li>
<li>이러한 자료를 분석하는것이 왜 어려운지 설명할 것. 즉 단순히 시계열로 해석하거나 공간자료로 해석하면 어떠한 문제가 있는지 간단히 서술할 것. (1~2문장) 레퍼런스 찾을것. (torch_geometric_temporal 의 도입부분 활용)</li>
</ul>
<p><code>기존</code></p>
<p>In recent years, the field of spatiotemporal datasets has emerged, enabling the simultaneous con- sideration of both the time and space dimensions. The examples include neuroscience(Atluri et al., 2016), environmental data(Thompson et al., 2014), traffic dynamics(Castro et al., 2013), and more. Specifically, traffic dynamics is a prevalent spatiotemporal dataset and is crucial because examining traffic data from both spatial and temporal perspectives can lead to advancements in traffic control. The incorporation of both spatial and temporal aspects enables a comprehensive understanding of complex phenomena, making spatiotemporal datasets invaluable for various applications and en- hancing the accuracy of predictive models.</p>
<p><code>참고</code></p>
<p>PyTorch Geometric Temporal: Spatiotemporal Signal Processing with Neural Machine Learning Models</p>
<ul>
<li>At the same time the existing geometric deep learning frameworks operate on graphs which have a fixed topology and it is also assumed that the node features and labels are static. Besides limiting assumptions about the input data, these off-the-shelf libraries are not designed to operate on spatiotemporal data.</li>
</ul>
<p>Spatio-Temporal Graph Convolutional Networks: A Deep Learning Framework for Traffic Forecasting</p>
<ul>
<li><p>Classic statistical and machine learning models are two major representatives of data-driven methods. In time- series analysis, autoregressive integrated moving average (ARIMA) and its variants are one of the most consolidated approaches based on classical statistics [Ahmed and Cook, 1979; Williams and Hoel, 2003]. However, this type of model is limited by the stationary assumption of time sequences and fails to take the spatio-temporal correlation into account. Therefore, these approaches have constrained representabil- ity of highly nonlinear traffic flow. Recently, classic statistical models have been vigorously challenged by machine learning methods on traffic prediction tasks.</p></li>
<li><p>Due to the high nonlinearity and complexity of traffic flow, tradi- tional methods cannot satisfy the requirements of mid-and-long term prediction tasks and often ne- glect spatial and temporal dependencies.</p></li>
</ul>
<p><code>수정</code></p>
<p>In recent years, the field of spatiotemporal datasets has emerged, enabling the simultaneous consider- ation of both the time and space dimensions. The examples include health data(Rozemberczki et al., 2021b), customer data(Rozemberczki et al., 2021a), energy data(Rozemberczki et al., 2021a), neu- roscience(Atluri et al., 2016), environmental data(Thompson et al., 2014), traffic dynamics(Castro et al., 2013), and more. Specifically, traffic dynamics is a prevalent spatiotemporal dataset and is crucial because examining traffic data from both spatial and temporal perspectives can lead to ad- vancements in traffic control. Classic time-series statistical methods to analyze those kind of data already exist, but they are limited by certain conditions, such as assumptions about the data. Specif- ically, these classic methods cannot account for spatiotemporal correlations and are not designed to work with spatiotemporal data(Yu et al., 2017; Rozemberczki et al., 2021a). In result, when we analize spatiotemporal data to use enough information, we can improve accuracy during us- ing appropriate geometric deep learning frameworks.</p>
<hr>
<p><code>-</code> 붉은부분</p>
<ul>
<li>의도는 좋으나 <code>sparse data</code> 는 올바르지 않은 표현임. missing, irregulary observed data 등으로 설명할 것.</li>
<li>이러한 자료가 왜 발생하는지 설명할 것. (이부분은 레퍼런스 필요) 이러한 자료를 처리하는 것이 어려운 이유를 설명할 것.[1]</li>
<li>우리의 아이디어는 “호모지니우스하지 않은 그래프 -&gt; 호모지니우스화 시킴” 인데 이러한 방식은 이상한방식이 아님. Yu et al.&nbsp;(2017) and Guo et al.&nbsp;(2019) Bai et al.&nbsp;(2020), Li et al.&nbsp;(2019), Zhao et al.&nbsp;(2019) 이 우리와 비슷한 연구를 했음.</li>
</ul>
<p><code>-</code>기존</p>
<p>However, when dealing with spatiotemporal datasets, sparse data is a common occurrence, which is unpredictable. For example, the sensor data from machines representing a spatiotemporal dataset may contain missing values due to unexpected events like sensor malfunction or temporal factors such as distance or time delay. It is a simple way to use interpolation methods like linear, nearest, etc. However, these methods can occasionally be imprecise in producing estimates. Moreover, in a method of learning spatiotemporal data Yu et al.&nbsp;(2017) and Guo et al.&nbsp;(2019) try to learn data after making it to be complete, i.e., allocate to other values from missing data with linear interpolation. Graph Convolution Network(GCN) is also a needed interpolation method before learning. Furthermore, Bai et al.&nbsp;(2020), Li et al.&nbsp;(2019), Zhao et al.&nbsp;(2019) tried to fill missing values by linear interpolation.</p>
<p><code>-</code> 참고</p>
<p>Traffic Speed Prediction with Missing Data based on TGCN</p>
<ul>
<li><p>In addition, there usually contains missing values in the collected data of traffic sensors due to the electronics unit failure. As is shown in Fig.1, There exist a lot of missing values during 22:00-24:00. This can decrease the prediction accuracy of aforementioned prediction models.</p></li>
<li><p>For the proposed model, if the input time series contains missing values, the model will produce failure because of the missing values can not be computed during the training process.</p></li>
</ul>
<p>Missing Data: Our View of the State of the Ar</p>
<ul>
<li>Why do missing data create such difficulty in scientific research? Because most data analysis procedures were not designed for them. Missingness is usually a nuisance, not the main focus of inquiry, but handling it in a principled manner raises conceptual difficulties and computational challenges</li>
</ul>
<p>LSTM-based traffic flow prediction with missing data</p>
<ul>
<li>Nevertheless, due to missing data, irregular sampling, and varying length, the data remain difficult to explore with high efficiency. In a traffic environment, this problem becomes even worse because the traffic sensors are often controlled manually.</li>
</ul>
<p>Graph neural networks: A review of methods and applications</p>
<ul>
<li>Homogeneous/Heterogeneous Graphs. Nodes and edges in ho- mogeneous graphs have same types, while nodes and edges have different types in heterogeneous graphs. Types for nodes and edges play important roles in heterogeneous graphs and should be further considered.</li>
</ul>
<p>T-GCN: A Temporal Graph Convolutional Network for Traffic Prediction</p>
<ul>
<li>Since the Los-loop dataset contained some missing data, we used the linear interpolation method to fill missing values.</li>
</ul>
<p>Spatio-Temporal Graph Convolutional Networks: A Deep Learning Framework for Traffic Forecasting</p>
<ul>
<li>The linear interpolation method is used to fill missing values after data cleaning. In addition, data input are normalized by Z-Score method.</li>
</ul>
<p>Adaptive Graph Convolutional Recurrent Network for Traffic Forecasting</p>
<ul>
<li>Data Preprocess: The missing values in the datasets are filled by linear interpolation. Then, both datasets are aggregated into 5-minute windows, resulting in 288 data points per day.</li>
</ul>
<p><code>-</code> 수정</p>
<p>Dealing with spatiotemporal datasets often presents a common challenge, which is the frequent occurrence of irregularly observed data. For instance, as highlighted by (Ge et al., 2019), traffic sensor data commonly suffers from missing observations due to electronic unit failures, which can significantly impact prediction accuracy. The difficulty in handling irregular data arises for several reasons. First, many traditional data analysis procedures were designed for datasets with complete observations Schafer &amp; Graham (2002). Second, when dealing with time-series datasets containing missing data, attempting to learn from such data can lead to challenges as it may result in the failure to capture certain time points Ge et al.&nbsp;(2019); Tian et al.&nbsp;(2018). That’s the reason why it’s important to transform incomplete data into complete data before conducting any learning or analysis.</p>
<p>Before move on to introduce our purpose, we need a definition of graph signal. To describe the geometric structures of data domain, graphs are well known as generic data representation forms(Shuman et al., 2013). So in this paper, we interpret data as Gt = (Vt,Et), V means ver- tics and E means edges. On specific Gt, it has a finite collection of samples and we call it as a graph signal(Shuman et al., 2013). Now, we would like to show the purpose of this paper that is mak- ing complete data when we approach the irregularly data. To satisfy this condition, we recognize the data not the heterogeneous graph, but the homogeneous graph by interpolation. Homogeneous graphs have same types of nodes and edges, and hetero geneous graphs have different types of them(Zhou et al., 2020). In a method of learning spatiotemporal data, Bai et al.&nbsp;(2020); Zhao et al.&nbsp;(2019); Yu et al.&nbsp;(2017); Guo et al.&nbsp;(2019) try to learn data after making it to be complete, i.e., allocate to other values from missing data with linear interpolation. In our proposed method, it is crucial to rightly estimate the underlying function when training spatiotemporal dataset because the functions define the expected pattern of the data. And that pattern would affect to read the trend of datasets. However it can be hard to estimate when it has many percentage of missing date.</p>
<hr>
<p><code>-</code> 아래식은 틀렸음. 이건 회귀모형이 아님.. GNAR의 notation을 사용하여 모형을 다시표현해볼것..</p>
<div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="attachment:2023-09-14-논문리비전_files/figure-ipynb/1f340f80-39bb-472a-9e0e-580bd25d4923-1-c5fb64d9-d118-4471-8fe0-aae33707f34b.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<ul>
<li>이부분이 아주 클리어 해야함</li>
<li>사용하는 대부분의 Notations들이 정리되어야함.</li>
<li>intro에 쓰는 것이 부담스러우면 제외해도 무방</li>
<li>뒤에 self consistence estimator에 사용할 Notation을 함께 고려</li>
</ul>
<p><code>-</code> 빨간부분 삭제후 다시 작성 (혹은 공부할 것)</p>
<div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="attachment:2023-09-14-논문리비전_files/figure-ipynb/df78f19b-d302-4397-b41e-fc5d667d348c-1-47f23b5c-8859-4c66-9a4e-9ce9a22e7ae7.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p><code>-</code> 초록색부분은 나쁘지 않음</p>
<div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="attachment:2023-09-14-논문리비전_files/figure-ipynb/8db3d5da-fff0-4ad3-b1d6-e7c4c3991f77-1-d1c03028-6fdf-42f6-9c7d-d7d73158310b.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p><code>기존</code></p>
<p>After interpolation to learn dataset, we can write a model as <span class="math display">\[y_i =f(x_i)+ε_i,\]</span> f(xi) represents the underlying function, and εi is thought to follow a normal distribution. In this paper, we try to train yi as eliminate sparse strong signal of εi to get lower mean square error between test data and predicted data. In other word, we study to remain εi without points which can consider heavier tails. In our proposed method, it is crucial to rightly estimate the underlying function f when training spatiotemporal dataset because the functions define the expected pattern of the data. And that pattern would affect to read the trend of datasets. However it can be hard to estimate f when it has many percentage of missing date.</p>
<p><code>수정</code></p>
<p>삭제함</p>
<hr>
</section>
<section id="related-works" class="level1">
<h1>2. Related works</h1>
<p><code>-</code> 2.1과 2.2를 왜 리뷰하는지 설명이 필요함</p>
<p><code>-</code> 2.1에서 왜 Convolution Operator에 집중하는지 설명이 필요</p>
<p><code>-</code> 2.2에서 왜 Dynamic graphs에 집중하는지 설명이 필요</p>
<p><code>-</code> 전체적으로 이름은 related works인데 뭐가 related 되어있길래 이런것들을 소개하는지 클리어하지 않음. (솔직히 저도 저 방법들이 우리랑 뭔 관련있는지 잘모르겠어요)</p>
<p><code>-</code> 기존</p>
<p>RELATED WORK</p>
<p>2.1 PROPAGATION MODULE</p>
<p>To start build the model with the simple graph structure, we can use computational modules which are the propagation module, the sampling module, and the pooling module. Especially, the prop- agation module is a commonly used computational module. It utilizes convolution and recurrent operators to aggregate information about neighbors. The skip operation is a rule of gathering infor- mation from past representations and mitigating the over-smoothing problem. It can be divided into two types: convolutional and recurrent operator(Zhou et al., 2020) and we focus on colvolutional operator. 2Under review as a conference paper at ICLR 2024</p>
<p>Convolutional Operator The convolutional operator can be considered a combination of spectral and spatial methods. First, there are a few classic models, which are spectral approaches: Spec- tral Network, ChebNet, and Adaptive Graph Convolution Network(AGCN). The spectral network is proposed by Bruna et al.&nbsp;(2013), which is defined as the characteristics of convolutions in the Fourier domain, which are determined by the eigendecomposition of the graph Laplacian. ChebNet, suggested by Defferrard et al.&nbsp;(2016), employed the K-localized convolution to construct a convolu- tional neural network that could avoid calculating eigenvectors of Laplacian. AGCN(Li et al., 2018) follows the relationship of the spatial aspect, at the same time, uses the residual graph Laplacian, and Li et al.&nbsp;(2018) called it an Adaptive graph. Next are the spatial approaches. The concept of Neural Frames Per Second (Neural FPS) is introduced by Duvenaud et al.&nbsp;(2015). They utilize dif- ferent weight matrices based on nodes with different degrees, but this approach may not be scalable to handle large-scale data. There is a model called Patchy-san proposed by Niepert et al.&nbsp;(2016). In the first step of this model, they select k numbers of neighbors of nodes. After normalizing around k neighbors, the model functions as a receptive field. The Diffusion-Convolutional Neural Net- works(DCNNs) of Atwood &amp; Towsley (2016) are also considered the neighbor between nodes and can be used in classification by changing edges and adjacency matrix. DCNN uses the metrics of transition to get the neighborhood for nodes. The Dual Graph Convolutional Networks (DGCN) pro- posed by Zhuang &amp; Ma (2018) consider local and global consistency. Gao et al.&nbsp;(2018) proposed the Learnable Graph Convolutional Networks (LGCN), which is based on the Learnable Graph Convo- lutional Layer, and the layer transforms the graph into a 1-D format, taking into account the number of nodes for definition.</p>
<p>2.2 GRAPH TYPE AND SCALE</p>
<p>It is important to consider there is not the only simple type graphs. So, we can approach to face variant grape types for real world data which is complex. The graphs’ classification categories can be directed/undirected, Homogeneous/heterogeneous, and static/dynamic graphsZhou et al.&nbsp;(2020). The directed graph can be called when edges of graph are connected, and the undirected graph means the opposite. The directed graph is better than the undirected graph because the first one has more information than the second one. The homogeneous graph has the same types of nodes and edges; however, the heterogeneous graph has different types. That means that information on nodes and edges is important when we analyze the heterogeneous graph. We can call a dynamic graph if the input features or graph topology change. It is reasonable that time points should be considered carefully there rather than a static graph. Zhou et al.&nbsp;(2020) also propose a classification of graphs based on their scale and type, which includes directed, heterogeneous, dynamic, hypergraph, signed, and large graphs.</p>
<p>Dynamic graphs Among them, we focus on the dynamic graph. Spatial and temporal informa- tion is collected on DCRNN(Diffusion Convolution Recurrent Neural Network)(Li et al., 2017) and STGCN(Spatio-temporal graph convolutional networks)(Yu et al., 2017). In detail, DCRNN gets the spatial data by GNN and then transfer the output to sequence-to-sequence or the sequence model such as RNN to consider temporal dependency and STGCN stacks multiple statio-temporal con- volutional blocks which are consisted one spatil graphconvolutional layer and two temporal gate convolutional layers. On the other hand, Structure-RNN(Jain et al., 2016) and ST-GCN(Yan et al., 2018) simultaneously capture spatial and temporal messages. To enable the application of traditional GNNs on the extended graphs, both Structural-RNN and ST-GCN expand the static graph structure by incorporating temporal connections. Structual-RNN adds edges between consecutive time steps, representing nodes and edges with nodeRNNs and edgeRNNs in a bipartite graph. ST-GCN involves constructing spatiotemporal graphs by stacking graph frames from each time step. However, Pareja et al.&nbsp;(2020) argue that using node features in learning can impact the model’s performance and propose EvolceGCN, a method designed for dynamic graphs.</p>
<p><code>-</code> 참고</p>
<ol type="1">
<li>snapshot이 homogeneous가 아닌데 missing 부분을 채워 넣어 homogeneuos graph 로 해석하고 분석</li>
</ol>
<p>위에서 언급한 저자들 입력</p>
<p>Spatio-Temporal Graph Convolutional Networks: A Deep Learning Framework for Traffic Forecasting(Bing Yu, Haoteng Yin, Zhanxing Zhu)</p>
<ul>
<li>The linear interpolation method is used to fill missing values after data cleaning. In addition, data input are normalized by Z-Score method.</li>
</ul>
<p>Graph Markov network for traffic forecasting with missing data</p>
<ul>
<li>We denote the completed state by, in which all missing values are filled based on historical data</li>
</ul>
<ol start="2" type="1">
<li>아예 full로 데이터가 존재한다고 가정하고 homogenous graph 로 보고 제시된 방법론</li>
</ol>
<p>Scalable Spatiotemporal Graph Neural Networks(Andrea Cini, Ivan Marisca, Filippo Maria Bianchi, Cesare Alippi)</p>
<ul>
<li>The first dataset contains data coming from the Irish Commission for Energy Reg- ulation Smart Metering Project (CER-E; Commission for Energy Regulation 2016), which has been previously used for benchmarking spatiotemporal imputation methods (Cini, Marisca, and Alippi 2022);however, differently from previ- ous works, we consider the full sensor network consisting of 6435 smart meters measuring energy consumption ev- ery 30 minutes at both residential and commercial/industrial premises.</li>
</ul>
<ol start="3" type="1">
<li>처음부터 heterogeneous graph를 input data로 가정하며 만들어진 방법론</li>
</ol>
<p>Learning Deep Representation from Big and Heterogeneous Data for Traffic Accident Inference(Quanjun Chen, Xuan Song, Harutoshi Yamada, Ryosuke Shibasaki)</p>
<ul>
<li>By mining big and hetero- geneous data, we aim to understand and develop a general model to estimate traffic accident risk. With the input of real- time GPS data, our model can simulate traffic accident risk on a large scale.</li>
<li>We extract hierarchical feature representation of meshed human mobility data from Stack denoise Autoencoder (SdAE), for a more efficient and precise prediction of risk levels in supervised learning.</li>
</ul>
<p>ISTD-GCN: Iterative Spatial-Temporal Diffusion Graph Convolutional Network for Traffic Speed Forecasting(Yi Xie, Yun Xiong, Yangyong Zhu)</p>
<ul>
<li>Therefore, we can model such heterogeneous spatial-temporal structures as a homogeneous process ofdiffusion</li>
</ul>
<p><code>-</code> 수정</p>
<p>As we mentioned, irregular spatiotemporal data is often encountered in the real world. It is well- known that neural networks are better suited for regular data. Therefore, many attempts have been made to transform data with different structures into the same structure through snapshots. If we interpret this as a graph, we can divide it into homogeneous graphs and heterogeneous graphs. Ho- mogeneous graphs have the same types of nodes and edges, while heterogeneous graphs do not(Zhou et al., 2020). There are Numerous methods to address the challenge of dealing with this issue. For instance, to fill missing values, Bai et al.&nbsp;(2020); Yu et al.&nbsp;(2017); Guo et al.&nbsp;(2019) employ linear in- terpolation, while Cui et al.&nbsp;(2020) utilize historical data. All of them tried to convert heterogeneous graph into homogeneous graph. However, if we create regular data using interpolation methods, the result may have low accuracy. Additionally, Cini et al.&nbsp;(2023) assume that the input data is originally complete, which is equivalent to interpreting the data as a homogeneous graph from the beginning. Furthermore, Chen et al.&nbsp;(2016); Xie et al.&nbsp;(2020) proposed a general model that treats input data as a heterogeneous graph, assuming a lack of supported sensing data. It might be efficient to handle data with a heterogeneous structure in each snapshot. But the real data often represents homogeneous graph and the missing values transforms it into a heterogeneous graph, that means the structures of every snapshot are not different.</p>
</section>
<section id="backgrounds" class="level1">
<h1>3. Backgrounds</h1>
<p><code>-</code> 좋아요</p>
<p><code>-</code> 자잘한건 제가 수정하면 될 듯합니다.</p>
</section>
<section id="section" class="level1">
<h1>4.</h1>
<p><code>-</code> 내용을 좀 더 팬시하게 쓸 필요가 있어보임</p>
<p><code>-</code> 아래부분을 정리하여 알고리즘화 해야함.</p>
<div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2023-09-20-논문리비전_수정.out_files/figure-html/7f30d76f-2ff9-41ea-9a74-170dc6d2bd78-1-2023-09-14-논문리비전_files/figure-ipynb/cb8b7d22-d4b4-4633-aa8c-a30e2d18fdfd-1-359a9447-a5b6-43bc-b490-f2a8bc2e404f.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p><code>-</code> 기존</p>
</section>
<section id="experiments" class="level1">
<h1>5. Experiments</h1>
<p><code>-</code> 아직 덜 읽어봄</p>
<p><code>-</code> 데이터 설명은 Appendix에, 실험결과와 Fig는 본문에 있는게 좋음</p>
<p>[1] 보통 결측없이 모두 관측한상태에서는 모형이 잘 동작함, 대부분의 spatio temporal data는 각각의 스냅샷마다 동일한 그래프구조를 가진다는 가정을 사용함. 스냅샷마다 그래프구조가 다른 경우를 가정하는 모형도 있음. 그러한 모형의 예시는 A,B,C,…. 등이 있음. 하지만 이러한 연구는 애초에 데이터가 스냅샷마다 non-호모지니우스하게 생겼으면 효율적일 수 있으나, 실제true model은 스냅샷마다 그래프구조가 동일하다고 여겨지지만 결측치로 인하여 스냅샷마다 호모지니우스가 깨지는 경우는 효율적이지 않을 수 있음. 우리는 이 부분에 초점을 맞추었음. 우리의 아이디어는 호모지니우스 하지 않은 그래프를 A,B,C, 등을 이용하여 그대로 처리하는것 보다 missing을 처리하여 호모지니우스하게 강제로 만들고 그 자료를 분석하자는 아이디어임.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="seoyeonc/sy_hub" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>